<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>render engine/test</title>
    <link href="/2025/03/06/render-engine-test/"/>
    <url>/2025/03/06/render-engine-test/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>3. Lumen - Radiance Cache</title>
    <link href="/2025/03/04/Render%20Engine/UE5/Lumen/3.%20Radiance%20Cache/"/>
    <url>/2025/03/04/Render%20Engine/UE5/Lumen/3.%20Radiance%20Cache/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>Lumen 中的 radiance cache 是基于 world probe 实现的，与 DDGI 不同，radiance cache probe 仅用于补充世界空间的 radiance 信息，例如 screen probe、reflection 的光线样本都有可能采样到 radiance cache。</p><p><code>LumenRadianceCache::UpdateRadianceCaches</code>为radiance cache更新入口，被IrradianceFieldGather、ScreenProbe、TranslucencyVolumeLighting三处调用到，其中IrradianceFieldGather与ScreenProbe是为像素提供indirect diffuse的两种方式，本文仅讲述 ScreenProbe 部分的调用。</p><h1 id="2-宏观逻辑"><a href="#2-宏观逻辑" class="headerlink" title="2 宏观逻辑"></a>2 宏观逻辑</h1><h1 id="3-实现"><a href="#3-实现" class="headerlink" title="3 实现"></a>3 实现</h1><h2 id="3-1-层级分布"><a href="#3-1-层级分布" class="headerlink" title="3.1 层级分布"></a>3.1 层级分布</h2><p>radiance cache 的 world probe 是基于 clipmap 的分布方式</p><h3 id="3-1-1-Clipmap-介绍"><a href="#3-1-1-Clipmap-介绍" class="headerlink" title="3.1.1 Clipmap 介绍"></a>3.1.1 Clipmap 介绍</h3><p>Clipmap <a href="#%5B1%5D">[1]</a>  提出是为了解决mipmap的内存开销问题，一个非常大的mipmap实际渲染中，只会根据相机视角用到很小的部分。Clipmap的字面意思就是将原 mipmap 裁剪得到一个将会被使用的较小区域，物理显存中只会维持这个区域，根据视角加载原mipmap的相关数据。下面左图是mipmap执行clip操作的示意图，右图是clipmap的两部分，</p><ul><li>Clipmap Stack：层级大小超过clip size，这部分不同层的大小都是 clip size</li><li>Clipmap Pyramid：层级大小低于clip size，这部分不同层的大小与原mipmap对应层级相同</li></ul><img src="/images/Render Engine/UE5/Lumen/3. Radiance Cache/image-20250214104203219.png" alt="image-20250214104203219" style="zoom:80%;"><p>在clipmap stack部分，虽然每一层级的大小都相同，但覆盖范围会越来越大。在视角移动加载数据时，clipmap使用环形寻址的方式来避免多次加载相同的数据，如下示意图，</p><img src="/images/Render Engine/UE5/Lumen/3. Radiance Cache/image-20250214104350600.png" alt="image-20250214104350600" style="zoom:80%;"><h3 id="3-1-2-World-Probe-的-3D-clipmap-结构"><a href="#3-1-2-World-Probe-的-3D-clipmap-结构" class="headerlink" title="3.1.2 World Probe 的 3D clipmap 结构"></a>3.1.2 World Probe 的 3D clipmap 结构</h3><p>二维clipmap中的一个texel在3D clipmap中对应一个3D cell (probe)，world probe 的3D clipmap结构是以相机为中心的包围盒区域，每个层级的probe数量相同，但覆盖范围不同，也就是层级越高的grid对应的3D区域越大。</p><img src="/images/Render Engine/UE5/Lumen/3. Radiance Cache/v2-10d3d573f85b66583a847b8653946aa8_r.jpg" alt="v2-10d3d573f85b66583a847b8653946aa8_r" style="zoom:67%;"><p>world probe 的分布记录在 <code>FRadianceCacheState</code> 的下面成员中，<code>UpdateRadianceCacheState</code>负责 world probe 的层级分布的更新。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">TArray&lt;FRadianceCacheClipmap&gt; Clipmaps;<br><span class="hljs-type">float</span> ClipmapWorldExtent = <span class="hljs-number">0.0f</span>;<span class="hljs-comment">// 覆盖范围的一半</span><br><span class="hljs-type">float</span> ClipmapDistributionBase = <span class="hljs-number">0.0f</span>;<br></code></pre></td></tr></table></figure><p>clipmap的层级数量、每一层级的grid数量以及每一层级的覆盖范围，都有对应命令行调整</p><table><thead><tr><th>cmd</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>r.Lumen.ScreenProbeGather.RadianceCache.NumClipmaps</td><td>int32</td><td>一共多少层级</td></tr><tr><td>r.Lumen.ScreenProbeGather.RadianceCache.ClipmapWorldExtent</td><td>float</td><td>0级覆盖的世界范围的一半，立方体区域</td></tr><tr><td>r.Lumen.ScreenProbeGather.RadianceCache.ClipmapDistributionBase</td><td>float</td><td>0级之后的世界范围指数增长的base，即 extent * pow(level)</td></tr><tr><td>r.Lumen.ScreenProbeGather.RadianceCache.GridResolution</td><td>int32</td><td>每一层的probe数量，每个维度probe数量相同</td></tr></tbody></table><p>下面是基于这些配置参数对层级分布的更新，主要是以相机位置为中心构建clipmap空间。一个clipmap空间，坐标单位是CellSize，原点为 clipmap 起点，中心点为相机所位于cell的中心。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FRadianceCacheClipmap</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>FVector Center; <span class="hljs-comment">// clipmap 包围盒</span><br><span class="hljs-type">float</span> Extent;<br><br>FVector3f CornerTranslatedWorldSpace;<span class="hljs-comment">// clipmap 包围盒起点相对于相机中心点的偏移，一个世界坐标点可通过此偏移变换到clipmap空间下</span><br><br><span class="hljs-type">float</span> ProbeTMin;<span class="hljs-comment">// 用于光追</span><br><br><span class="hljs-comment">/** Offset applied to UVs so that only new or dirty areas of the volume texture have to be updated. */</span><br>FVector VolumeUVOffset;<br><span class="hljs-type">float</span> CellSize;<span class="hljs-comment">// 两个相邻 probe 之间的距离</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>相机位置 NewViewOrigin，各成员计算为</p><ul><li>Center &#x3D; SnappedOrigin &#x3D; floor(NewViewOrigin &#x2F; CellSize) * CellSize，相机位置对齐到 CellSize 的世界坐标</li><li>Extent：clipmap 包围盒范围的一半</li><li>CornerTranslatedWorldSpace：SnappedOrigin - 0.5 * CellSize - Extent + PreViewTranslation<br>clipmap 的起始位置，再偏移 0.5 * CellSize 到 cell 中心点，也就是以起点为原点的坐标系的偏移量</li><li>ProbeTMin：用于光追 TMin，CellLength * ProbeTMinScale (半透明情况下ProbeTMinScale 为 1，否则为 0.1)</li></ul><h3 id="3-1-3-shader-中的-clipmap-变换"><a href="#3-1-3-shader-中的-clipmap-变换" class="headerlink" title="3.1.3 shader 中的 clipmap 变换"></a>3.1.3 shader 中的 clipmap 变换</h3><h4 id="3-1-3-1-ProbeCoord-ProbeWorldPosition"><a href="#3-1-3-1-ProbeCoord-ProbeWorldPosition" class="headerlink" title="3.1.3.1 ProbeCoord &lt;-&gt; ProbeWorldPosition"></a>3.1.3.1 ProbeCoord &lt;-&gt; ProbeWorldPosition</h4><p>有了clipmap，在 shader 可以将一个世界坐标变换为指定层级的clipmap空间下 probe coord，以及将 probe coord 变换到世界空间下，例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">float3 <span class="hljs-title">GetRadianceProbeCoordFloat</span><span class="hljs-params">(float3 ProbeWorldPosition, uint ClipmapIndex)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> float3 ProbeTranslatedWorldPosition = ProbeWorldPosition + <span class="hljs-built_in">DFHackToFloat</span>(PrimaryView.PreViewTranslation);<br><br><span class="hljs-type">const</span> float3 CornerTranslatedWorldPosition = <span class="hljs-built_in">GetRadianceProbeClipmapCornerTWS</span>(ClipmapIndex);<br><span class="hljs-type">const</span> float3 CornerToProbe = ProbeTranslatedWorldPosition - CornerTranslatedWorldPosition;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> CellSize = <span class="hljs-built_in">GetRadianceProbeClipmapCellSize</span>(ClipmapIndex);<br><span class="hljs-keyword">return</span> CornerToProbe / CellSize;<br>&#125;<br><br><span class="hljs-function">float3 <span class="hljs-title">GetProbeTranslatedWorldPositionNoOffset</span><span class="hljs-params">(uint3 ProbeCoord, uint ClipmapIndex)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> float3 CornerTranslatedWorldPosition = <span class="hljs-built_in">GetRadianceProbeClipmapCornerTWS</span>(ClipmapIndex);<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> CellSize = <span class="hljs-built_in">GetRadianceProbeClipmapCellSize</span>(ClipmapIndex);<br><br><span class="hljs-type">const</span> float3 CornerToProbe = (ProbeCoord + <span class="hljs-number">0.5</span>) * CellSize;<br><span class="hljs-keyword">return</span> CornerTranslatedWorldPosition + CornerToProbe;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-3-2-查找给定WorldPosition"><a href="#3-1-3-2-查找给定WorldPosition" class="headerlink" title="3.1.3.2 查找给定WorldPosition"></a>3.1.3.2 查找给定WorldPosition</h4><p>对于一个被 level i 覆盖的世界坐标，肯定会被后续大于 i 层级覆盖，那么到底采样哪一层级？优先选择最低层级，因此在仅给定世界坐标来获取probe coord以及层级时，从最低层级到最高层级依次遍历，直至找到覆盖该坐标的层级为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">FRadianceProbeCoord <span class="hljs-title">GetRadianceProbeCoord</span><span class="hljs-params">(float3 WorldPosition, <span class="hljs-type">float</span> ClipmapDitherRandom)</span></span><br><span class="hljs-function"></span>&#123;<br>FRadianceProbeCoord Out = (FRadianceProbeCoord)<span class="hljs-number">0</span>;<br>Out.ClipmapIndex = NumRadianceProbeClipmapsForMark;<br><br>uint ClipmapIndex = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; ClipmapIndex &lt; NumRadianceProbeClipmapsForMark; ++ClipmapIndex) &#123;<br>float3 ProbeCoordFloat = <span class="hljs-built_in">GetRadianceProbeCoordFloatForMark</span>(WorldPosition, ClipmapIndex);<br>float3 BottomEdgeFades = <span class="hljs-built_in">saturate</span>((ProbeCoordFloat - <span class="hljs-number">.5f</span>) * InvClipmapFadeSizeForMark);<br>float3 TopEdgeFades = <span class="hljs-built_in">saturate</span>(((float3)RadianceProbeClipmapResolutionForMark - <span class="hljs-number">.5f</span> - ProbeCoordFloat) * InvClipmapFadeSizeForMark);<br><span class="hljs-type">float</span> EdgeFade = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min3</span>(BottomEdgeFades.x, BottomEdgeFades.y, BottomEdgeFades.z), <span class="hljs-built_in">min3</span>(TopEdgeFades.x, TopEdgeFades.y, TopEdgeFades.z));<br><br>int3 ProbeMinCoord;<br>int3 ProbeMaxCoord;<br>ProbeMinCoord = <span class="hljs-built_in">floor</span>(ProbeCoordFloat - <span class="hljs-number">0.5f</span>);<br>ProbeMaxCoord = ProbeMinCoord + <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span> (EdgeFade &gt; ClipmapDitherRandom) &#123;<br>Out.ProbeMinCoord = ProbeMinCoord;<br>Out.ProbeMaxCoord = ProbeMaxCoord;<br>Out.ClipmapIndex  = ClipmapIndex;<br><span class="hljs-keyword">return</span> Out;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> Out;<br>&#125;<br></code></pre></td></tr></table></figure><p>在实际实现中，相邻两个层级的边界上由于层级跳变，效果上会出现明显的边界感。因此在层级边缘会设置一定范围的fade区域，当采样到fade区域时，会引入一个抖动值 <code>ClipmapDitherRandom</code>。fade 区域定义为距clipmap边界的grid单位，默认 <code>GLumenTranslucencyVolumeRadianceCacheClipmapFadeSize(4)</code>，上述中的 <code>InvClipmapFadeSizeForMark</code> 为倒数：</p><ul><li>当不在fade区域时，EdgeFade &gt;&#x3D; 1，EdgeFade &gt; ClipmapDitherRandom 恒为 true</li><li>当在fade区域时，EdgeFade &lt; 1，最终在上下相邻层级中随机采样一个</li></ul><h2 id="3-2-构建probe更新列表"><a href="#3-2-构建probe更新列表" class="headerlink" title="3.2 构建probe更新列表"></a>3.2 构建probe更新列表</h2><h3 id="3-2-1-indirect-数据更新"><a href="#3-2-1-indirect-数据更新" class="headerlink" title="3.2.1 indirect 数据更新"></a>3.2.1 indirect 数据更新</h3><p>DDGI 的world probe负责插值得到某一点的irradiance，同时在计算光线radiance时还会采样上一帧的irradiance来近似无限反弹的结果，这意味着像素会采样周围probe得到其接收的间接 irradiance，而次级反射点同样需要采样其周围world probe。在 Lumen 里，无限反弹由 surface cache 的 radiosity 部分完成，radiance cache probe 的 radiance 来采样 surface cache 得到的，已经具有无限反弹的结果，因此只需要更新被使用到的 probe。</p><p>在标记使用状态之前，先将 <code>RadianceProbeIndirectionTexture</code> 中的每个probe状态重置为 <code>INVALID_PROBE_INDEX</code>。RadianceProbeIndirectionTexture 是一个 3D texture，记录了所有clipmap层级的每个probe的使用状态。每个层级的probe数量相同，在 x 维度逐层级并排排列在贴图中，假如 probe 数量为 48x48x48，有层级0 [0<del>47, 0</del>47, 0<del>47]，层级 1 [48</del>95, 0<del>47, 0</del>47]。</p><p><code>ScreenGatherMarkUsedProbes</code>表示被screen probe使用到的 world probe，主要实现在 shader <code>MarkRadianceProbesUsedByScreenProbesCS</code>中，遍历每个screen probe：</p><ul><li><p>通过变换得到 screen probe 的 WorldPosition</p></li><li><p>获取覆盖screen probe的最小clipmap层级<br><code>uint ClipmapIndex = GetRadianceProbeClipmapForMark(WorldPosition, 0);</code></p></li><li><p>层级有效，在 indirection texture 将包裹screen probe的 8 个 world probes 标记为使用状态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MarkPositionUsedInIndirectionTexture</span><span class="hljs-params">(float3 WorldPosition, uint ClipmapIndex)</span></span><br><span class="hljs-function"></span>&#123;<br>float3 ProbeCoordFloat = <span class="hljs-built_in">GetRadianceProbeCoordFloatForMark</span>(WorldPosition, ClipmapIndex);<br>int3 BottomCornerProbeCoord = <span class="hljs-built_in">floor</span>(ProbeCoordFloat - <span class="hljs-number">0.5f</span>);<br><br><span class="hljs-built_in">MarkProbeIndirectionTextureCoord</span>(BottomCornerProbeCoord + <span class="hljs-built_in">int3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ClipmapIndex);<br><span class="hljs-built_in">MarkProbeIndirectionTextureCoord</span>(BottomCornerProbeCoord + <span class="hljs-built_in">int3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), ClipmapIndex);<br><span class="hljs-built_in">MarkProbeIndirectionTextureCoord</span>(BottomCornerProbeCoord + <span class="hljs-built_in">int3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), ClipmapIndex);<br><span class="hljs-built_in">MarkProbeIndirectionTextureCoord</span>(BottomCornerProbeCoord + <span class="hljs-built_in">int3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), ClipmapIndex);<br><span class="hljs-built_in">MarkProbeIndirectionTextureCoord</span>(BottomCornerProbeCoord + <span class="hljs-built_in">int3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ClipmapIndex);<br><span class="hljs-built_in">MarkProbeIndirectionTextureCoord</span>(BottomCornerProbeCoord + <span class="hljs-built_in">int3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), ClipmapIndex);<br><span class="hljs-built_in">MarkProbeIndirectionTextureCoord</span>(BottomCornerProbeCoord + <span class="hljs-built_in">int3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), ClipmapIndex);<br><span class="hljs-built_in">MarkProbeIndirectionTextureCoord</span>(BottomCornerProbeCoord + <span class="hljs-built_in">int3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), ClipmapIndex);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果记录到 <code>RadianceProbeIndirectionTexture</code> 中，对应位置设置为 USED_PROBE_INDEX。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">int3 IndirectionTextureCoord = ProbeCoord + <span class="hljs-built_in">int3</span>(ClipmapIndex * RadianceProbeClipmapResolutionForMark, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>RWRadianceProbeIndirectionTexture[IndirectionTextureCoord] = USED_PROBE_INDEX;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-2-2-Probe重用、分配与释放"><a href="#3-2-2-Probe重用、分配与释放" class="headerlink" title="3.2.2 Probe重用、分配与释放"></a>3.2.2 Probe重用、分配与释放</h3><p>整个clipmap的probe数量比较多，但只会更新其中一部分，如果按照clipmap分布为所有probe分配数据会非常浪费。因此使用buffer来紧凑管理需要分配数据存储的probe列表。<code>RWProbeFreeList</code> 存放空闲的probe数据索引，可使用时从中申请以及释放时归还，其中的 ProbeIndex 唯一标识probe的数据位置，包括：</p><ul><li>RWProbeLastUsedFrame[ProbeIndex] 记录probe上次使用的帧数</li><li>光追结果 RadianceProbeAtlasTexture, DepthProbeAtlasTexture 等等</li></ul><h4 id="3-2-2-1-上一帧-Probe-重用与释放"><a href="#3-2-2-1-上一帧-Probe-重用与释放" class="headerlink" title="3.2.2.1 上一帧 Probe 重用与释放"></a>3.2.2.1 上一帧 Probe 重用与释放</h4><p>如前所述，clipmap以相机为中心，会随着相机的移动而移动，往往上一帧的clipmap与当前帧有重叠，因此可以重用这部分probe。主要实现在 shader <code>UpdateCacheForUsedProbesCS</code>中，遍历每个LastFrameProbe：</p><ol><li>当前遍历的 ClipmapIndex 以及 LastFrameProbeCoord可以从线程ID中得到</li><li>LastFrameProbeCoord -&gt; ProbeTranslatedWorldPosition -&gt; ProbeCoord 变换到当前帧clipmap下<ul><li>从 LastFrameRadianceProbeIndirectionTexture 中得到 <code>LastFrameProbeIndex</code> (probe唯一ID，分配得到的，非变换得到)</li><li>使用上一帧的clipmap变换，得到probe世界坐标 <code>ProbeTranslatedWorldPosition</code>，再变换到当前帧的clipmap中，得到 <code>ProbeCoord</code>。ProbeCoord有效，表示上一帧probe也在当前帧clipmap中，继续执行重用逻辑</li></ul></li><li>按照 probe 在当前帧是否被使用到以及其中数据是否过旧来更新重用状态<ul><li>从 RadianceProbeIndirectionTexture 得到当前帧probe的<code>ProbeUsedMarker</code></li><li>probe上次更新帧数<code>LastUsedFrameNumber = RWProbeLastUsedFrame[LastFrameProbeIndex]</code></li><li>probe 被当前帧使用或者<code>(FrameNumber - LastUsedFrameNumber)</code>在阈值范围内<ul><li>标记为重用 bReused &#x3D; true</li><li>将 LastFrameProbeIndex 分配给当前帧probe，更新到 RadianceProbeIndirectionTexture 中</li><li>被当前帧使用，则更新 <code>RWProbeLastUsedFrame[LastFrameProbeIndex] = FrameNumber</code></li></ul></li></ul></li><li>如果上一帧probe没有被重用，则释放probe索引 LastFrameProbeIndex，归还到 RWProbeFreeList 中</li></ol><h4 id="3-2-2-2-Probe-分配索引、优先级与开销预算评估"><a href="#3-2-2-2-Probe-分配索引、优先级与开销预算评估" class="headerlink" title="3.2.2.2 Probe 分配索引、优先级与开销预算评估"></a>3.2.2.2 Probe 分配索引、优先级与开销预算评估</h4><p>处理完上一帧probe，接下来需要为当前帧被使用到的probe分配数据索引。这部分在 shader <code>AllocateUsedProbesCS</code>中，遍历 RadianceProbeIndirectionTexture 的每个texel的ProbeUsedMarker：</p><ul><li>当前probe被使用到，还未被分配数据索引 (ProbeUsedMarker &#x3D;&#x3D; USED_PROBE_INDEX)。从 ProbeFreeList 中分配一个ProbeIndex</li><li>否则表示，当前probe为重用probe，已有数据索引，即 ProbeIndex&#x3D;ProbeUsedMarker</li><li>每帧trace更新probe的开销是有限的，因此需要评估probe的更新优先级以及trace开销<ul><li>更新优先级，基于 LastTracedFrameIndex, LastUsedFrameIndex, ClipmapIndex 来划分PriorityBucketIndex，bucket越靠前优先级越高。<code>GetPriorityBucketIndex</code><ul><li>如果probe从未trace过，返回 bucket 0</li><li>否则，根据“clipmap层级越高重要性越低”、”经历越久帧未trace，优先级越高“来确定 UpdateImportance，最终得到 BucketIndex</li></ul></li><li>ProbeTraceCost：probe的光线样本分辨率不同，根据probe到相机的距离具有不同的trace cost<ul><li>如果低于 SupersampleDistanceFromCameraSq 为16</li><li>如果低于 DownsampleDistanceFromCameraSq 为 4</li></ul></li></ul></li><li>累积 trace cost，<code>RWPriorityHistogram[PriorityBucketIndex] += ProbeTraceCost</code></li></ul><p>这里通过probe的上次trace帧、上次使用帧以及层级，将probe映射到bucket中，得到了一个不严格的优先级列表 <code>RWPriorityHistogram</code>。</p><h3 id="3-2-3-为预算内的probe构建-trace-data"><a href="#3-2-3-为预算内的probe构建-trace-data" class="headerlink" title="3.2.3 为预算内的probe构建 trace data"></a>3.2.3 为预算内的probe构建 trace data</h3><h4 id="3-2-3-1-为probe创建trace-data"><a href="#3-2-3-1-为probe创建trace-data" class="headerlink" title="3.2.3.1 为probe创建trace data"></a>3.2.3.1 为probe创建trace data</h4><p>首先基于probe的trace cost优先级队列 <code>RWPriorityHistogram</code>，确定更新预算内的bucket。在 shader <code>SelectMaxPriorityBucketCS</code> 中，按照bucket从前往后累积 trace cost，直至达到预设 NumTracesBudget，即查找到最后一个更新的bucket <code>MaxUpdateBucketIndex</code>，以及记录最后一个bucket剩余多少trace cost <code>MaxTracesFromMaxUpdateBucket</code>。</p><p>在 shader <code>AllocateProbeTracesCS</code> 中，遍历 RadianceProbeIndirectionTexture 每个texel，对于分配ProbeIndex的probe：</p><ul><li>以同样的方式得到 probe 的 ProbeTraceCost, PriorityBucketIndex</li><li>位于更新开销内的probe (<code>PriorityBucketIndex &lt;= MaxUpdateBucketIndex</code>)<ul><li>如果 probe 位于最后一个bucket中MaxUpdateBucketIndex，还需要判断是否已消耗完最后一个bucket的剩余预算，已消耗完则不进行trace</li><li>为能够 trace 的probe分配 TraceIndex：<ul><li>累积 ProbeTraceCost 到 ProbesToUpdateTraceCost[0]</li><li>构建 trace data <code>RWProbeTraceData[TraceIndex] = float4(ProbeWorldPosition, asfloat((ClipmapIndex &lt;&lt; 24) | ProbeIndex));</code></li><li>更新trace帧 <code>RWProbeLastTracedFrame[ProbeIndex] = FrameNumber;</code></li></ul></li></ul></li></ul><p>按照预算开销，构建了要执行trace的probe列表 RWProbeTraceData，其中每个元素打包了 ProbeWorldPosition, ClipmapIndex, ProbeIndex。</p><h4 id="3-2-3-2-probe-偏移与PDF估计"><a href="#3-2-3-2-probe-偏移与PDF估计" class="headerlink" title="3.2.3.2 probe 偏移与PDF估计"></a>3.2.3.2 probe 偏移与PDF估计</h4><p>避免probe距物体表面过近，会为每个需要trace的probe计算一个偏移量，实现在 shader <code>ComputeProbeWorldOffsetsCS</code> 中。主要思想是，通过查询 SDF 可以得知 probe 位置到最近表面的距离，若距离小于阈值，则：</p><ul><li>每个group负责一个probe trace data</li><li>将一个cell划分为 4x4x4 voxels， 在不同的 voxels 方向上对于 probe 位置施加一个偏移量，再次查询SDF最近距离</li><li>在所有查询结果中，取偏最近距离最大的一个偏移量</li></ul><p>world probe 在不同的方向上重要性不同，后面会根据重要性来执行超采样逻辑，即具有更高分辨率的光线样本。重要性的其中一方面是需要PDF估计，这里使用screen probe的数据来评估world probe pdf。具体做法在 shader<code>ScatterScreenProbeBRDFToRadianceProbesCS</code>中，通过将 screen probe 的BRDF扩散到其周围的8个world probe实现：</p><ul><li>每个group负责一个screen probe</li><li>根据 screen probe 的 WorldPosition 可以查询到其周围8个world probe。得到最小的 BottomCornerProbeCoord，再加上 <code>int3(GroupThreadId.x &amp; 0x1, (GroupThreadId.x &amp; 0x2) &gt;&gt; 1, (GroupThreadId.x &amp; 0x4) &gt;&gt; 2)</code>，就可以定位其中一个probe</li><li>通过 <code>RadianceProbeIndirectionTexture</code> 查找到 ProbeIndex</li><li>ProbeIndex 可以找到 probe 的SH数据位置，将screen probe的SH系数<code>BRDFProbabilityDensityFunctionSH</code>累加到 <code>RWRadianceProbeSH_PDF</code></li></ul><h2 id="3-3-构建用于更新probe的trace-tile"><a href="#3-3-构建用于更新probe的trace-tile" class="headerlink" title="3.3 构建用于更新probe的trace tile"></a>3.3 构建用于更新probe的trace tile</h2><h3 id="3-3-1-创建-probe-trace-tile-列表"><a href="#3-3-1-创建-probe-trace-tile-列表" class="headerlink" title="3.3.1 创建 probe trace tile 列表"></a>3.3.1 创建 probe trace tile 列表</h3><p>前面讲到 world probe 会根据重要性来执行超采样而达到更高分辨率的光线样本，主要是通过对probe trace tile进行不同的层级划分实现的，实现在 shader <code>GenerateProbeTraceTilesCS</code>：</p><ol><li>每个 group 负责一个probe。BaseTraceTileResolution 为 ProbeResolution(默认为 32) 的 1&#x2F;16，即 2x2</li><li>确定 probe trace tile 的层级数量 <code>NumLevels</code>:<ul><li>如果ProbesToUpdateTraceCost超出预算的2倍，取 1</li><li>否则根据probe到相机的距离 <code>DistanceFromCameraSq</code>：SupersampleDistanceFromCameraSq 取 3，DownsampleDistanceFromCameraSq 取 2</li></ul></li><li>BaseTraceTile 每个 texel 都表示一个立体角区域，划分则是为其中的立体角区域再细分一个tile，<ul><li>NumLevels &gt; 1 并且 TraceTileCoord 方向上PDF高于阈值，为该方向细分 1 个 L1 trace tile (2x2)，添加到<code>PendingTraceTileList</code>，待后续进一步划分<ul><li>TraceTileList 的每个元素打包了 uint2：<ul><li>x: 低16位，TraceTileCoord * 2 + uint2(0&#x2F;1, 0&#x2F;1)；高16位，Level&#x3D;1</li><li>y: ProbeTraceIndex</li></ul></li></ul></li><li>否则，表示不需要再细分，则添加一个 L0 trace tile 到最终结果 <code>CompletedTraceTileList</code></li></ul></li><li>遍历 PendingTraceTileList，继续划分NumLevels 3, 2的 trace tile 如果 PDF 高于超采样阈值，则L1划分4个L2，L2划分4个L3<ul><li>划分 NumLevels &gt; 2 的 trace tile<ul><li>划分 L1<ul><li>如果TraceTileCoord 方向上 PDF 高于 <code>SupersampleTileBRDFThreshold</code>，添加 4 个 L2 tiles 到 <code>PendingTraceTileList</code></li><li>否则，添加1个 L1 tile 到最终结果 <code>CompletedTraceTileList</code></li></ul></li><li>收集 L2：将 PendingTraceTileList 中的 L2 tile 加入到结果<code>CompletedTraceTileList</code>中</li></ul></li><li>划分 NumLevels &gt; 1 的 trace tile<ul><li>将 PendingTraceTileList 中的 L1 tile 加入到结果<code>CompletedTraceTileList</code>中</li></ul></li></ul></li><li>按照 probe 次序，将将CompletedTraceTileList的所有trace tile写入RWProbeTraceTileData，每个元素 uint2<ul><li>x：低 16位，TraceTileCoord * 2 + uint2(0&#x2F;1, 0&#x2F;1)；高16位，level</li><li>y：ProbeTraceIndex</li></ul></li></ol><p>上述，针对probe做了以trace tile为单位的划分，每个trace tile表示一定分辨率。假如每个trace tile具有 8x8 分辨率，而一个 probe 最少有 2x2 个 trace tile，即最小分辨率为 16x16；最多有 8x8 个 trace tile，即最大分辨率为 64x64。但注意一个probe的trace tile划分不是均匀，例如一个PDF较高的方向上可能划分更多trace tile。</p><h3 id="3-3-2-trace-tile-排序"><a href="#3-3-2-trace-tile-排序" class="headerlink" title="3.3.2 trace tile 排序"></a>3.3.2 trace tile 排序</h3><p>trace tile的每个texel都对应了球面上一个立体角范围，可以在该立体角范围内采样光线，执行光追得到radiance。为了光追效率，还会额外做一次trace tile排序，将方向相近的trace tile相邻存放。具体做法是：将光线方向范围划分为一定数量的bin，再把trace tile划分到对应的bin中，最后按照bin顺序排列trace tile。实现在 shader <code>SortProbeTraceTilesCS</code> 中：</p><ol><li>只有一个group，一个线程负责一个trace tile，能够得到 TraceTileCoord, TraceTileLevel, ProbeTraceIndex</li><li>确定 trace tile 所位于层级的probe分辨率 <code>TraceResolution=(RadianceProbeResolution/2) &lt;&lt; TraceTileLevel</code><ul><li>RadianceProbeResolution 默认为 32，对应了 trace tile 默认 8x8 的分辨率</li></ul></li><li>trace tile 在所处层级分辨率下的texel <code>ProbeTexelCoord=TraceTileCoord * RADIANCE_CACHE_TRACE_TILE_SIZE_2D(8)</code>。这是在给定球面分辨率下，表示trace tile方向的texel坐标</li><li>给定指定bin数量，投影trace tile到bin中：<ul><li><code>DirectionalBin=ProbeTexelCoord * NUM_DIRECTION_BINS_2D(8) / TraceResolution</code>。把整个球面分辨率划分为8份</li><li>记录每个bin内的trace tile数量。DirectionalBin转为一维索引 FinalBinIndex，<code>SharedNumTraceTileBins[FinalBinIndex] +=1</code></li></ul></li><li>按照Bin的顺序排列trace tile<ul><li>统计当前 TraceTile 所属bin之前所有Bin的trace tile数量 <code>SortedTraceTileOffset</code>，以及累积所属bin已存放trace tile数量</li><li>写入 RWProbeTraceTileData[SortedTraceTileOffset]</li></ul></li></ol><h2 id="3-4-执行光追更新probe"><a href="#3-4-执行光追更新probe" class="headerlink" title="3.4 执行光追更新probe"></a>3.4 执行光追更新probe</h2><h3 id="3-4-1-为每个trace-tile执行光追"><a href="#3-4-1-为每个trace-tile执行光追" class="headerlink" title="3.4.1 为每个trace tile执行光追"></a>3.4.1 为每个trace tile执行光追</h3><p>下面就是为每个trace tile执行光追，生成每个texel方向上的radiance，实现在shader <code>LumenRadianceCacheHardwareRayTracingCS</code>中：</p><ul><li><p>一个group负责一个trace tile，一个线程负责一个光线样本，每个trace tile 8x8 分辨率</p></li><li><p>线程索引得到trace tile内的texel坐标 <code>TexelCoord</code>，执行<code>TraceRadianceCacheProbeTexel</code>：</p><ul><li><p>TraceTileIndex -&gt; ProbeTraceIndex -&gt; TraceData -&gt; ProbeIndex，可以获取到probe的所有相关信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FRadianceCache</span><br>&#123;<br>uint2 TraceTileCoord;<br>uint TraceTileLevel;<br>uint ProbeTraceIndex;<br><br>float3 ProbeWorldCenter;<br>uint ClipmapIndex;<br>uint ProbeIndex;<br><br>uint ProbeResolution;<br><span class="hljs-type">float</span> ProbeTMin;<br>uint ProbeAtlasResolutionModuloMask;<br>uint ProbeAtlasResolutionDivideShift;<br><br><span class="hljs-type">bool</span> bFarField;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>构造光线</p><ul><li><code>Ray.Direction</code>：将局部 TexelCoord 变换到球面上的 ProbeTexelCoord，通过 spherical mapping 可得到texel中心点的方向</li><li><code>Ray.Origin</code>：probe的世界坐标</li><li><code>Ray.TMin</code>：ProbeTMin，0.1 * cell_size</li><li><code>Ray.TMax</code>：限制到near field内</li></ul></li><li><p>追踪并采样surface cache <code>TraceAndCalculateRayTracedLightingFromSurfaceCache</code></p></li><li><p>追踪结果按照trace tile排列，存放在 RWTraceRadianceTexture, RWTraceHitTexture</p></li></ul></li></ul><p>上面的追踪同样在 far field 内执行一次</p><h3 id="3-4-2-Resolve到统一分辨率下"><a href="#3-4-2-Resolve到统一分辨率下" class="headerlink" title="3.4.2 Resolve到统一分辨率下"></a>3.4.2 Resolve到统一分辨率下</h3><p>如前所述的trace tile划分，为probe分配了不同的分辨率，最终需要 resolve 到统一分辨率下。实现在 shader <code>SplatRadianceCacheIntoAtlasCS</code> 中：</p><ul><li>一个group负责一个trace tile</li><li>获取trace tile基本信息，TraceTileIndex -&gt; ProbeTraceIndex -&gt; TraceData -&gt; ProbeIndex，得到 FRadianceCache</li></ul><h2 id="3-5-采样"><a href="#3-5-采样" class="headerlink" title="3.5 采样"></a>3.5 采样</h2><p>Radiance Cache 本质上只提供稍远距离的radiance信息（可能是 radiance cache 分辨率不足提供近光会有比较明显的artifact吧，例如反射过于模糊？），这个由 probeTMin 控制。反射、screen probe 会首先尝试 trace probeTMin 范围内，如果没有近距离交点且被radiance cache覆盖，则会采样 radiance cache 得到 radiance 信息。shader 函数 <code>SampleRadianceCacheAndApply</code> 提供了采样radiance cache的功能。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a name="[1]">[1]</a> Christopher C. Tanner, Christopher J. Migdal, and Michael T. Jones. 1998. The clipmap: a virtual mipmap. In Proceedings of the 25th annual conference on Computer graphics and interactive techniques (SIGGRAPH ‘98). Association for Computing Machinery, New York, NY, USA, 151–158.</p>]]></content>
    
    
    <categories>
      
      <category>Render Engine</category>
      
      <category>UE5</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2. Lumen - Surface Cache</title>
    <link href="/2025/03/04/Render%20Engine/UE5/Lumen/2.%20Surface%20Cache/"/>
    <url>/2025/03/04/Render%20Engine/UE5/Lumen/2.%20Surface%20Cache/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>直接光照只需要关注相机看到的部分，而间接光照需要处理次级光线及之后的光照信息，也就是不依赖于相机的全局信息。每帧来计算光线交点信息对于大场景是不现实的，而 surface cache 的作用就是缓存次级表面信息，供光追采样。</p><p>surface cache 可以粗略理解为定义在 texture space 上的cache，而texture space描述的是物体表面空间，不随相机而改变。整个场景的texture space是非常大，不可能全部装入显存，但实际每帧只会使用到一小部分。因此在实现上，surface cache采用的是类似于virtual texture的技术。将texture space划分为固定大小的page，使用page table维护virtual page与physical page的换入换出。光追采样surface cache发生缺页时，会生成对应的page请求。</p><p>surface cache 缓存用于间接光照计算的相关信息包括材质、表面的直接光照计算、表面的radiosity。surface cache由于定义在物体表面上，不随相机而改变，因此在多帧之间具有一致性。实际更新过程可以按照开销预算来帧间分摊</p><h1 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2 工作流程"></a>2 工作流程</h1><p>Surface Cache 是 Lumen 系统的基石，Lumen 其它部分都是通过采样surface cache来获取次级弹射信息。下面这张图是surface cache整体工作流程：</p><ol><li>构建要更新的virtual page列表。更新请求主要来自于：场景的动态更新，如物体的加载与卸载；上一帧的surface cache request。每帧的更新开销预算是固定，为此基于一定策略来评估page的重要性，在预算内，选择重要性高的page更新。</li><li>PageTable 更新。在得到要更新的virtual page列表后，需要先为这些page分配physical page，这涉及到虚拟存储的管理。</li><li>历史数据重投影与填充gbuffer数据。先将上一帧的surface cache中，发生重分配的page数据重投影到当前帧page；构建光栅化page的mesh draw commands，光栅化填充page所在表面区域的gbuffer数据。</li><li>构建需要更新直接光照的 lighting page list。有了page的gbuffer数据之后，准备计算page的直接光照。此时page table中包含新出现的page以及已存在page，已存在page数据可以复用，未必需要更新。这里同样按照预算统计出需要更新直接光照的 lighting page list</li><li>光照计算。计算光照阶段将page划分为 8x8 大小的page tile。由于光源数量可能很多，按照page  tile范围以及光源的衰减等构建出影响到page tile的光源列表（tile-based rendering）。为每个texel执行光照计算：<ul><li>direct lighting: 应用光源列表的lighting function计算得到</li><li>final lighting: direct lighting + 上一帧的 indirect lighting。这里串起来了上一帧的间接光，这样多帧累积达到无限反弹近似。</li></ul></li><li>更新 radiosity。radiosity用于间接光计算，这里的radiosity与probe类似，只是放置在了surface空间下。<ol><li>按照indirect lighting预算构建放置在page的probe更新列表</li><li>为probe采样光线，执行光追，有交点则转而采样surface cache的final lighting作为光线radiance。这里如果发生缺页会生成一个page请求</li><li>为probe radiance执行spatial&#x2F;temporal的filter</li><li>投影为SH，并为每个texel插值其周围的probe生成irradiance，更新到 indirect lighting</li></ol></li></ol><img src="/images/Render Engine/UE5/Lumen/2. Surface Cache/surface cache流程.png" alt="surface cache流程"><h1 id="3-参数化空间"><a href="#3-参数化空间" class="headerlink" title="3 参数化空间"></a>3 参数化空间</h1><h2 id="3-1-mesh-card参数化"><a href="#3-1-mesh-card参数化" class="headerlink" title="3.1 mesh card参数化"></a>3.1 mesh card参数化</h2><h2 id="3-2-存储管理"><a href="#3-2-存储管理" class="headerlink" title="3.2 存储管理"></a>3.2 存储管理</h2><h2 id="3-3-采样"><a href="#3-3-采样" class="headerlink" title="3.3 采样"></a>3.3 采样</h2><h1 id="4-Surface-Cache-更新"><a href="#4-Surface-Cache-更新" class="headerlink" title="4 Surface Cache 更新"></a>4 Surface Cache 更新</h1><h2 id="4-1-gbuffer"><a href="#4-1-gbuffer" class="headerlink" title="4.1 gbuffer"></a>4.1 gbuffer</h2><h2 id="4-2-lighting"><a href="#4-2-lighting" class="headerlink" title="4.2 lighting"></a>4.2 lighting</h2><h2 id="4-3-radiosity"><a href="#4-3-radiosity" class="headerlink" title="4.3 radiosity"></a>4.3 radiosity</h2>]]></content>
    
    
    <categories>
      
      <category>Render Engine</category>
      
      <category>UE5</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1. Lumen - Introduction</title>
    <link href="/2025/03/04/Render%20Engine/UE5/Lumen/1.%20Introdution/"/>
    <url>/2025/03/04/Render%20Engine/UE5/Lumen/1.%20Introdution/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Summary"><a href="#1-Summary" class="headerlink" title="1 Summary"></a>1 Summary</h1><p>本系列是作者基于对 UE5 Lumen 源码以及网上资料的学习，而形成对 Lumen 实现原理的介绍。Lumen 是UE5的实时全局光照解决方案，其中包含了众多技术的工程化，本文先总体介绍 UE5 Lumen 的组成部分，之后再对各组成部分详细描述。</p><h1 id="2-Global-Illumination"><a href="#2-Global-Illumination" class="headerlink" title="2 Global Illumination"></a>2 Global Illumination</h1><p>老生常谈，全局光照在实时渲染性能的限制下，最多只能达到 1&#x2F;2 spp的光线开销，而高质量的间接光需要成百上千的光线数量。对此，一方面提出了各种 spatial-temporal 技术来变相提高采样率；另一方面有基于probe 的 DDGI 或者 VXGI 等，来离散化采样场景，从而得到场景间接光的低分辨率表示。</p><p>仅仅这些技术还无法是的全局光照在大场景下开启，还需要考虑实际的工程实现问题。例如，在计算光线radiance时，即着色光线交点，需要考虑：</p><ul><li>材质数量庞大，需要非常多的材质pass，开销异常高</li><li>大场景世界范围很大，需要的world probe数量也会很高，实时更新全部 world probe 是不现实的</li><li>光源数量同样可能会很多，需要应用many-lights技术</li><li>等等</li></ul><p>Lumen 作为一个庞大的实时全局光照系统，不仅杂糅了很多技术，而且工程实现上有很多实时性能上的权衡，主要包含以下组成部分：</p><ul><li>surface cache：直接光照只需要关注相机看到的部分，而间接光照需要处理次级光线及之后的光照信息，也就是不依赖于相机的全局信息。surface cache 是基于mesh card构建的参数化空间（可近似理解为有误差的texture space），缓存物体表面上用于间接光照的数据，包括材质、表面的直接光照计算、表面的radiosity。surface cache由于定义在物体表面上，不随相机而改变，因此在多帧之间具有一致性。</li><li>radiance cache probe：</li><li>screen probe：</li><li>reflection：</li><li>光追：</li></ul>]]></content>
    
    
    <categories>
      
      <category>Render Engine</category>
      
      <category>UE5</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/04/Render%20Engine/UE5/Mesh%20Drawing%20Pipeline/"/>
    <url>/2025/03/04/Render%20Engine/UE5/Mesh%20Drawing%20Pipeline/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Importance Sample BRDF</title>
    <link href="/2024/12/07/Rendering%20Blogs/Graphics%20Basis/Importance%20Sample%20BRDF/"/>
    <url>/2024/12/07/Rendering%20Blogs/Graphics%20Basis/Importance%20Sample%20BRDF/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Summary"><a href="#1-Summary" class="headerlink" title="1 Summary"></a>1 Summary</h1><p>本文主要介绍微表面模型的 BRDF 的重要性采样过程，即使用重要性采样来计算渲染方程的积分。</p><h1 id="2-Background"><a href="#2-Background" class="headerlink" title="2 Background"></a>2 Background</h1><p>假设如下图所示的反射过程：</p><p><a name="Reflection Fig"></a></p><img src="/images/Rendering Blogs/Graphics Basis/Importance Sample BRDF.assets/image-20211223113437451.png" alt="image-20211223113437451" style="zoom:67%;"><center>Fig 1: 微表面反射图示</center><p>有渲染方程<br>$$<br>L_o(P, \boldsymbol{v})&#x3D;L_e(P, \boldsymbol{v})+\int_{\Omega^+}L_i(\boldsymbol{l})f(\boldsymbol{l}, \boldsymbol{v}) \cos\theta_l \space d\boldsymbol{l}<br>$$</p><p>其中 $P$ 为着色点，$\boldsymbol{l}$ 为入射光方向(指向光源)，$\boldsymbol{v}$ 为观察方向；第一项 $L_e$ 为着色点 $P$ 自发光，第二项为反射光，记为 $L_r$，本文主要关注第二项。第二项中 $L_i(\boldsymbol{l})$ 为入射光的属性，如颜色等；$f(\boldsymbol{l},\boldsymbol{v})$ 为 BRDF，本文只关注 microfacet BRDF。注意这里的 $\boldsymbol{l}$ 相当于单位立体角的方向，其他地方常记作 $\omega_i$ ，反射项的积分即在法线方向的半球上对立体角的积分。 </p><h2 id="2-1-蒙特卡洛积分"><a href="#2-1-蒙特卡洛积分" class="headerlink" title="2.1 蒙特卡洛积分"></a>2.1 蒙特卡洛积分</h2><p>$L_r$ 积分没有解析解，直接求复杂很高，通常使用蒙特卡洛求积分的估计值。假设要求积分 $\int f(x) \space dx$，并且自变量服从一个分布 $X \sim P(x)$，概率密度为 $p(x)$。这时我们可以在积分区间内，以分布 $X \sim p(x)$ 进行很多次采样，得到 $X_1, X_2, …, X_N$。使用这些采样点可以得到积分的估计，方法如下：<br>$$<br>\int f(x) \space dx &#x3D; \int \frac{f(x)}{p(x)}\cdot p(x) \space dx&#x3D;E\left[\frac{f(x)}{p(x)}\right]<br>$$<br>我们将求积分转为了求期望 $E\left[\frac{f(x)}{p(x)}\right]$，对于期望，可以进行无偏估计(样本均值)：<br>$$<br>E\left[\frac{f(x)}{p(x)}\right] \approx \frac{1}{N}\sum\limits_{i&#x3D;1}^{N}\frac{f(X_i)}{p(X_i)}<br>$$<br>将采样点代入上式，即可得到积分的估计。</p><p><strong>使用蒙特卡洛积分后的 $L_r$</strong><br>$$<br>L_r&#x3D;\int_{\Omega^+}L_i(\boldsymbol{l})f(\boldsymbol{l}, \boldsymbol{v}) \cos\theta_l \space d\boldsymbol{l}\approx\frac{1}{N}\sum\limits_{k&#x3D;1}^N\frac{L_i(\boldsymbol{l}_k)f(\boldsymbol{l}<em>k,\boldsymbol{v})\cos\theta</em>{l_k}}{p(\boldsymbol{l}_k)} \tag{1} \label{BRDF MC}<br>$$<br>想要求上述积分，除了很多采样点之外，还需要知道 $\boldsymbol{l}$ 的概率密度 $p(\boldsymbol{l})$，而这个概率密度的选取要尽量接近被积函数的分布，即采用重要性采样的思想。</p><h2 id="2-2-重要性采样-5"><a href="#2-2-重要性采样-5" class="headerlink" title="2.2 重要性采样 [5]"></a>2.2 重要性采样 <a href="#%5B5%5D">[5]</a></h2><p>在蒙特卡洛积分中，采样概率密度的选取能够影响到积分结果的方差。如果选取的分布接近被积函数的分布，那么蒙特卡洛积分的收敛速度会更快。例如 $\eqref{BRDF MC}$ 的被积函数，其中有一个 $\cos\theta_l$ 项，如果采样得到的样本 $\boldsymbol{l}<em>k$ 垂直于法线，即 $\cos\theta</em>{l_k}&#x3D;0$，此时，被积函数值为 0，因此这类采样点对积分结果无任何共享。</p><p>为了节省蒙特卡洛采样次数，应该避免采样到无用点，因此需要调整采样概率密度。当光源项与 BRDF 项未知时，使得采样概率密度 $p(\boldsymbol{l})$ 正比于 $\cos\theta_l$，经常称为 <strong>cosine-weighted sample hemisphere</strong>。<br>$$<br>p(\boldsymbol{l}) &#x3D; c\propto \cos\theta_l \qquad \quad where\space c &gt; 0<br>$$<br>我们还知道入射光方向分布在 hemisphere，因此概率密度在 hemisphere 范围内的积分为 1，有<br>$$<br>\begin{align}<br>\int_{\Omega^+}p(\boldsymbol{l})\space d\omega_l &amp;&#x3D; \int_{\Omega^+} c\cdot \cos\theta_l\space d\omega_l \<br>&amp;&#x3D;c\cdot \int_0^{2\pi}\int_0^{\pi&#x2F;2}\cos\theta_l\sin\theta_l\space d\theta_ld\phi_l \<br>&amp;&#x3D;c\cdot \pi &#x3D;1<br>\end{align} \label{cosine-int}\tag{1}<br>$$<br>因此 $\Large c&#x3D;\frac{1}{\pi}$，将入射方向 $\boldsymbol{l}$ 的概率密度 $p(\boldsymbol{l})$ 在<strong>数值上</strong>可按下式计算：<br>$$<br>p(\boldsymbol{l})&#x3D;\frac{1}{\pi}\cdot \cos\theta_l<br>$$</p><h3 id="2-2-1-采样过程"><a href="#2-2-1-采样过程" class="headerlink" title="2.2.1 采样过程"></a>2.2.1 采样过程</h3><p>实际的采样无法直接采样立体角，需要将立体角形式的概率密度转换到球坐标的概率密度，如 $\eqref{cosine-int}$ 式的变换：<br>$$<br>p(\boldsymbol{l}) &#x3D; p_{\boldsymbol{l}}(\phi_l,\theta_l) &#x3D;\frac{1}{\pi}\cdot \cos\theta_l\cdot \sin\theta_l<br>$$</p><ul><li>边缘概率密度</li></ul><p>$\phi_l$ 的边缘概率密度为<br>$$<br>\begin{align}<br>p_{\boldsymbol{l}}(\phi_l)&amp;&#x3D; \int_0^{\frac{\pi}{2}} p_{\boldsymbol{l}}(\phi_l,\theta_l) \space d\theta_l \<br>&amp;&#x3D;\int_0^{\frac{\pi}{2}} \frac{1}{\pi}\cdot \cos\theta_l\cdot \sin\theta_l\space d\theta_l \<br>&amp;&#x3D;\frac{1}{2\pi}<br>\end{align}<br>$$<br>$\theta_l$ 的边缘概率密度为<br>$$<br>\begin{align}<br>p_{\boldsymbol{l}}(\theta_l)&amp;&#x3D;\int_0^{2\pi} p_{\boldsymbol{l}}(\phi_l,\theta_l) \space d\phi \<br>&amp;&#x3D;\int_0^{2\pi} \frac{1}{\pi}\cdot \cos\theta_l\cdot \sin\theta_l \space d\phi_l \<br>&amp;&#x3D;2\cdot\cos\theta_l\sin\theta_l<br>\end{align}<br>$$</p><ul><li>边缘概率分布</li></ul><p>$\phi_l$ 的边缘概率分布为<br>$$<br>\begin{align}<br>P_{\boldsymbol{l}}(\phi_{l_k})&amp;&#x3D;\int_0^{\phi_{l_k}} p_{\boldsymbol{l}}(\phi_l) \space d\phi_l \<br>&amp;&#x3D;\int_0^{\phi_{l_k}} \frac{1}{2\pi} \space d\phi_l \<br>&amp;&#x3D;\frac{1}{2\pi}\cdot \phi_{l_k}<br>\end{align}<br>$$</p><p>$\theta_l$ 的边缘概率分布为<br>$$<br>\begin{align}<br>P_{\boldsymbol{l}}(\theta_{l_k})&amp;&#x3D;\int_0^{\theta_{l_k}} p_{\boldsymbol{l}}(\theta_l) \space d\theta_l \<br>&amp;&#x3D;\int_0^{\theta_{l_k}} 2\cdot\cos\theta_l\sin\theta_l \space d\theta_l \<br>&amp;&#x3D;1-\cos^2\theta_{l_k}<br>\end{align}<br>$$</p><ul><li>均匀采样变换到球坐标采样</li></ul><p>假设计算伪随机生成 $[0,1]\times [0,1]$ 的随机数 $x,y$，作为球坐标 $(\phi_l,\theta_l)&#x3D;(\phi_{l_k},\theta_{l_k})$ 的概率，可列<br>$$<br>\begin{cases}<br>P_{\boldsymbol{l}}(\phi_{l_k})&#x3D;\frac{1}{2\pi}\cdot \phi_{l_k}&#x3D;x \<br>P_{\boldsymbol{l}}(\theta_{l_k})&#x3D;1-\cos^2\theta_{l_k}&#x3D;y<br>\end{cases}<br>$$<br>因此有变换<br>$$<br>\begin{cases}<br>\phi_{l_k}&#x3D; 2\pi\cdot x\<br>\cos\theta_{l_k} &#x3D; \sqrt{1-y}<br>\end{cases}<br>$$</p><p>对于特殊光源、特殊 BRDF，可以得到被积函数不同的近似分布，使得采样分布接近被积函数的分布。下面即介绍不同微表面 BRDF 的重要性采样。</p><h2 id="2-3-Microfacet-BRDF"><a href="#2-3-Microfacet-BRDF" class="headerlink" title="2.3 Microfacet BRDF"></a>2.3 Microfacet BRDF</h2><p>这里只关注法线分布模型 NDF，微表面 BRDF 的详细细节请看 <a href="#%5B1%5D">[1]</a>，定义如下<br>$$<br>\begin{align}<br>f(\boldsymbol{l},\boldsymbol{v})&amp;&#x3D;\frac{F(\boldsymbol{l},\boldsymbol{v})\cdot G(\boldsymbol{l},\boldsymbol{v},\boldsymbol{h})\cdot D(\boldsymbol{h})}{4(\boldsymbol{n}\cdot \boldsymbol{l})(\boldsymbol{n}\cdot \boldsymbol{v})} \<br>&amp;&#x3D;\frac{F(\theta_d)\cdot G(\theta_l, \theta_v)\cdot D(\theta_h)}{4\cdot \cos\theta_l\cdot \cos\theta_v}<br>\end{align}<br>$$</p><p>对于微表面分布函数，$D(\boldsymbol{h})$ 有几个重要性质：</p><ul><li>所有微表面的面积之和始终不小于宏观表面的单位微平面的面积</li><li>所有微表面在宏观表面的单位微平面的投影面积之和为该宏观表面的单位微平面的面积，约定为 1。</li></ul><p>宏观表面的微平面与微表面如下图所示，</p><img src="/images/Rendering Blogs/Graphics Basis/Importance Sample BRDF.assets/image-20220107210022958.png" alt="image-20220107210022958" style="zoom: 33%;"><p>有，<br>$$<br>\int_{\Omega^+} D(\boldsymbol{h}) \space d\boldsymbol{h} \geq 1 \tag{2} \label{NDF Int}<br>$$</p><p>$$<br>\int_{\Omega^+} D(\boldsymbol{h}) \cos\theta_h \space d\boldsymbol{h} &#x3D; 1 \tag{3} \label{NDF Projected Area}<br>$$</p><p><strong>因此蒙特卡洛积分重要性采样的概率密度要依据 $D(\boldsymbol{h}) \cos\theta_h$  设定</strong>，但蒙特卡洛积分是对入射光方向 $\boldsymbol{l}$，而 $D(\boldsymbol{h}) \cos\theta_h$ 是微表面法线的概率密度。但计算 BRDF 只需要关注能够反射到观察方向的入射光方向即可，而反射过程与微表面法线具有反射定律的关系，可以根据此关系推导出入射光方向 $\boldsymbol{l}$ 的概率密度。下面介绍几种微表面分布函数，</p><h3 id="2-3-1-Blinn-Phong-NDF"><a href="#2-3-1-Blinn-Phong-NDF" class="headerlink" title="2.3.1 Blinn Phong NDF"></a>2.3.1 Blinn Phong NDF</h3><p>$$<br>D_p(\boldsymbol{h})&#x3D;\frac{\alpha_p+2}{2\pi}(\cos\theta_h)^{\alpha_p}<br>$$</p><p>其中 $\alpha_p$ 表示表面的光滑程度，当为 $\infty$ 时，表示绝对光滑表面。该参数带来的视觉变换非常不线性，不便调控。 UE4 中使用映射 $\alpha_p&#x3D;2\alpha^{-2}-2$ ，$\alpha$ 为 roughness。</p><h3 id="2-3-2-Beckmann-NDF"><a href="#2-3-2-Beckmann-NDF" class="headerlink" title="2.3.2 Beckmann NDF"></a>2.3.2 Beckmann NDF</h3><p>$$<br>D_b(\boldsymbol{h})&#x3D;\frac{1}{\pi\alpha^2(\cos\theta_h)^4}\cdot exp(\frac{\cos^2\theta_h-1}{\alpha^2\cos^2\theta_h})<br>$$</p><h3 id="2-3-3-GGX-Trowbridge-Reitz-NDF"><a href="#2-3-3-GGX-Trowbridge-Reitz-NDF" class="headerlink" title="2.3.3 GGX(Trowbridge-Reitz) NDF"></a>2.3.3 GGX(Trowbridge-Reitz) NDF</h3><p>$$<br>D_{GGX}(\boldsymbol{h})&#x3D;\frac{\alpha^2}{\pi((\cos\theta_h)^2(\alpha^2-1)+1)^2}<br>$$</p><h1 id="3-根据-NDF-得到蒙特卡洛积分的重要性采样概率密度"><a href="#3-根据-NDF-得到蒙特卡洛积分的重要性采样概率密度" class="headerlink" title="3 根据 NDF 得到蒙特卡洛积分的重要性采样概率密度"></a>3 根据 NDF 得到蒙特卡洛积分的重要性采样概率密度</h1><p>求 $\eqref{BRDF MC}$ 中的积分，需要一个关于入射方向的概率密度函数 $p(\boldsymbol{l})$。$p(\boldsymbol{l})$ 无法直接获取，需要通过微表面法线概率密度函数得到。 因此第一步是先求得微表面法线概率密度函数 $p(\boldsymbol{h})$。</p><h2 id="3-1-NDF-到微表面法线-PDF、CDF"><a href="#3-1-NDF-到微表面法线-PDF、CDF" class="headerlink" title="3.1 NDF 到微表面法线 PDF、CDF"></a>3.1 NDF 到微表面法线 PDF、CDF</h2><p>由 $\eqref{NDF Int}$ 可知，NDF 并不是真正的概率密度函数，因为其在定义域的积分 $\geq1$ ，而 $\eqref{NDF Projected Area}$ 中的 $D(\boldsymbol{h})\cos\theta_h$ 才是真正的概率密度。对微表面法线概率密度 $p(\boldsymbol{h})$ 进行球坐标参数化有：</p><p>对于 $z$ 坐标轴为宏平面法线 $\boldsymbol{n}$ 的 hemisphere，$\boldsymbol{h}$ 的球坐标为 $(\phi_h,\theta_h)$，其中 $\phi_h \in [0,2\pi],\theta_h \in [0,\pi&#x2F;2]$，并且 $\phi_h,\theta_h$ 相互独立。NDF $D(\boldsymbol{h})$ 对应的概率密度函数 PDF 为<br>$$<br>p_{\boldsymbol{h}}(\phi_h,\theta_h)&#x3D;D(\boldsymbol{h})\cos\theta_h&#x3D;D(\phi_h,\theta_h)\cos\theta_h<br>$$<br>计算机中的采样只能通过伪随机数生成服从均匀分布 $ U [0,1]$ 的采样点，需要通过变换转到服从其他分布的采样点 <a href="#%5B2%5D">[2]</a>。对于本文过程如下：在 $[0,1]\times[0,1]$ 进行均匀采样得到 $(x,y)$，用以表示采样点 $\boldsymbol{h}<em>k(\phi</em>{h_k},\theta_{h_k})$ 的概率，即<br>$$<br>P_k(\boldsymbol{h}<em>k)&#x3D;P_k(\phi</em>{h_k},\theta_{h_k})&#x3D;(x,y)<br>$$<br>$\eqref{NDF Projected Area}$ 为概率密度在随机变量的值域上的积分，将该积分的积分的微分立体角 $d\boldsymbol{h}$ 转换为球坐标有 $sin\theta_h\space d\phi_h d\theta_h$</p><p>计算边缘概率密度 $p_{\boldsymbol{h}}(\phi_h),p_{\boldsymbol{h}}(\theta_h)$ 有，<br>$$<br>\begin{align}<br>p_{\boldsymbol{h}}(\phi_h) &amp;&#x3D; \int_0^{\pi&#x2F;2} p_{\boldsymbol{h}}(\phi_h,\theta_h) \sin\theta_h \space d\theta_h \<br>p_{\boldsymbol{h}}(\theta_h) &amp;&#x3D; \int_0^{2\pi} p_{\boldsymbol{h}}(\phi_h,\theta_h) \sin\theta_h \space d\phi_h<br>\end{align}<br>$$<br>再对边缘概率密度 $p_{\boldsymbol{h}}(\phi_h),p_{\boldsymbol{h}}(\theta_h)$ 进行积分得到的边缘概率分布 $P_{\boldsymbol{h}}(\phi_h),P_{\boldsymbol{h}}(\theta_h)$ 联立方程，<br>$$<br>P_{\boldsymbol{h}}(\phi_{h_k}) &#x3D; \int_0^{\phi_{h_k}} p_{\boldsymbol{h}}(\phi_h)\space d\phi_h &#x3D; x \<br>P_{\boldsymbol{h}}(\theta_{h_k}) &#x3D; \int_0^{\theta_{h_k}} p_{\boldsymbol{h}}(\theta_h)\space d\theta_h &#x3D; y<br>$$<br>即可求得方程的解 $\phi_{h_k},\theta_{h_k}$，代入得到所求概率密度 $p_k(\boldsymbol{h}<em>k) &#x3D;p <em>k(\phi</em>{h_k},\theta</em>{h_k})$。</p><h2 id="3-2-常用的-NDF-到微表面法线-PDF、CDF-的推导"><a href="#3-2-常用的-NDF-到微表面法线-PDF、CDF-的推导" class="headerlink" title="3.2 常用的 NDF 到微表面法线 PDF、CDF 的推导"></a>3.2 常用的 NDF 到微表面法线 PDF、CDF 的推导</h2><p>下面按照第一小节中的步骤推导几个常用的 NDF 对应的微表面法线的概率密度函数。</p><h3 id="3-2-1-Blinn-Phong-NDF-到-PDF、CDF"><a href="#3-2-1-Blinn-Phong-NDF-到-PDF、CDF" class="headerlink" title="3.2.1 Blinn Phong NDF 到 PDF、CDF"></a>3.2.1 Blinn Phong NDF 到 PDF、CDF</h3><p>Blinn Phong NDF 对应的概率密度为：<br>$$<br>p_{\boldsymbol{h}}(\theta_h,\phi_h)&#x3D;D_p(\boldsymbol{h})\cos\theta_h&#x3D;\frac{\alpha_p+2}{2\pi}(\cos\theta_h)^{\alpha_p+1}<br>$$</p><ul><li><p>计算边缘概率密度<br>$$<br>\begin{align}<br>p_{\boldsymbol{h}}(\phi_h) &amp;&#x3D; \int_0^{\pi&#x2F;2} p_{\boldsymbol{h}}(\phi_h,\theta_h) \sin\theta_h \space d\theta_h&#x3D;\int_0^{\pi&#x2F;2} \frac{\alpha_p+2}{2\pi}(\cos\theta_h)^{\alpha_p+1}\sin\theta_h\space d\theta_h \<br>&amp;&#x3D; -\int_0^{\pi&#x2F;2}\frac{\alpha_p+2}{2\pi}(\cos\theta_h)^{\alpha_p+1} \space d(\cos\theta_h) &#x3D; -\frac{1}{2\pi}(\cos\theta_h)^{\alpha_p+2}\bigg|_0^{\pi&#x2F;2} \<br>&amp;&#x3D; \frac{1}{2\pi}<br>\end{align}<br>$$</p><p>$$<br>\begin{align}<br>p_{\boldsymbol{h}}(\theta_h) &amp;&#x3D; \int_0^{2\pi} p_{\boldsymbol{h}}(\phi_h,\theta_h) \sin\theta_h \space d\phi_h &#x3D; \int_0^{2\pi} \frac{\alpha_p+2}{2\pi}(\cos\theta_h)^{\alpha_p+1} \sin\theta_h \space d\phi_h \<br>&amp;&#x3D; (\alpha_p+2)(\cos\theta_h)^{\alpha_p+1} \sin\theta_h<br>\end{align}<br>$$</p></li><li><p>计算边缘概率分布<br>$$<br>\begin{align}<br>P_{\boldsymbol{h}}(\phi_{h_k}) &amp;&#x3D; \int_0^{\phi_{h_k}} p_{\boldsymbol{h}}(\phi_h)\space d\phi_h &#x3D; \int_0^{\phi_{h_k}} \frac{1}{2\pi} \space d\phi_h \<br>&amp;&#x3D; \frac{\phi_{h_k}}{2\pi}<br>\end{align}<br>$$</p><p>$$<br>\begin{align}<br>P_{\boldsymbol{h}}(\theta_{h_k}) &amp;&#x3D; \int_0^{\theta_{h_k}} p_{\boldsymbol{h}}(\theta_h)\space d\theta_h &#x3D; \int_0^{\theta_{h_k}} (\alpha_p+2)(\cos\theta_h)^{\alpha_p+1} \sin\theta_h\space d\theta_h \<br>&amp;&#x3D; -\int_0^{\theta_{h_k}} (\alpha_p+2)(\cos\theta_h)^{\alpha_p+1}\space d(\cos\theta_h) &#x3D; -(\cos\theta_h)^{\alpha_p+2}\bigg|<em>0^{\theta</em>{h_k}} \<br>&amp;&#x3D; 1-(\cos\theta_{h_k})^{\alpha_p+2}<br>\end{align}<br>$$</p></li><li><p>根据均匀分布的采样点 $(x,y)$ 得到 Blinn Phong NDF 的采样点<br>$$<br>\begin{cases}<br>\frac{\phi_{h_k}}{2\pi} &#x3D; x \<br>1-(\cos\theta_{h_k})^{\alpha_p+2} &#x3D; y<br>\end{cases}<br>$$</p><p>$$<br>\begin{cases}<br>\phi_{h_k} &#x3D; x\cdot 2\pi \<br>\cos\theta_{h_k} &#x3D; (1-y)^{\frac{1}{\alpha_p+2}}<br>\end{cases} \tag{4}\label{Blinn Phong Sampled Microface Normal}<br>$$</p></li></ul><h3 id="3-2-2-GGX-NDF-到-PDF、CDF"><a href="#3-2-2-GGX-NDF-到-PDF、CDF" class="headerlink" title="3.2.2 GGX NDF 到 PDF、CDF"></a>3.2.2 GGX NDF 到 PDF、CDF</h3><p>GGX NDF 对应的概率密度为：<br>$$<br>p_{\boldsymbol{h}}(\theta_h,\phi_h)&#x3D;D_{GGX}(\boldsymbol{h})\cos\theta_h&#x3D;\frac{\alpha^2\cdot \cos\theta_h}{\pi((\cos\theta_h)^2(\alpha^2-1)+1)^2}<br>$$</p><ul><li><p>计算边缘概率密度<br>$$<br>\begin{align}<br>p_{\boldsymbol{h}}(\phi_h) &amp;&#x3D; \int_0^{\pi&#x2F;2} p_{\boldsymbol{h}}(\phi_h,\theta_h) \sin\theta_h \space d\theta_h&#x3D;\int_0^{\pi&#x2F;2} \frac{\alpha^2\cdot \cos\theta_h}{\pi((\cos\theta_h)^2(\alpha^2-1)+1)^2} \sin\theta_h \space d\theta_h \<br>&amp;&#x3D; -\int_0^{\pi&#x2F;2} \frac{\alpha^2\cdot \cos\theta_h}{\pi((\cos\theta_h)^2(\alpha^2-1)+1)^2} \space d(\cos\theta_h) \<br>&amp;&#x3D; -\frac{\alpha^2}{2\pi}\int_0^{\pi&#x2F;2} ((\cos\theta_h)^2(\alpha^2-1)+1)^{-2} \space d(\cos\theta_h)^2 \<br>&amp;&#x3D; \frac{\alpha^2}{2\pi(\alpha^2-1)}\cdot\frac{1}{(\cos\theta_h)^2(\alpha^2-1)+1}\bigg|_0^{\pi&#x2F;2} \<br>&amp;&#x3D; \frac{1}{2\pi}<br>\end{align}<br>$$</p><p>$$<br>\begin{align}<br>p_{\boldsymbol{h}}(\theta_h) &amp;&#x3D; \int_0^{2\pi} p_{\boldsymbol{h}}(\phi_h,\theta_h) \sin\theta_h \space d\phi_h &#x3D; \int_0^{2\pi} \frac{\alpha^2\cdot \cos\theta_h}{\pi((\cos\theta_h)^2(\alpha^2-1)+1)^2} \sin\theta_h \space d\phi_h \<br>&amp;&#x3D; \frac{2\alpha^2\cdot\cos\theta_h\cdot\sin\theta_h}{((\cos\theta_h)^2(\alpha^2-1)+1)^2}<br>\end{align}<br>$$</p></li><li><p>计算边缘概率分布<br>$$<br>\begin{align}<br>P_{\boldsymbol{h}}(\phi_{h_k}) &amp;&#x3D; \int_0^{\phi_{h_k}} p_{\boldsymbol{h}}(\phi_h)\space d\phi_h &#x3D; \int_0^{\phi_{h_k}} \frac{1}{2\pi} \space d\phi_h \<br>&amp;&#x3D; \frac{\phi_{h_k}}{2\pi}<br>\end{align}<br>$$</p><p>$$<br>\begin{align}<br>P_{\boldsymbol{h}}(\theta_{h_k}) &amp;&#x3D; \int_0^{\theta_{h_k}} p_{\boldsymbol{h}}(\theta_h)\space d\theta_h &#x3D; \int_0^{\theta_{h_k}} \frac{2\alpha^2\cdot\cos\theta_h\cdot\sin\theta_h}{((\cos\theta_h)^2(\alpha^2-1)+1)^2}\space d\theta_h \<br>&amp;&#x3D; -\int_0^{\theta_{h_k}} \frac{2\alpha^2\cdot\cos\theta_h}{((\cos\theta_h)^2(\alpha^2-1)+1)^2}\space d(\cos\theta_h) \<br>&amp;&#x3D; -\alpha^2\int_0^{\theta_{h_k}} \frac{1}{((\cos\theta_h)^2(\alpha^2-1)+1)^2}\space d(\cos\theta_h)^2 \<br>&amp;&#x3D; \frac{\alpha^2}{(\alpha^2-1)}\cdot\frac{1}{(\cos\theta_h)^2(\alpha^2-1)+1}\bigg|<em>0^{\theta</em>{h_k}} \<br>&amp;&#x3D; \frac{\alpha^2}{(\alpha^2-1)[(\cos\theta_{h_k})^2(\alpha^2-1)+1]}-\frac{1}{\alpha^2-1}<br>\end{align}<br>$$</p></li><li><p>根据均匀分布的采样点 $(x,y)$ 得到 GGX NDF 的采样点<br>$$<br>\begin{cases}<br>\frac{\phi_{h_k}}{2\pi}&#x3D;x \<br>\frac{\alpha^2}{(\alpha^2-1)[(\cos\theta_{h_k})^2(\alpha^2-1)+1]}-\frac{1}{\alpha^2-1} &#x3D; y<br>\end{cases}<br>$$</p><p>$$<br>\begin{cases}<br>\phi_{h_k} &#x3D; x\cdot 2\pi \<br>\cos\theta_{h_k} &#x3D; \sqrt{\frac{1-y}{(\alpha^2-1)y+1}}<br>\end{cases} \tag{5}\label{GGX Sampled Microface Normal}<br>$$</p></li></ul><h2 id="3-3-微表面法线概率密度函数到入射方向的概率密度（推导失败）"><a href="#3-3-微表面法线概率密度函数到入射方向的概率密度（推导失败）" class="headerlink" title="3.3 微表面法线概率密度函数到入射方向的概率密度（推导失败）"></a>3.3 微表面法线概率密度函数到入射方向的概率密度（推导失败）</h2><p>首先思考一个问题：假设已知概率密度 $p_1(u,v)$，并且存在变换 $s&#x3D;s(u,v),t&#x3D;t(u,v)$ ，求概率密度 $p_2(s,t)$ 。</p><p>由概率密度在随机变量的取值空间积分为 1，设 $(u,v)\in \Omega_1$，$(s,t)\in \Omega_2$有：<br>$$<br>\begin{align}<br>\int_{\Omega_1} p_1(u,v)\space dudv &amp;&#x3D; \int_{\Omega_2} p_2(s,t)\space dsdt \<br>&amp;&#x3D; \int_{\Omega_1}p_2\Big(s(u,v),t(u,v)\Big) \space ds(u,v)dt(u,v) \<br>&amp;&#x3D; \int_{\Omega_1}p_2\Big(s(u,v),t(u,v)\Big)\left|\frac{\part (s,t)}{\part (u,v)}\right| \space dudv<br>\end{align}<br>$$<br>因此有：<br>$$<br>p_1(u,v)&#x3D;p_2\Big(s(u,v),t(u,v)\Big)\left|\frac{\part (s,t)}{\part (u,v)}\right| \tag{6} \label{Transform PDF}<br>$$<br>其中 $\Large \left|\frac{\part (s,t)}{\part (u,v)}\right|$ 为雅可比行列式的绝对值 <a href="#%5B4%5D">[4]</a>，<br>$$<br>\left|\frac{\part (s,t)}{\part (u,v)}\right|&#x3D;\left|\frac{\part s}{\part u}\cdot \frac{\part t}{\part v}-\frac{\part s}{\part v}\cdot\frac{\part t}{\part u}\right|<br>$$<br>下面只需要找到入射方向 $\boldsymbol{l}$ 与微表面法线 $\boldsymbol{h}$ 的关系即可利用 $\eqref{Transform PDF}$ 来得到入射方向的概率密度。</p><p>$\boldsymbol{h}$ 的概率密度为 $p_\boldsymbol{h}(\boldsymbol{h})$，$\boldsymbol{l}$ 的概率密度为 $p_\boldsymbol{l}(\boldsymbol{l})$。对于 $z$ 坐标轴为宏平面法线 $\boldsymbol{n}$ 的 hemisphere区域 $\Omega^+$，有积分<br>$$<br>\int_{\Omega^+} p_\boldsymbol{h}(\boldsymbol{h}) \space d\boldsymbol{h}&#x3D;\int_{\Omega^+} p_\boldsymbol{l}(\boldsymbol{l}) \space d\boldsymbol{l}<br>$$</p><p>使用球坐标表示有：<br>$$<br>\begin{cases}<br>\boldsymbol{l}&#x3D;(\phi_l,\theta_l) \<br>\boldsymbol{h}&#x3D;(\phi_h,\theta_h)<br>\end{cases}<br>$$</p><p>$$<br>\iint_{\Omega^+} p_\boldsymbol{h}(\phi_h,\theta_h) \sin\theta_h \space d\theta_hd\phi_h&#x3D;\iint_{\Omega^+} p_\boldsymbol{l}(\phi_l,\theta_l) \sin\theta_l\space d\theta_ld\phi_l<br>$$</p><p>由于 $\boldsymbol{l}$ 与 $\boldsymbol{h}$ 位于同一平面内，因此 $\phi_l&#x3D;\phi_h$；观察 [Fig 1](#Reflection Fig) 有，$\theta_l+\theta_h&#x3D;\theta_v-\theta_h \$ 。因此，<br>$$<br>\begin{cases}<br>\phi_l&#x3D;\phi_h \<br>\theta_l&#x3D;\theta_v-2\theta_h<br>\end{cases}<br>$$<br>因此雅可比行列式有：<br>$$<br>\left|\frac{\part \phi_l}{\part \phi_h}\cdot \frac{\part \theta_l}{\part\theta_h}-\frac{\part \phi_l}{\part\theta_h }\cdot \frac{\part\theta_l}{\part \phi_h}\right|&#x3D;\left|1\times(-2)-0\times 0\right|&#x3D;2<br>$$</p><p>代入有：<br>$$<br>p_\boldsymbol{h}\sin\theta_h&#x3D;2\cdot p_\boldsymbol{l}\sin\theta_l \<br>p_\boldsymbol{l} &#x3D; \frac{p_\boldsymbol{h}}{2\sin\theta_l&#x2F;\sin\theta_h}<br>$$<br>????</p><p><a href="#%5B3%5D">[3]</a> 通过构造新的坐标系得到<br>$$<br>p_\boldsymbol{l}(\boldsymbol{l})&#x3D;\frac{p_\boldsymbol{h}(\boldsymbol{h})}{4(\boldsymbol{l}\cdot \boldsymbol{h})}&#x3D;\frac{p_\boldsymbol{h}(\boldsymbol{h})}{4(\boldsymbol{v}\cdot \boldsymbol{h})}<br>$$</p><h1 id="4-最终的渲染方程积分"><a href="#4-最终的渲染方程积分" class="headerlink" title="4 最终的渲染方程积分"></a>4 最终的渲染方程积分</h1><p>至此我们已经可以计算 $\eqref{BRDF MC}$ 的积分了，由上述可知<br>$$<br>p_{\boldsymbol{l}}(\boldsymbol{l})&#x3D;\frac{p_\boldsymbol{h}(\boldsymbol{h})}{4(\boldsymbol{v}\cdot \boldsymbol{h})}&#x3D;\frac{D(\boldsymbol{h})\cdot \cos\theta_h}{4(\boldsymbol{v}\cdot \boldsymbol{h})}<br>$$<br>$\eqref{BRDF MC}$ 中的 $p(\boldsymbol{l}<em>k)$ 即为上式的 $p</em>{\boldsymbol{l}}(\boldsymbol{l})$。假设第 $k$ 次均匀分布采样点为 $(x_k,y_k)\in[0,1]\times[0,1]$，经过 $\eqref{Blinn Phong Sampled Microface Normal}$ 与 $\eqref{GGX Sampled Microface Normal}$ 可以得到该采样点在 NDF 上对应的微表面法线 $\boldsymbol{h}_k$ ，有：<br>$$<br>p(\boldsymbol{l}_k)&#x3D;\frac{D(\boldsymbol{h}<em>k)\cdot \cos\theta</em>{h_k}}{4(\boldsymbol{v}\cdot \boldsymbol{h}_k)}&#x3D;\frac{D(\boldsymbol{h}_k)\cdot \boldsymbol{h}_k\cdot \boldsymbol{n}}{4(\boldsymbol{v}\cdot \boldsymbol{h}_k)}<br>$$<br> $\eqref{BRDF MC}$ 中第 $k$ 次采样结果代入上式有，<br>$$<br>\begin{align}<br>&amp; \frac{L_i(\boldsymbol{l}_k)f(\boldsymbol{l}<em>k,\boldsymbol{v})\cos\theta</em>{l_k}}{p(\boldsymbol{l}_k)} \<br>&amp;&#x3D; \frac{L_i(\boldsymbol{l}_k)\cdot(\boldsymbol{l}_k\cdot\boldsymbol{n})}{p(\boldsymbol{l}_k)}\cdot \frac{F(\boldsymbol{l}_k,\boldsymbol{v})\cdot G(\boldsymbol{l}_k,\boldsymbol{v},\boldsymbol{h}_k)\cdot D(\boldsymbol{h}_k)}{4(\boldsymbol{n}\cdot \boldsymbol{l}_k)(\boldsymbol{n}\cdot \boldsymbol{v})} \<br>&amp;&#x3D; \frac{L_i(\boldsymbol{l}_k)\cdot(\boldsymbol{l}_k\cdot\boldsymbol{n})}{\frac{D(\boldsymbol{h}_k)\cdot (\boldsymbol{h}_k\cdot \boldsymbol{n})}{4\boldsymbol{v}\cdot \boldsymbol{h}_k}}\cdot \frac{F(\boldsymbol{l}_k,\boldsymbol{v})\cdot G(\boldsymbol{l}_k,\boldsymbol{v},\boldsymbol{h}_k)\cdot D(\boldsymbol{h}_k)}{4(\boldsymbol{n}\cdot \boldsymbol{l}_k)(\boldsymbol{n}\cdot \boldsymbol{v})} \<br>&amp;&#x3D; \frac{L_i(\boldsymbol{l}_k)\cdot(\boldsymbol{v}\cdot \boldsymbol{h}_k)}{(\boldsymbol{h}_k\cdot \boldsymbol{n})}\cdot \frac{F(\boldsymbol{l}_k,\boldsymbol{v})\cdot G(\boldsymbol{l}_k,\boldsymbol{v},\boldsymbol{h}_k)}{(\boldsymbol{n}\cdot \boldsymbol{v})} \<br>&amp;&#x3D; \frac{L_i(\boldsymbol{l}_k)\cdot F(\boldsymbol{l}_k,\boldsymbol{v})\cdot G(\boldsymbol{l}_k,\boldsymbol{v},\boldsymbol{h}_k)\cdot (\boldsymbol{v}\cdot \boldsymbol{h}_k)}{(\boldsymbol{h}_k\cdot \boldsymbol{n})\cdot (\boldsymbol{n}\cdot \boldsymbol{v})}<br>\end{align}<br>$$<br>由上式可知，最终 BRDF 中的 NDF 项被舍去。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a name="[1]">[1]</a> [Real-Time Physically Based Material Basics](.&#x2F;2. Real-Time Physically Based Material Basics)</p><p><a name="[2]">[2]</a> [Introduction of Sampling in Computer](..&#x2F;Sample Algorithm&#x2F;2. Introduction of Sampling in Computer.md)</p><p><a name="[3]">[3]</a> <a href="https://www.graphics.cornell.edu/~bjw/wardnotes.pdf">https://www.graphics.cornell.edu/~bjw/wardnotes.pdf</a></p><p><a name="[4]">[4]</a> [Jacobian Matrix](..&#x2F;Math&#x2F;Jacobian Matrix.md)</p><p><a name="[5]">[5]</a> <a href="https://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/Importance_Sampling#sec:importance-sampling">https://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/Importance_Sampling#sec:importance-sampling</a></p>]]></content>
    
    
    <categories>
      
      <category>Rendering Blogs</category>
      
      <category>Graphics</category>
      
      <category>PBR</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Radiance Caching with On-Surface Caches for Real-Time Global Illumination</title>
    <link href="/2024/12/07/Paper%20Notes/Cloud%20Rendering/Radiance%20Caching%20with%20On-Surface%20Caches%20for%20Real-Time%20Global%20Illumination/"/>
    <url>/2024/12/07/Paper%20Notes/Cloud%20Rendering/Radiance%20Caching%20with%20On-Surface%20Caches%20for%20Real-Time%20Global%20Illumination/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Summary"><a href="#1-Summary" class="headerlink" title="1 Summary"></a>1 Summary</h1><p>本文提出了在 On-Surface Caches 管线下的两种类型radiance cache，以及基于这两种radiance cache的GI方法。定义在texture space下的radiance cache相较于probe或者hash grid等方案，有更好的时序一致性、直接位于表面之上的避免漏光等优点，以及可以在multi-viewer下共享radiance信息。</p><p>两种类型的radiance cache缓存了表面区域的半球8x8分辨率的radiance信息：</p><ul><li><p>primary cache: cache entry分配自每个viewer的visibility buffer，即直接可见表面。存储了到达cache位置的 incoming radiance。可用于查询像素的incoming radiance或者通过SH查询收到的irradiance。</p><p>cache entry 的更新：对于 diffuse 表面，使用 ray guiding 策略；对于 glossy 表面，使用 BRDF 重要性采样。</p></li><li><p>secondary cache: cache entry分配在primary cache弹射后交到的表面位置，即secondary hit。存储了cache位置的 outgoing radiance，可以用于查询某光线方向的radiance信息</p><p>cache entry 的更新：基于 ReSTIR 的直接光照着色以及在secondary cache中采样。secondary cache之间的采样可以实现无限反弹。</p></li></ul><p>基于这两种类型的radiance cache，作者提出GI的计算：</p><ul><li>像素的irradiance：在相邻两层mip level的primary cache之间执行trilinear插值</li><li>像素的反射：<ul><li>对于roughness较高的glossy，使用BRDF重要性采样primary cache的incoming radiance。由于 primary cache 是视角无关的radiance信息，尽管采样primary cache时使用BRDF重要性权重，仍然会受到限制。因此仅能应用于较粗糙的glossy表面。</li><li>对于roughness较低(低于0.2)的光滑表面：光滑表面的反射与视角相关性更强，对此每个视角执行BRDF重要性采样，trace视角相关的光线。反射光线仍然采样交点处的secondary cache。</li></ul></li></ul><h1 id="2-Background"><a href="#2-Background" class="headerlink" title="2 Background"></a>2 Background</h1><h1 id="3-Method"><a href="#3-Method" class="headerlink" title="3 Method"></a>3 Method</h1><p><a href="#%5B2%5D">[2]</a> 提出的 On-Surface Caches (OSC)，构建位于场景模型表面之上的texture-based cache，用于缓存渲染的中间计算。这篇论文基于此cache策略，提供一种 visibility-based radiance caching 方法，同类方法有 <a href="#%5B3%5D">[3]</a> <a href="#%5B4%5D">[4]</a>。不同于将最终radiance值存储在屏幕空间的screen-space方法，帧与帧之间不需要重投影，因为表面上的数据直接存放在时序一致的texture space。</p><h2 id="3-1-Radiance-Cache"><a href="#3-1-Radiance-Cache" class="headerlink" title="3.1 Radiance Cache"></a>3.1 Radiance Cache</h2><p>本文的方法利用两种类型的radiance cache，两种cache存储半球面上的radiance，如 <a href="#Fig-3.1">Fig-3.1</a>:</p><ul><li>primary hit cache: 用于存储到达表面（当前视角）命中点位置的incoming radiance</li><li>secondary hit cache: 存放outgoing radiance，本身也会被primary hit cache用于查询入射radiance。以及secondary hit cache直接可以互相采样，随着时间得到无限次弹射</li></ul><p><a href="#%5B4%5D">[4]</a> 中的hash grid cells不采样彼此，并且只缓存了hash grid内的直接光照，因此限制了屏幕外的多次弹射。</p><blockquote><p>incoming radiance 与 outgoing radiance。下面渲染方程计算P点在 $\boldsymbol{v}$ 方向上的 outgoing radiance，计算过程则是对半球面上的incoming radiance以及BRDF积分。<br>$$<br>L_o(P, \boldsymbol{v})&#x3D;\int_{\Omega^+}L_i(\boldsymbol{l})f(\boldsymbol{l}, \boldsymbol{v}) \cos\theta_l \space d\boldsymbol{l}<br>$$<br>irradiance。下面 diffuse 材质在 $\omega_o$ 方向上的outgoing radiance计算。由于diffuse brdf是常量，可以提出积分，因此得到先对incoming radiance的积分，该积分结果就是irradiance，(辐照度) 描述的是单位面积上接收到的总入射辐射能量<br>$$<br>L_o(\omega_o)&#x3D;\int_{\Omega^+} \mathcal{C}\cdot L_i(\omega_i)\cdot \cos\theta_i\space d\omega_i&#x3D;\mathcal{C}\cdot \int_{\Omega^+} L_i(\omega_i)\cdot \cos\theta_i\space d\omega_i<br>$$</p></blockquote><p>这两种radiance cache存储不同类型的radiance是有实际意义的。如果在 secondary hit cache 中存放 incoming radiance，那么当从 secondary hit cache 采样指定方向的outgoing radiance时，由渲染方程可知，需要执行一次积分，每次采样一次积分是不现实的；而在 primary hit cache 中存放 outgoing radiance，也就是直接查询着色点到视点方向的 outgoing radiance，这样cache在表面满足不了视口分辨率的精度。</p><p><a name="Fig-3.1"></a></p><p>![image-20241207155709420](&#x2F;images&#x2F;Paper Notes&#x2F;Cloud Rendering&#x2F;Radiance Caching with On-Surface Caches for Real-Time Global Illumination.assets&#x2F;image-20241207155709420.png)</p><center>Fig-3.1 左图：两种类型cache之间交互以及与环境、光照的交互；右图：cache的spatial filter，只能在位于同一island的caches之间执行</center><h3 id="3-1-1-Primary-Cache"><a href="#3-1-1-Primary-Cache" class="headerlink" title="3.1.1 Primary Cache"></a>3.1.1 Primary Cache</h3><p><a name="Fig-3.2"></a></p><p>![image-20241207164153230](&#x2F;images&#x2F;Paper Notes&#x2F;Cloud Rendering&#x2F;Radiance Caching with On-Surface Caches for Real-Time Global Illumination.assets&#x2F;image-20241207164153230.png)</p><center>Fig-3.2 Primary radiance cache 的可视化。(a) 每个方形是一个 8x8 texels 的cache entry，存储incoming radiance；(b) 展示了hit distance，用于 detail-preserving filtering。</center><p>primary cache entries 放置在由视点观察到的primary hits位置（即直接可见表面），存放了半球面上的incoming radiance数据，如图 <a href="#Fig-3.2">Fig-3.2</a> 所示。半球分辨率为 8x8，每个 texel 4通道，rgb 存放 radiance，a 存放hit distance。相比于 grid 形式的probe放置，定义在texture space的cache entry能够保留更多几何表面细节。</p><p>OSC 的mip bias用于管理一个cache entry的覆盖表面的区域大小，作者给出最优范围 1.5~3.5。在更新cache entry时，会在其中抖动采样一个点，得到 triangle ID与重心坐标，这可以确定其世界坐标。triangle ID 的精度不足会导致图 <a href="#Fig-3.4">Fig-3.4</a> 的问题。为此，作者将GI cache与triangle ID cache(visibility)的分辨率进行解耦，即可以使用更高分辨率的triangle ID，实验下来 triangle ID 的mip bias取-2最优，如图 <a href="#Fig-3.3">Fig-3.3</a>。</p><p>primary cache entry 会为每个VB样本执行，确保覆盖所有可见表面。如果相邻像素位于不同的island，那么为会每个像素分配一个cache entry，这回导致cache entry数量以及计算负载的增加。对于这一点，未来探索的一个潜在方向是优化分配策略，特别是针对非常小的表面。在分配新的cache entry时，我们尝试使用相邻的mip level的信息来初始化它。在发生mip level切换时，已存在的cache entry数据会被用于新出现的相邻mip level，从而确保平滑的mip level过渡。</p><p>对于 diffuse 表面，利用缓存的radiance信息执行 ray guiding 策略 <a href="#%5B3%5D">[3]</a><a href="#%5B4%5D">[4]</a> 。对于单个viewer的 glossy 反射，使用 BRDF 重要性采样。在更新 cache entry 的 incoming radiance 时，会将rays样本加载到shared memory中以atomic操作进行累积。</p><p>对于光线交于发光表面或者环境光，获取直接光照。对于小的发光表面，它们可能根本无法被 ray guiding 采样到（尤其是考虑到 8 × 8 的有限分辨率），因此可能导致时序不稳定性。</p><p><a name="Fig-3.3"></a></p><p>![image-20241207171925197](&#x2F;images&#x2F;Paper Notes&#x2F;Cloud Rendering&#x2F;Radiance Caching with On-Surface Caches for Real-Time Global Illumination.assets&#x2F;image-20241207171925197.png)</p><center>Fig-3.3 (a) 场景几何的实际triangle ID；(b) 方形表示了表面上的一个cache entry；(c) 2x2 下的triangle ID cache entry的三角形编号；(d) 4x4 下更精细的编号</center><p><a name="Fig-3.4"></a></p><p>![image-20241207171132639](&#x2F;images&#x2F;Paper Notes&#x2F;Cloud Rendering&#x2F;Radiance Caching with On-Surface Caches for Real-Time Global Illumination.assets&#x2F;image-20241207171132639.png)</p><center>Fig-3.4 (a) Black artifacts，由triangle ID对于cache表面的覆盖不充足，导致从cache到world的转换得到光线起点的过程匹配到相邻世界坐标；(b) 更精细的triangle ID可以明显缓解该问题</center><h3 id="3-1-2-Secondary-Cache"><a href="#3-1-2-Secondary-Cache" class="headerlink" title="3.1.2 Secondary Cache"></a>3.1.2 Secondary Cache</h3><p>irradiance probe 以及 <a href="#%5B4%5D">[4]</a> hash grid 的radiance caching方法会有潜在的漏光问题，主要是由于其放置于空间或者接近表面的位置，而不是表面上。因此需要一些启发式策略避免漏光。而本文提出的secondary cache直接放置于表面。</p><p>secondary cache 缓存了半球面的outgoing radiance，能够采样任意方向，并且由于cache entry之间可以彼此采样，可以达到多次弹射的全局光照，如图 <a href="#%5BFig-3.6%5D">Fig-3.6</a>。hemisphere采用 8x8 tile的分辨率。直接光照采用时序重采样的 ReSTIR <a href="#%5B5%5D">[5]</a> 。对于多次弹射光照，投射了 32 条余弦加权的光线，以使secondary cache entries 能够互相采样，也可以使用更复杂的采样策略。outgoing radiance则是为每个cached direction对incoming radiance(ray radiance)应用BRDF，即每个光线会执行64次计算。</p><p>与primary cache不同，secondary cache以固定的表面大小进行放置，大概 20cm X 20cm 到 30cm X 30cm。对于大场景，可以在距离所有视角远的区域降低cache分辨率。secondary cache entry的分配发生于primary cache的光线交于一个表面时。在cache区域采样时，triangle ID的改进与primary cache相同。</p><p><a name="Fig-3.5"></a></p><p>![image-20241207180126279](&#x2F;images&#x2F;Paper Notes&#x2F;Cloud Rendering&#x2F;Radiance Caching with On-Surface Caches for Real-Time Global Illumination.assets&#x2F;image-20241207180126279.png)</p><center>Fig-3.5 secondary radiance cache 的可视化。每个方形表示一个8x8 texels的cache entry，其中存放了outgoing radiance。secondary cache是紧密附着在表面上的，可以避免漏光。(a) 没有temporal filtering，比较噪；(b) filter后更平滑</center><p><a name="Fig-3.6"></a></p><p>![image-20241208194928613](&#x2F;images&#x2F;Paper Notes&#x2F;Cloud Rendering&#x2F;Radiance Caching with On-Surface Caches for Real-Time Global Illumination.assets&#x2F;image-20241208194928613.png)</p><center>Fig-3.6 (a) 单次弹射的全局光照，在比较暗的区域缺失了大量细节；(b) secondary cache采样彼此实现的无限反弹可以捕获的多弹射全局光照，明显增强了较暗角落的光照</center><h2 id="3-2-Cache-Data-Structure"><a href="#3-2-Cache-Data-Structure" class="headerlink" title="3.2 Cache Data Structure"></a>3.2 Cache Data Structure</h2><p>primary&#x2F;secondary cache 都具有 2x(8x8) 半精度 vec4，存放 radiance 和光线距离，应该是有一份历史信息；以及全精度的表面法线与位置 (是指采样点？)， 2 个vec3，法线与位置在初次访问cache时写入。primary cache 还需要 54 bytes SH系数，以及 4个64-bit 整数来存放相邻cache entries的地址。secondary cache 需要额外的 28 bytes 用于 reservoir。</p><p>因此，primary cache entry需要 1134 bytes，secondary cache entry 需要 1076 bytes。</p><ul><li>radiance与光线距离：2x8x8x4x2&#x3D;1024 bytes；法线与位置：2x3x4&#x3D;24bytes；SH系数：54 bytes；相邻地址：4x8&#x3D;32 bytes；共 1024+24+54+32&#x3D;1134bytes</li><li>radiance与光线距离：1024 bytes；法线与位置：2x3x4&#x3D;24bytes；reservoir：28 bytes；共 1024+24+28&#x3D;1056 bytes</li></ul><h2 id="3-3-Temporal-Filtering"><a href="#3-3-Temporal-Filtering" class="headerlink" title="3.3 Temporal Filtering"></a>3.3 Temporal Filtering</h2><p>OSC下temporal filtering不需要重投影，作者采用基于时间的 exponential moving average，blending factor为样本数的倒数，设置样本数范围 4~8，应对不同的响应速度。来自低样本数的噪声可以通过screen-space denoiser来减轻。对于来自 primary hit cache 的 glossy 反射，降低样本数至4以下。</p><h2 id="3-4-Spatial-Filtering"><a href="#3-4-Spatial-Filtering" class="headerlink" title="3.4 Spatial Filtering"></a>3.4 Spatial Filtering</h2><p>相邻的cache texel位于同一平面上，如图 <a href="#Fig-3.1">Fig-3.1</a>，cache space下的filter没有必要进行depth&#x2F;normal检查以及启发式策略。作者仅采用一个额外的blur，半径为3，权重为 1&#x2F;(step+1) 的filter。</p><p>同一表面上也可能出现light bleeds，例如，Sponza场景中窗帘下方的光线溢出到地板上。作者使用 <a href="#%5B3%5D">[3]</a> 提出的angle error detection 方法解决该问题。此外，在选择filter邻居时，引入视差矫正方向，避免过度模糊，如图 <a href="#Fig-3.7">Fig-3.7</a>。</p><p>island 边界问题，位于不同的island的邻居无法被访问，这会导致一条明显的缝。这在定义不佳的island上尤为明显，例如，当一个平坦表面由多个islands组成时。这种在没有表面纹理的场景中非常显眼，但在许多应用了表面纹理的场景中，接缝的可见性会大大降低，如图 <a href="#Fig-3.8">Fig-3.8</a> 所示。</p><p><a name="Fig-3.7"></a></p><p>![image-20241209110506190](&#x2F;images&#x2F;Paper Notes&#x2F;Cloud Rendering&#x2F;Radiance Caching with On-Surface Caches for Real-Time Global Illumination.assets&#x2F;image-20241209110506190.png)</p><center>Fig-3.7 Sponza 场景窗帘被间接光照照亮。(a) filter过程中，为相邻cache entriy使用相同方向，导致细节丢失以及过渡平坦。(b) 使用视差矫正方向保留了光照特征。</center><p><a name="Fig-3.8"></a></p><p>![image-20241209111702863](&#x2F;images&#x2F;Paper Notes&#x2F;Cloud Rendering&#x2F;Radiance Caching with On-Surface Caches for Real-Time Global Illumination.assets&#x2F;image-20241209111702863.png)</p><center>Fig-3.8 由于spatial filter无法跨island边界，导致明显的缝隙。相接、平坦或者曲率很低的表面应该位于一个island上，来避免island边界的缝隙问题。最左边两张图中，被划分了多个不同的island，导致明显的缝隙；有时这些边界可能被surface texture隐藏，例如最右边两张图中</center><h2 id="3-5-Irradiance-Evaluation"><a href="#3-5-Irradiance-Evaluation" class="headerlink" title="3.5 Irradiance Evaluation"></a>3.5 Irradiance Evaluation</h2><p>在相邻两个mip层级的primary cache之间执行trilinear插值得到像素的irradiance。primary cache可以转为SH提供diffuse illumination；或者应用半球上incoming radiance的 BRDF重要性采样，支持更细节的surface shading以及glossy reflections，如图 <a href="#Fig-3.9">Fig-3.9</a>。trilinear 插值来自SH的irradiance是比较高效的，但重要性采样的trilinear插值相对较慢。对此，作者选择在三线性插值样本中进行基于插值权重的随机采样。这种方法将每像素的cache访问次数从 8 次减少到 1 次。然而，它会引入少量额外噪声，这可以通过temporal filter减轻。</p><p><a name="Fig-3.9"></a></p><p>![image-20241209113157530](&#x2F;images&#x2F;Paper Notes&#x2F;Cloud Rendering&#x2F;Radiance Caching with On-Surface Caches for Real-Time Global Illumination.assets&#x2F;image-20241209113157530.png)</p><center>Fig-3.9 除窗帘外，roughness 设置为 0.4。(a)~(c) 是没有TAA或者其它filter，对primary hit cache的不同spp下的BRDF重要性采样。时间与每个VB像素采样primary cache相关；(d) 8spp下以及简单temporal filter的TAA；(e) path-traced reference，五次bounce累积40K帧。本文的方法成功捕捉了glossy反射。然而，与参考图像相比，某些高光未能完全重现，作者认为这与filter过程以及cache分辨率可能不足有关。</center><h2 id="3-6-Reflections"><a href="#3-6-Reflections" class="headerlink" title="3.6 Reflections"></a>3.6 Reflections</h2><p>与AMD-GI1.1<a href="#%5B6%5D">[6]</a> 相似，本文提供了两种处理反射的方式，多个视角可以在secondary hit时共享radiance信息并提供多次反射光照：</p><ul><li>glossy reflection 通过对primary hit hemisphere进行 BRDF 重要性采样来实现，而不是依赖球谐函数（如图 <a href="#Fig-3.10">Fig-3.10</a>）。由于半球已经捕获了incoming radiance，因此无需进一步进行光线追踪。为了提供更好的反射质量，incoming radiance应通过 BRDF 重要性采样追踪，而不是使用ray guiding方案。然而，需要注意的是，<strong>这种方法在缺少单一视角的multi-viewer场景中会遇到限制</strong>。虽然ray guiding仍然是一个选项，但这会以降低反射质量为代价。为了确保反射的响应性，重要的是减少主要缓存的时间滤波强度，如第 3.3 节所述。</li><li>sharp reflections 是通过使用专门的反射光线来实现的，如图 <a href="#Fig-3.11">Fig-3.11</a> 所示。这些光线的radiance从secondary cache中获取，其中已缓存了outgoing radiance。secondary cache支持multi-viewer场景，因为每个viewer可以发射独立的反射光线，同时共享存储在secondary cache中radiance信息。这是因为outgoing radiance是按半球存储的。实际实现中根据材质属性动态决定<strong>是否发射反射光线</strong>，特别是在粗糙度低于特定阈值（本文 0.2）时。</li></ul><blockquote><p>这两种方法应该是适应不同的粗糙度水平。</p><ul><li>对于粗糙度较高的glossy表面，反射光线的radiance从primary cache中采样，由于primary cache中的incoming radiance已经包含了secondary cache中的outgoing radiance，因此有无限反弹的信息。注意，primary cache是视角无关的，虽然反射采样incoming radiance是可以使用BRDF重要性权重，但视角相关的反射仍然会缺失信息。</li><li>对于粗糙度低的光滑表面，需要额外trace反射光线，反射光线的radiance来自于secondary cache的outgoing radiance。光滑表面的反射与视角更加强相关，这里要每个view单独trace反射光线。似乎这也就是说，这里要为反射光线生成secondary cache entry</li></ul></blockquote><p>通过在两种方法中都依赖次级缓存中的入射辐射，我们的系统通过反射提供了多次反射光照，如图 <a href="#Fig-3.12">Fig-3.12</a> 所示。然而，需要注意的是，这两种方法仍然会出现一些噪声，因此需要进行screen-space filer。</p><p><a name="Fig-3.10"></a></p><p>![image-20241209132939923](&#x2F;images&#x2F;Paper Notes&#x2F;Cloud Rendering&#x2F;Radiance Caching with On-Surface Caches for Real-Time Global Illumination.assets&#x2F;image-20241209132939923.png)</p><center>Fig-3.10 重要性采样primary cache、path-traced reference与AMD-GI1.1之间的对比。尽管secondary cache entry覆盖的区域要大得多，但它们为primary cache生成了令人满意的光滑反射，接近路径追踪的参考结果。对primary cache进行重要性采样更适合处理较大物体的反射，并且粗糙度的最低值大约为 0.2。</center><p><a name="Fig-3.11"></a></p><p>![image-20241209133723897](&#x2F;images&#x2F;Paper Notes&#x2F;Cloud Rendering&#x2F;Radiance Caching with On-Surface Caches for Real-Time Global Illumination.assets&#x2F;image-20241209133723897.png)</p><center>Fig-3.11 在VB的ray-traced反射中，secondary cache为反射光线提供radiance，消除了进一步光线投射的昂贵开销。左图，具有近似镜面反射的地板；secondary cache覆盖范围广，偶尔会出现在反射中。由于缓存分辨率较低，表面细节（如黄色便签上的画）受到影响。右图，粗糙度为 0.1，场景显得更平滑，使得secondary cache变得更难以辨认。</center><p><a name="Fig-3.12"></a></p><p>![image-20241209134052245](&#x2F;images&#x2F;Paper Notes&#x2F;Cloud Rendering&#x2F;Radiance Caching with On-Surface Caches for Real-Time Global Illumination.assets&#x2F;image-20241209134052245.png)</p><center>Fig-3.12 secondary cache 能够为 ray-traced reflections 提供无限反弹。左图没有无限反弹；中间使用secondary cache达到的无限反弹；右图是AMD-GI1.1的效果，无法提供屏幕外的无限反弹</center><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a name="[1]">[1]</a> Wolfgang Tatzgern, Alexander Weinrauch, Pascal Stadlbauer, Joerg H. Mueller, Martin Winter, and Markus Steinberger. 2024. Radiance Caching with On-Surface Caches for Real-Time Global Illumination. Proc. ACM Comput. Graph. Interact. Tech. 7, 3, Article 38 (August 2024), 17 pages.</p><p><a name="[2]">[2]</a> Alexander Weinrauch. 2023. Effect-based Multi-viewer Caching for Cloud-native Rendering. <em>siggraph</em> (2023).</p><p><a name="[3]">[3]</a> Daniel Wright, Krzysztof Narkowicz, and Patrick Kelly. 2022. Lumen: Real-time Global Illumination in Unreal Engine 5. <a href="https://advances.realtimerendering.com/s2022/index.html">https://advances.realtimerendering.com/s2022/index.html</a></p><p><a name="[4]">[4]</a> Guillaume Boissé, Sylvain Meunier, Heloise de Dinechin, Pieterjan Bartels, Alexander Veselov, Kenta Eto, and Takahiro Harada. 2023. GI-1.0: A Fast and Scalable Two-level Radiance Caching Scheme for Real-time Global Illumination. </p><p><a name="[5]">[5]</a> Benedikt Bitterli, Chris Wyman, Matt Pharr, Peter Shirley, Aaron Lefohn, and Wojciech Jarosz. 2020. Spatiotemporal reservoir resampling for real-time ray tracing with dynamic direct lighting. ACM Transactions on Graphics (TOG) 39, 4 (2020), 148–1  </p><p><a name="[6]">[6]</a> Kenta Eto, Sylvain Meunier, Takahiro Harada, and Guillaume Boissé. 2023. Real-Time Rendering of Glossy Reflections Using Ray Tracing and Two-Level Radiance Caching. In SIGGRAPH Asia 2023 Technical Communications  </p>]]></content>
    
    
    <categories>
      
      <category>Paper Notes</category>
      
      <category>Cloud Rendering</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Virtual Texture</title>
    <link href="/2024/11/28/Paper%20Notes/Render%20Pipeline/Virtual%20Texture/"/>
    <url>/2024/11/28/Paper%20Notes/Render%20Pipeline/Virtual%20Texture/</url>
    
    <content type="html"><![CDATA[<p>GPU Pro7</p>]]></content>
    
    
    <categories>
      
      <category>Paper Notes</category>
      
      <category>Render Pipeline</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/11/24/Rendering%20Blogs/Profile/Structured%20Buffer%20Performance/"/>
    <url>/2024/11/24/Rendering%20Blogs/Profile/Structured%20Buffer%20Performance/</url>
    
    <content type="html"><![CDATA[<h1 id="1-对齐问题-1"><a href="#1-对齐问题-1" class="headerlink" title="1 对齐问题 [1]"></a>1 对齐问题 <a href="#%5B1%5D">[1]</a></h1><p>structured buffer 为在 GPU 上表示除了颜色或4分量之外的数据结构提供了一个非常便利的解决方案，非常适用于如 tile-based deferred shading 等技术。</p><p>structured buffer 的内存是紧密排列的（与C++的默认对齐似乎是一样的），例如以下代码会生成步幅20字节的缓冲区</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span><br>&#123;<br>    float4 Position;<br>    <span class="hljs-type">float</span> Radius;<br>&#125;;<br>StructuredBuffer&lt;Foo&gt; FooBuf;<br></code></pre></td></tr></table></figure><p>这存在一个问题：由于结构体的大小没有对齐到 128-bit，<code>Position</code>可能会跨cache line，这会导致数据读取更加昂贵。虽然一次非高效的读取可能不会对性能造成太大影响，但随着代码的复杂性增加，它可能迅速放大。例如，着色器对复杂光源列表进行迭代，每个光源包含超过 100 字节的数据，这可能成为一个严重的性能瓶颈。事实上，我们最近发现了一段预发布代码，仅因为这种差异，就导致了全帧性能下降超过 5%。</p><p>避免这些问题的简单做法：</p><ul><li>设计大小为 128-bit 整数倍的结构体</li><li>注意内部对齐，是向量类型能够自然对齐</li></ul><p>调整后如下所示，尽管这样会浪费一些内存，但相比于性能损失，代价更小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span><br>&#123;<br>    float4 Position;<br>    <span class="hljs-type">float</span>  Radius;<br>    <span class="hljs-type">float</span> pad0;<br>    <span class="hljs-type">float</span> pad1;<br>    <span class="hljs-type">float</span> pad2;<br>&#125;;<br>StructuredBuffer&lt;Foo&gt; FooBuf;<br></code></pre></td></tr></table></figure><h1 id="2-冗余使用与延迟-2"><a href="#2-冗余使用与延迟-2" class="headerlink" title="2 冗余使用与延迟 [2]"></a>2 冗余使用与延迟 <a href="#%5B2%5D">[2]</a></h1><p>structured buffer 的处理有冗余会给性能带来影响。如下代码中，这种写法导致每个线程都在重复获取相同的数据。对于包含大量光源的列表，这种冗余工作可能会非常多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">StructuredBuffer&lt;Light&gt; LightBuf;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_lights; i++) &#123;<br>    Light cur_light = LightBuf[i];<br><br>    <span class="hljs-comment">// Do Lighting</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结构化缓冲区的实现机制</strong>是针对分散访问设计的，具备较好的性能。但这种设计的一个特点是：structured buffer 每次获取数据都可能有相当的延迟。当所有线程完全一致地访问时，缓存命中率会非常高，但延迟问题仍然存在。在这种情况下，将数据批量存储到共享内存中可能是一个更好的选择。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">StructuredBuffer&lt;Light&gt; LightBuf;<br>groupshared Light[MAX_LIGHTS] LocalLights;<br><br>LocalLights[ThreadIndex] = LightBuf[ThreadIndex];<br><span class="hljs-built_in">GroupSharedMemoryBarrierWithGroupSync</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_lights; i++) &#123;<br>    Light cur_light = LocalLights[i];<br><br>    <span class="hljs-comment">// Do Lighting</span><br>&#125;<br></code></pre></td></tr></table></figure><p>显然，这种优化增加了代码复杂性，同时可能因为共享内存压力或额外的barrier指令而无法提升性能。此外，结构体的大小也会影响这一方法的效率。例如，对于大小为 1024 字节的结构体，由于线程之间的步幅较大，效率可能会受到影响。在某些情况下，使用更简单的结构体设计，比如将数据展平为 <code>float</code> 或 <code>float4</code> 数组，并手动计算索引偏移，可能会更高效。尽管代码会显得复杂一些，但这是一个内部循环，<strong>消除冗余</strong>可能值得为此付出代价。</p><h1 id="3-Constant-Buffers-3"><a href="#3-Constant-Buffers-3" class="headerlink" title="3 Constant Buffers [3]"></a>3 Constant Buffers <a href="#%5B3%5D">[3]</a></h1><p>本章节将讨论如何使用常量缓冲区（Constant Buffers）来避免结构化缓冲区（Structured Buffers）可能遇到的陷阱。constant buffer 即GL中的uniform buffer。</p><p>作为开发者，应该考虑为何使用 structured buffer。如果数据大小可以满足 constant buffer 限制的 64 KB 空间，那么 constant buffer 可能是一个更好的选择。这在代码使用一致访问模式时尤为适用（如上一章节描述的那样，连续访存）。<strong>constant buffer 的一致性访问的效率很高，延迟比 structured buffer 低。而 structured buffer 的分散访问性能更好</strong>，如果代码的访问模式预计会有大量不一致性，那么 structured buffer 才是真正的优选。</p><p>来自一个实际的示例：使用结构化缓冲区、128-bit 步幅、一致的访问模式，并且数据量小于 64 KB。将该结构化缓冲区转换为常量缓冲区后，单个着色器的执行时间减少了 25-33%，整体帧率提升了 10%。这仅通过更改一个资源的类型就能获得如此显著的性能提升。以下是代码示例及所需的更改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Light</span><br>&#123;<br>    float3 Position;<br>    <span class="hljs-type">float</span> Radius;<br>    float4 Color;<br>    float3 AttenuationParams;<br>    uint Type;<br>&#125;;<br><br><span class="hljs-comment">// Original code</span><br>StructuredBuffer&lt;Light&gt; LightBuf;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_lights; i++)<br>&#123;<br>    Light cur_light = LightBuf[i];<br><br>    <span class="hljs-comment">// Do Lighting</span><br>&#125;<br><br><span class="hljs-comment">// Revised code</span><br>cbuffer LightCBuf<br>&#123;<br>    Light LightBuf[MAX_LIGHTS];<br>&#125;;<br> <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_lights; i++)<br>&#123;<br>    Light cur_light = LightBuf[i];<br><br>    <span class="hljs-comment">// Do Lighting</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-1-实例：Tiled-Deferred-Lighting"><a href="#3-1-实例：Tiled-Deferred-Lighting" class="headerlink" title="3.1 实例：Tiled Deferred Lighting"></a>3.1 实例：Tiled Deferred Lighting</h2><p><strong>在实际应用中，结构化缓冲区的一个常见用途是支持分块延迟光照（Tiled Deferred Lighting）。</strong><br>这种情况下，使用常量缓冲区会遇到两个限制：</p><ol><li>数据量可能超出常量缓冲区的容量。</li><li>虽然着色阶段通常是一致访问，但 culling 阶段通常完全是分散的访问。（应该是指为tile生成光源列表）</li></ol><p>幸运的是，这两个问题都可以通过简单的解决方案解决。</p><h3 id="3-1-1-拆分结构体"><a href="#3-1-1-拆分结构体" class="headerlink" title="3.1.1 拆分结构体"></a>3.1.1 拆分结构体</h3><p>如果需要 256 字节的结构体来表示光源，并支持超过 256 个光源，那么数据大小超过了 constant buffer 的限制。以下代码展示了两个解决方案：</p><ol><li>将结构体拆分为多个小结构体。</li><li>保留 structured buffer，同时创建一个并行的 constant buffer，只包含最常用的数据。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Light</span> <span class="hljs-comment">// 144 bytes, only 455 lights possible w/ CB</span><br>&#123;<br>    float3 Position;<br>    <span class="hljs-type">float</span> Radius;<br>    float4 Color;<br>    float3 AttenuationParams;<br>    uint Type;<br>    float4 SpotDirectionAndAngle;<br>    float4 ShadowRect;<br>    float4x4 ShadowMatrix;<br>&#125;;<br><br><span class="hljs-comment">// Original structured buffer version</span><br>StructuredBuffer&lt;Light&gt; LightBuf;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Two constant buffers, with lesser-used shadow data in second</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LightBase</span> <span class="hljs-comment">// 64 bytes, 1024 lights possible</span><br>&#123;<br>    float3 Position;<br>    <span class="hljs-type">float</span> Radius;<br>    float4 Color;<br>    float3 AttenuationParams;<br>    uint Type;<br>    float4 SpotDirectionAndAngle;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LightShadow</span> <span class="hljs-comment">// 80 bytes, 819 lights possible</span><br>&#123;<br>    float4 ShadowRect;<br>    float4x4 ShadowMatrix;<br>&#125;;<br><br><span class="hljs-comment">// MAX_LIGHTS restricted to min of two structures</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_LIGHTS 819</span><br><br>cbuffer LightCBuf<br>&#123;<br>    LightBase LightBufBase[MAX_LIGHTS];<br>&#125;;<br><br>cbuffer LightCBufShadow<br>&#123;<br>    LightShadow LightBufShadow[MAX_LIGHTS];<br>&#125;;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * One constant buffer for core parameters with structured buffer</span><br><span class="hljs-comment"> * for infrequently used parameters and divergent access</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// MAX_LIGHTS restricted by only the one structure</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_LIGHTS 1024</span><br><br>cbuffer LightCBuf<br>&#123;<br>    LightBase LightBufBase[MAX_LIGHTS];<br>&#125;;<br><br>StructuredBuffer&lt;Light&gt; LightBuf;<br></code></pre></td></tr></table></figure><h3 id="3-1-2-处理分散访问"><a href="#3-1-2-处理分散访问" class="headerlink" title="3.1.2 处理分散访问"></a>3.1.2 处理分散访问</h3><p>处理分散访问则更加简单。如上代码注释所述，只需在 culling 阶段绑定数据的结构化缓冲区副本即可解决问题。这需要为数据创建冗余副本，但额外的 64-256 KB 数据代价很小，换来的性能提升可能高达帧率的 10%。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a name="[1]">[1]</a> <a href="https://developer.nvidia.com/content/understanding-structured-buffer-performance">https://developer.nvidia.com/content/understanding-structured-buffer-performance</a></p><p><a name="[2]">[2]</a> <a href="https://developer.nvidia.com/content/redundancy-and-latency-structured-buffer-use">https://developer.nvidia.com/content/redundancy-and-latency-structured-buffer-use</a></p><p><a name="[3]">[3]</a> <a href="https://developer.nvidia.com/content/how-about-constant-buffers">https://developer.nvidia.com/content/how-about-constant-buffers</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GPU Logic</title>
    <link href="/2024/11/22/Rendering%20Blogs/Profile/GPU%20Logic/"/>
    <url>/2024/11/22/Rendering%20Blogs/Profile/GPU%20Logic/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Life-of-triangle-1"><a href="#1-Life-of-triangle-1" class="headerlink" title="1 Life of triangle [1]"></a>1 Life of triangle <a href="#%5B1%5D">[1]</a></h1><p>![NVIDIA’s logical pipeline](&#x2F;images&#x2F;Rendering Blogs&#x2F;Profile&#x2F;GPU Logic.assets&#x2F;fermipipeline.png)</p><h2 id="1-1-GPUs-are-super-parallel-work-distributors"><a href="#1-1-GPUs-are-super-parallel-work-distributors" class="headerlink" title="1.1 GPUs are super parallel work distributors"></a>1.1 GPUs are super parallel work distributors</h2><p>为什么需要这些复杂性？在图形渲染中，我们需要处理数据扩展 (data amplification) 的问题，这会带来大量不确定的工作负载。每个 draw call 可能生成不同数量的三角形。裁剪后的顶点数量可能与最初的三角形数量不同。在背面剔除和深度剔除之后，不同的三角形可能生成不同的像素。</p><p>因此，现代GPU让它们的基本图元（三角形、线、点）遵循的是逻辑流水线，而不是物理流水线。在早期（G80统一架构之前，如DX9硬件、PS3、Xbox360），流水线在芯片上通过不同的阶段体现，工作依次通过这些阶段处理。G80架构基本上对部分单元进行了复用，可以根据负载在顶点着色器和片段着色器之间切换，但仍然以串行方式处理图元、光栅化等。而从Fermi架构开始，流水线变得完全并行，这意味着芯片通过复用多个内部引擎实现了逻辑流水线（即三角形经过的各个步骤）。</p><p>假设有两个三角形A和B。它们可能处于不同的逻辑流水线步骤中。例如，A已经被变换，正在进行光栅化。一些像素可能在执行fragment shader，一些像素可能被深度缓冲剔除（Z-cull），还有一些像素可能已经写入帧缓冲区，而还有一些可能仍在等待。同时，三角形B可能在提取顶点数据。因此，尽管每个三角形都需要经过这些逻辑步骤，但许多三角形生命周期的不同阶段可以同时被处理。整个draw call任务被拆分为许多较小的任务，甚至是子任务，这些任务可以并行运行。每个任务都会根据可用的资源进行调度，这种调度不限于某种特定类型的任务（例如顶点着色和片段着色可以并行进行）。</p><p>可以把这想象成一条分叉的河流。并行的pipeline stream是彼此独立的，每条pipeline都有自己的时间线，有些pipeline可能分支更多。如果我们用颜色对GPU中的单元进行编码，标记它们当前正在处理的三角形或draw call，那么整个系统就会像一片多彩的“闪烁灯”景象 :)</p><h2 id="1-2-GPU-architecture"><a href="#1-2-GPU-architecture" class="headerlink" title="1.2 GPU architecture"></a>1.2 GPU architecture</h2><p>![GPU architecture](&#x2F;images&#x2F;Rendering Blogs&#x2F;Profile&#x2F;GPU Logic.assets&#x2F;fermipipeline_maxwell_gpu.png)</p><p>由于 Fermi 架构的 NVIDIA GPU 拥有相似的基本架构设计，其中核心部分是一个管理所有任务的 <strong>Giga Thread Engine</strong>。GPU 被划分为多个 <strong>GPC（Graphics Processing Cluster，图形处理簇）</strong>，每个 GPC 包含多个 <strong>SM（Streaming Multiprocessor，流式多处理器）</strong> 和一个 <strong>Raster Engine（光栅引擎）</strong>。在这些组件之间有大量的互联结构，其中最为重要的是 <strong>Crossbar（交叉开关）</strong>，它允许任务在 GPC 或其他功能单元（例如 <strong>ROP（Render Output Unit，渲染输出单元）</strong> 子系统）之间迁移。</p><p>程序员编写的任务（例如着色器程序的执行）实际上是由 SM 来完成的。SM 包含许多 <strong>Core（核心）</strong>，这些核心负责执行线程的数学运算。例如，一个线程可以对应于一个顶点着色器或像素着色器的调用。这些核心以及其他单元由 <strong>Warp Scheduler（Warp 调度器）</strong> 驱动，每个 Warp 调度器管理一组 32 个线程（称为一个 Warp），并将需要执行的指令交给 <strong>Dispatch Unit（分发单元）</strong>。指令的逻辑由调度器处理，而核心本身并不负责逻辑计算。核心接收到的指令类似于“<em>“sum register 4234 with register 4235 and store in 4230</em>”。相比之下，GPU 的核心显得相对“简单”，而 CPU 的核心则更“智能”。GPU 将智能设计集中在更高的架构层面，协调整个系统（甚至多个系统）的工作。</p><p>GPU 上这些单元的具体数量（例如每个 GPC 包含多少个 SM，每个 GPU 有多少个 GPC）取决于具体的芯片配置。</p><h2 id="1-3-The-logical-pipeline"><a href="#1-3-The-logical-pipeline" class="headerlink" title="1.3 The logical pipeline"></a>1.3 The logical pipeline</h2><p>![The logical pipeline](&#x2F;images&#x2F;Rendering Blogs&#x2F;Profile&#x2F;GPU Logic.assets&#x2F;fermipipeline_begin.png)</p><p>为简化起见，省略了一些细节。我们假设 drawcall 引用了一些已经填充好数据的 index- and vertex-buffer，这些缓冲区存储在 GPU 的 DRAM 中，并且仅使用 VS 和 PS：</p><ol><li><p>程序在图形 API中发起 drawcall。该调用最终会到达驱动程序，驱动程序对调用进行一些合法性验证，并将命令以 GPU 可读取的编码形式插入到 <strong>pushbuffer（推送缓冲区）</strong> 中。在此过程中，CPU 端可能出现许多瓶颈，因此程序员需要合理使用 API，并采用能充分利用现代 GPU 性能的技术。</p></li><li><p>一段时间后或显式的“flush”调用，驱动程序在 pushbuffer 中积累了足够的工作量，将其发送给 GPU 进行处理（这一过程可能需要操作系统的部分参与）。GPU 的 <strong>Host Interface（主机接口）</strong> 接收到这些命令，并通过 <strong>Front End（前端）</strong> 进行处理。</p></li><li><p>接着，工作分发开始于 <strong>Primitive Distributor（图元分发器）</strong>，通过处理 index buffer 中的索引数据生成三角形工作批次，并将其分发到多个 <strong>GPC</strong>。</p><p>![The logical pipeline](&#x2F;images&#x2F;Rendering Blogs&#x2F;Profile&#x2F;GPU Logic.assets&#x2F;fermipipeline_sm.png)</p></li><li><p>在 <strong>GPC（图形处理簇）</strong> 内，一个 <strong>SM（流式多处理器）</strong> 的 <strong>Poly Morph Engine（多边形形变引擎）</strong> 负责从三角形索引中提取顶点数据（即Vertex Fetch）</p></li><li><p>完成顶点数据的提取后，<strong>SM</strong> 内会调度一个由 32 个线程组成的 <strong>Warp（线程束）</strong> 来处理这些顶点数据。</p></li><li><p><strong>SM</strong> 的 <strong>Warp 调度器（Warp Scheduler）</strong> 会按照顺序为整个 Warp 发出指令。这些线程以 lock-step 执行每条指令，但如果某些线程无需执行某条指令，则它们可以被单独屏蔽。屏蔽线程的情况可能包括：</p><ul><li><strong>例 1</strong>：当前指令属于 “if (true)” 分支，但某个线程的数据条件计算结果为 “false”；</li><li><strong>例 2</strong>：某个线程已经满足了循环终止条件，而其他线程尚未满足。</li></ul><p>因此，当着色器中出现大量分支分歧（<strong>branch divergence</strong>）时，将显著增加 Warp 中所有线程的执行时间。</p><p>需要注意的是，线程无法独立推进，它们只能以 Warp 为单位共同推进！不过，Warp 之间是相互独立的。</p></li><li><p>Warp 的一条指令可能一次完成，也可能需要多个调度周期。例如，在 <strong>SM</strong> 中，处理 <strong>load&#x2F;store</strong> 操作的单元通常比处理基本数学运算的单元要少。</p></li><li><p>由于某些指令（特别是内存加载）需要更长的时间来完成，<strong>Warp 调度器</strong> 会切换到其他不需要等待内存的 Warp。这正是 <strong>GPU</strong> 克服内存读取延迟的关键机制：通过切换warp，隐藏延迟并减少等待时间。为了实现快速切换，调度器管理的所有线程在 <strong>寄存器文件（register file）</strong> 中拥有各自独立的寄存器。如果某个着色器程序需要的寄存器较多，那么可容纳的线程&#x2F;Warps 就会减少。这意味着可供切换的 Warp 也减少，从而在等待指令完成（尤其是内存加载）期间，可执行的有效工作量也会减少。这种<strong>寄存器资源的限制</strong>可能会导致效率下降。</p><p>![The logical pipeline](&#x2F;images&#x2F;Rendering Blogs&#x2F;Profile&#x2F;GPU Logic.assets&#x2F;fermipipeline_memoryflow.png)</p></li><li><p>当 <strong>Warp</strong> 完成所有顶点着色器的指令后，其结果将由 <strong>视口变换</strong> 进行处理。随后，三角形将在 clip space volume 内进行裁剪，准备进入光栅化阶段。 在这一过程中，我们使用 <strong>L1 缓存</strong> 和 <strong>L2 缓存</strong> 来存储并管理各个任务之间通信的数据。</p><p>![The logical pipeline](&#x2F;images&#x2F;Rendering Blogs&#x2F;Profile&#x2F;GPU Logic.assets&#x2F;fermipipeline_raster.png)</p></li><li><p>现在到了令人兴奋的部分，我们的三角形即将被分解，并可能会离开当前所在的 <strong>GPC（图形处理簇）</strong>。三角形的 <strong>bounding box</strong> 被用来决定哪些**光栅引擎（raster engines）**需要对其进行处理，因为每个光栅引擎负责屏幕上的多个 <strong>tile（瓦片）</strong>。 随后，三角形通过 <strong>Work Distribution Crossbar</strong> 被发送到一个或多个 GPC。此时，我们有效地将三角形分解成许多更小的任务进行处理。</p></li><li><p>在目标 <strong>SM</strong> 内的 <strong>Attribute Setup（属性设置）</strong> 阶段，会确保插值数据（例如在顶点着色器中生成的输出数据）被转换为适合像素着色器的格式。</p></li><li><p><strong>GPC（图形处理簇）</strong> 的 <strong>Raster Engine</strong> 会处理其接收到的三角形，为其负责的区域生成像素信息，并执行背面剔除和深度剔除操作。</p></li><li><p>接着，我们将像素处理任务按 32 个线程（即 8 组 <strong>2x2 像素块</strong>，quad）进行批处理。这种 <strong>2x2 像素块</strong> 是像素着色器的最小处理单位。这种划分方式允许我们计算一些导数，例如用于纹理的 MIP 映射过滤（当像素块内的纹理坐标变化剧烈时，选择更高层级的 MIP）。对于那些 2x2 像素块中采样位置并未实际覆盖三角形的线程，将会被屏蔽（例如通过 <strong>gl_HelperInvocation</strong>）。然后，像素着色任务将交由本地 SM 的某个 Warp 调度器进行管理。</p></li><li><p>像素着色线程在 <strong>Warp 调度器</strong> 中执行的调度逻辑，与顶点着色器阶段的类似。线程仍然以锁步（<strong>lock-step</strong>）方式运行，这种方式特别有用，因为它可以高效访问 <strong>像素块</strong> 内的数值（几乎零成本），因为所有线程的数据都保证在同一指令点完成计算（通过扩展如 <strong>NV_shader_thread_group</strong> 实现）</p><p>![The logical pipeline](&#x2F;images&#x2F;Rendering Blogs&#x2F;Profile&#x2F;GPU Logic.assets&#x2F;fermipipeline_end.png)</p></li><li><p>我们完成了吗？快了！</p><p>像素着色器已经完成了颜色的计算，并生成了需要写入 Render Targets 的深度值。在将这些数据交给 <strong>ROP（Render Output Unit）</strong> 子系统之前，我们需要考虑三角形的原始 API 排序（像 <code>gl_PrimitiveID</code> ?）。这是因为 <strong>ROP 子系统</strong> 本身包含多个 ROP 单元，在其中执行深度测试、与 Framebuffer 的 Blending 等任务。</p><p>这些操作必须是原子性的（<strong>Atomic</strong>，一次只能处理一组颜色和深度值），以确保当两个三角形覆盖同一个像素时，不会出现一个三角形的颜色与另一个三角形的深度值相结合的情况。</p><p>此外，NVIDIA 通常会应用内存压缩技术（<strong>Memory Compression</strong>）来降低对内存带宽的需求，从而提升“有效”带宽（详见 GTX 980 的 PDF 文档）。</p></li></ol><p>终于完成了！</p><p>我们已经成功将像素写入到渲染目标中。希望这部分信息能帮助您了解 GPU 内部的工作流和数据流。同时，这也可以帮助您理解为何与 CPU 的同步操作会对性能造成如此大的影响。</p><p>当 GPU 必须等待所有任务完成且没有新的工作提交时，所有硬件单元都会变为闲置状态（<strong>Idle</strong>）。当发送新的工作任务时，整个 GPU 从完全闲置状态到再次完全负载需要一些时间，尤其是对于那些规模较大的 GPU。</p><p>在下面的图片中，您可以看到一个 CAD 模型的渲染结果，其中不同的颜色表示了对图像贡献的不同 <strong>SM（流式多处理器）</strong> 或 <strong>Warp ID</strong>。需要注意，这种结果通常是帧间不一致的（<strong>Frame-Coherent</strong>），因为工作分配会在每一帧之间有所变化。这幅场景使用了许多 <strong>Draw Calls</strong> 渲染完成，其中一些可能是并行处理的（通过 <strong>NSIGHT</strong> 工具可以观察到这种 <strong>Draw Call</strong> 的并行性）。</p><p>![The logical pipeline](&#x2F;images&#x2F;Rendering Blogs&#x2F;Profile&#x2F;GPU Logic.assets&#x2F;fermipipeline_distribution.png)</p><h1 id="2-The-Peak-Performance-Percentage-Analysis-Method-for-Optimizing-Any-GPU-Workload"><a href="#2-The-Peak-Performance-Percentage-Analysis-Method-for-Optimizing-Any-GPU-Workload" class="headerlink" title="2 The Peak-Performance-Percentage Analysis Method for Optimizing Any GPU Workload"></a>2 The Peak-Performance-Percentage Analysis Method for Optimizing Any GPU Workload</h1><p>这篇博客介绍基于硬件指标 (hardware metrics) 的性能分析方法，帮助我们了解整个GPU的使用情况，哪些硬件单元或子单元限制了性能，以及它们的运行效率多大程度接近各自的最大吞吐量 (maximum throughput，也成为 Speed of Light <strong>SOL</strong>)。假设应用程序没有使用异步计算或异步复制队列，那么这种硬件为中心的信息可以映射回图形 API 和着色器的操作，进而为提升任何给定工作负载的 GPU 性能提供指导，如图 1 所示： </p><img src="/images/Rendering Blogs/Profile/GPU Logic.assets/pasted-image-0-8-1024x246.png" alt="GPU performance data flow" style="zoom: 80%;"><ul><li>如果没有任何 GPU 单元的吞吐量接近其最大吞吐量（SOL），那么我们会努力提高至少一个单元的实际吞吐量。</li><li>如果某个 GPU 单元的吞吐量已经接近其最大吞吐量（SOL），那么我们会找出如何从该单元中移除部分工作负载。</li></ul><p>这些硬件metrics可以使用 Nsight Graphics 的 range profiler 捕获。</p><h2 id="2-1-step1-Capturing-a-Frame-with-Nsight-Graphics"><a href="#2-1-step1-Capturing-a-Frame-with-Nsight-Graphics" class="headerlink" title="2.1 step1: Capturing a Frame with Nsight Graphics"></a>2.1 step1: Capturing a Frame with Nsight Graphics</h2><h2 id="2-2-step-2-Breaking-Down-the-GPU-Frame-Time"><a href="#2-2-step-2-Breaking-Down-the-GPU-Frame-Time" class="headerlink" title="2.2 step 2: Breaking Down the GPU Frame Time"></a>2.2 step 2: Breaking Down the GPU Frame Time</h2><h2 id="2-3-step-3-Profiling-a-GPU-Workload"><a href="#2-3-step-3-Profiling-a-GPU-Workload" class="headerlink" title="2.3 step 3: Profiling a GPU Workload"></a>2.3 step 3: Profiling a GPU Workload</h2><h2 id="2-4-step-4-Inspecting-the-Top-SOLs-Cache-Hit-Rates"><a href="#2-4-step-4-Inspecting-the-Top-SOLs-Cache-Hit-Rates" class="headerlink" title="2.4 step 4: Inspecting the Top SOLs &amp; Cache Hit Rates"></a>2.4 step 4: Inspecting the Top SOLs &amp; Cache Hit Rates</h2><h3 id="2-4-1-The-Per-Unit-SOL-Metrics"><a href="#2-4-1-The-Per-Unit-SOL-Metrics" class="headerlink" title="2.4.1 The Per-Unit SOL% Metrics"></a>2.4.1 The Per-Unit SOL% Metrics</h3><p>在分析工作负载时，首先要关注的是GPU每个单元的SOL%，可以理解为实际吞吐量与理论吞吐量的比值。然而，对于具有多个子单元或并行数据路径的单元，SOL% 表示所有子单元和数据路径的子 SOL 指标中的最大值。GPU 各个单元有：</p><ul><li>PD (Primitive Distributor)：加载 index-buffer，并分发图元到芯片各处（GPC，Graphics Processing Cluster）</li><li>VAF (Vertex Attribute Fetch)：在vertex shader启动前，加载 vertex-buffer</li><li>SM (Streaming Multiprocessor)：执行 shader</li><li>TEX：执行 SRV (shader resource view) 提取操作，以及 UAV (unordered access view，读写) 访问</li><li>VPC (Viewport Culling)：负责视口变换、视锥剔除以及属性的透视矫正</li><li>L2：每个 VRAM 分区附带的二级缓存</li><li>CROP：负责对渲染目标进行颜色写入和混合操作</li><li>ZROP：负责深度和模板测试</li><li>VRAM：GPU 显存</li></ul><p>现代 GPU 并不是一个简单的线性流水线（A→B→C→……），而是由互联单元组成的网络（如 SM↔TEX↔L2，SM→CROP↔L2 等）。简单的“瓶颈”计算方法（基于每个单元的固定上下游接口）不足以全面分析 GPU 性能。因此，在进行性能分析时，我们主要关注每个单元的 SOL% 指标，以确定限制性能的单元和&#x2F;或问题。下一部分将详细讨论这一方法。</p><h3 id="2-4-2-The-“Top-SOL-Units”"><a href="#2-4-2-The-“Top-SOL-Units”" class="headerlink" title="2.4.2 The “Top SOL Units”"></a>2.4.2 The “Top SOL Units”</h3><p>先从 TOP-5 SOL 入手</p><h4 id="2-4-2-1-最高-SOL-80"><a href="#2-4-2-1-最高-SOL-80" class="headerlink" title="2.4.2.1 最高 SOL% &gt; 80%"></a>2.4.2.1 最高 SOL% &gt; 80%</h4><p>如果最高 SOL% 大于 80%，这表明对应工作负载在 GPU 上运行得非常高效（接近最大吞吐量）。要进一步提高速度，可以尝试减少最高 SOL 单元的工作量，或者将其部分任务转移到其他单元。例如：</p><ul><li>如果TOP SOL 单元是 SM，且 SOL% &gt; 80%，可以尝试优化掉一些指令组，或将某些计算转换为lookup table。</li><li>对于受到纹理吞吐量限制的工作负载 (因为结构化缓冲区通过 TEX 单元加载)，可以考虑将 structured buffer 的加载转移为 constant buffer 加载 <a href="#%5B4%5D">[4]</a>，尤其是当着色器对 structured buffer 的访问是统一(uniformly)的 (所有线程从同一地址加载数据时)</li></ul><h4 id="2-4-2-2-最高-SOL-60"><a href="#2-4-2-2-最高-SOL-60" class="headerlink" title="2.4.2.2 最高 SOL% &lt; 60%"></a>2.4.2.2 最高 SOL% &lt; 60%</h4><p>如果最高 SOL% 小于 60%，这表明最高 SOL 单元以及所有 SOL% 更低的 GPU 单元存在以下问题：</p><ul><li><strong>利用率不足</strong>（空闲周期较多）</li><li><strong>运行效率低下</strong>（阻塞周期较多）</li><li><strong>未充分利用快速路径</strong>，原因在于分配的工作负载特性</li></ul><p>以下是一些具体的例子：</p><ul><li><strong>应用程序部分受到 CPU 限制</strong>（见第 5.1.1 节）。</li><li><strong>大量的 <code>Wait For Idle</code> 命令或graphics与compute模式频繁切换</strong>，导致 GPU 管道反复清空（见第 5.1.2 节）。</li><li><strong>TEX 从某些纹理对象提取数据</strong>，由于其格式、维度或过滤模式的设计限制，运行吞吐量降低。例如，当trilinear采样 3D 纹理时，TEX SOL% 为 50% 是正常的</li><li>内存子系统效率低下，包括：<ul><li>TEX 或 L2 单元的缓存命中率较低</li><li>稀疏的 VRAM 访问导致 VRAM SOL% 偏低</li><li>VB（顶点缓冲区）、IB（索引缓冲区）、CB（常量缓冲区）或 TEX（纹理）从系统内存而非 GPU VRAM 获取数据</li></ul></li><li><strong>输入装配阶段</strong>提取 32 位索引缓冲区（与 16 位索引相比，效率减半）</li></ul><p>注意：在这种情况下，我们可以使用最高 SOL% 值来估算通过减少低效因素所能达到的性能提升上限。例如，如果某工作负载的 SOL 当前为 50%，假设通过优化内部低效可以将 SOL 提高到 90%，则该工作负载的最大性能增益为 90&#x2F;50 &#x3D; 1.8 倍 &#x3D; 80%。</p><h4 id="2-4-2-3-最高-SOL-位于-60-80"><a href="#2-4-2-3-最高-SOL-位于-60-80" class="headerlink" title="2.4.2.3 最高 SOL% 位于 [60%, 80%]"></a>2.4.2.3 最高 SOL% 位于 [60%, 80%]</h4><p>这种情况需要结合以上两种情况分析。</p><h3 id="2-4-3-Secondary-SOL-Units-and-TEX-L2-Hit-Rates"><a href="#2-4-3-Secondary-SOL-Units-and-TEX-L2-Hit-Rates" class="headerlink" title="2.4.3 Secondary SOL Units and TEX &amp; L2 Hit Rates"></a>2.4.3 Secondary SOL Units and TEX &amp; L2 Hit Rates</h3><p>Nsight Range Profiler 报告前 5 个最高 SOL 单元而不仅仅是最高的一个，原因在于多个硬件单元可能会相互影响，并在一定程度上共同限制性能。因此，我们建议根据 SOL% 值手动对 SOL 单元进行聚类。<br>（在实践中，10% 的差距通常是定义这些聚类的合理范围，但为了不遗漏任何问题，建议手动完成聚类分析。）</p><p>我们还建议查看 <strong>TEX（L1 缓存）和 L2 缓存的命中率</strong>，这些数据可以在 Range Profiler 的“Memory”部分中找到。一般来说：</p><ul><li>命中率大于 90% 表示很好</li><li>70% ~90% 表示较好</li><li>而低于 70% 则较差（可能会显著限制性能）。</li></ul><h4 id="2-4-3-1-示例1：full-screen-HBAO-blur"><a href="#2-4-3-1-示例1：full-screen-HBAO-blur" class="headerlink" title="2.4.3.1 示例1：full-screen HBAO+ blur"></a>2.4.3.1 示例1：full-screen HBAO+ blur</h4><p>full-screen HBAO+ blur 的 top 5 SOL 单元：</p><table><thead><tr><th>SM:94.5%</th><th>TEX:94.5%</th><th>L2:37.3%</th><th>CROP:35.9%</th><th>VRAM:27.7%</th></tr></thead></table><p>注意，这个工作负载同时受到 <strong>SM</strong> 和 <strong>TEX</strong> 的限制。由于 SM 和 TEX 的 SOL% 值完全相同，可以推测 SM 的性能可能受到 SM 和 TEX 单元之间接口吞吐量的限制（可能是 SM 向 TEX 的请求，或者 TEX 返回数据到 SM 的过程）。</p><p>该工作负载的 <strong>TEX 缓存命中率为 88.9%</strong>，<strong>L2 缓存命中率为 87.3%</strong>。<br>有关此工作负载的详细分析，请参考附录 “<a href="https://developer.nvidia.com/blog/the-peak-performance-analysis-method-for-optimizing-any-gpu-workload/#example1">TEX-Interface Limited Workload</a>”</p><h4 id="2-4-3-2-示例2：SSR"><a href="#2-4-3-2-示例2：SSR" class="headerlink" title="2.4.3.2 示例2：SSR"></a>2.4.3.2 示例2：SSR</h4><table><thead><tr><th>SM:49.1%</th><th>L2:36.8%</th><th>TEX:35.8%</th><th>VRAM:33.5%</th><th>CROP:0.0%</th></tr></thead></table><p>在这个工作负载中，<strong>SM 是主要瓶颈</strong>，而 <strong>L2</strong>、<strong>TEX</strong> 和 <strong>VRAM</strong> 是次要限制因素。<strong>TEX 缓存命中率为 54.6%</strong>，<strong>L2 缓存命中率为 76.4%</strong>。<br>较低的 TEX 命中率可以解释 SM 的低 SOL% 值：由于 TEX 命中率较低（很可能是因为相邻像素访问了相距较远的纹素），SM 观察到的平均 TEX 延迟高于正常值，且更难以掩盖延迟。</p><p>注意：在这种情况下，活跃单元实际上构成了一条依赖链：<strong>SM -&gt; TEX -&gt; L2 -&gt; VRAM</strong>。</p><h4 id="2-4-3-3-示例3：tiled-lighting-compute-shader"><a href="#2-4-3-3-示例3：tiled-lighting-compute-shader" class="headerlink" title="2.4.3.3 示例3：tiled-lighting compute shader"></a>2.4.3.3 示例3：tiled-lighting compute shader</h4><table><thead><tr><th>SM:70.4%</th><th>L2:67.5%</th><th>TEX:49.3%</th><th>VRAM:42.6%</th><th>CROP:0.0%</th></tr></thead></table><p>这个工作负载中，<strong>SM 和 L2 是主要限制因素</strong>，而 <strong>TEX 和 VRAM 是次要限制因素</strong>。<strong>TEX 缓存命中率为 64.3%</strong>，<strong>L2 缓存命中率为 85.2%</strong>。</p><h4 id="2-4-3-4-示例4：shadow-map-generation"><a href="#2-4-3-4-示例4：shadow-map-generation" class="headerlink" title="2.4.3.4 示例4：shadow-map generation"></a>2.4.3.4 示例4：shadow-map generation</h4><table><thead><tr><th>PD:31.6%</th><th>VRAM:19.8%</th><th>VPC:19.4%</th><th>L2:16.3%</th><th>VAF:12.4%</th></tr></thead></table><p>这个工作负载受到 <strong>PD（图元分发器）</strong> 的限制，且最高 SOL% 较低。在这种情况下，将索引缓冲区的格式从 32 位更改为 16 位显著提升了性能。<br>由于 TEX 并未出现在前 5 个 SOL 单元中，因此 TEX 命中率无关紧要。而 <strong>L2 缓存命中率为 62.6%</strong>。</p><h2 id="2-5-step-5-Understand-the-Performance-Limiters"><a href="#2-5-step-5-Understand-the-Performance-Limiters" class="headerlink" title="2.5 step 5: Understand the Performance Limiters"></a>2.5 step 5: Understand the Performance Limiters</h2><p>我们现在需要了解是什么限制了这些top-SOL单元的性能。</p><h3 id="2-5-1-If-the-Top-SOL-is-Low"><a href="#2-5-1-If-the-Top-SOL-is-Low" class="headerlink" title="2.5.1 If the Top SOL% is Low"></a>2.5.1 If the Top SOL% is Low</h3><p>一个工作负载可能同时受到多种病理问题的影响。下面检查以下指标的值：<strong>“Graphics&#x2F;Compute Idle%”</strong> 和 <strong>“SM Active %”</strong>。</p><h4 id="2-5-1-1-The-“Graphics-Compute-Idle-”-metric"><a href="#2-5-1-1-The-“Graphics-Compute-Idle-”-metric" class="headerlink" title="2.5.1.1 The “Graphics&#x2F;Compute Idle%” metric"></a>2.5.1.1 The “Graphics&#x2F;Compute Idle%” metric</h4><p><strong>“Graphics&#x2F;Compute Idle%”</strong> 是指在当前工作负载中，整个图形与计算硬件管线完全空闲的 GPU 总运行周期百分比。这些周期表示图形&#x2F;计算管线为空的时间，可能是因为以下原因之一：</p><ol><li><strong>CPU 无法足够快地向 GPU 提供指令</strong>。</li><li>应用程序正在使用同步 Copy Engine（这可能发生在 DIRECT 队列或即时上下文中调用 Copy 操作时）。</li></ol><p>**注意：**由于 <code>Wait For Idle</code> 命令导致的管线清空不计入 “Graphics&#x2F;Compute Idle”</p><p>在这种情况下，我们建议测量每个工作负载中以下 CPU 调用所消耗的总 CPU 时间，并尝试优化最耗时的部分：</p><ul><li>对于 DX11<ul><li><code>Flush&#123;,1&#125;</code></li><li><code>Map</code></li><li><code>UpdateSubresource&#123;,1&#125;</code></li></ul></li><li>对于 DX12：<ul><li><code>Wait</code></li><li><code>ExecuteCommandLists</code></li></ul></li><li>适用于 DX11 和 DX12：所有的 <code>Create</code> 或 <code>Release</code> 调用</li></ul><p>DX11 注意事项：</p><ol><li><strong><code>ID3D11DeviceContext::Flush</code></strong><ul><li>调用 <code>Flush</code> 强制启动命令缓冲区，可能导致 CPU 等待。</li></ul></li><li><strong><code>ID3D11DeviceContext::Map</code>（针对 STAGING 资源）</strong><ul><li>如果连续帧中映射了相同的 STAGING 资源，可能因资源争用导致 CPU 阻塞。在这种情况下，当前帧的 <code>Map</code> 调用必须等待之前帧的处理完成。</li></ul></li><li><strong><code>ID3D11DeviceContext::Map</code>（使用 DX11_MAP_WRITE_DISCARD）</strong><ul><li>如果驱动程序耗尽了版本化空间（versioning space），<code>Map</code> 调用可能导致 CPU 阻塞。因为每次 <code>Map(WRITE_DISCARD)</code> 调用都会从固定大小的内存池返回一个新指针。当内存池耗尽时，<code>Map</code> 调用会等待。</li></ul></li></ol><p>DX12 注意事项：</p><ol><li><strong><code>ExecuteCommandLists</code>（ECL）调用</strong><ul><li>每次 <code>ECL</code> 调用都存在一些与启动新命令缓冲区相关的 GPU 空闲开销。</li><li>为减少 GPU 空闲时间，建议将所有命令列表批处理为尽可能少的 <code>ECL</code> 调用，除非需要在帧的某些点强制启动命令缓冲区（例如，在 VR 应用中减少输入延迟，保持单帧在飞行状态时）。</li></ul></li><li><strong><code>ID3D12CommandQueue::Wait</code> 调用</strong><ul><li>当应用调用 <code>Wait</code> 等待某个栅栏时，操作系统（Windows 10）会暂停向该命令队列提交新命令缓冲区，直到 <code>Wait</code> 调用返回。</li></ul></li></ol><p>**注意：**通过 Nsight 可以测量每个 API 调用的 CPU 和 GPU 时间，这些数据会在每次启动 Range Profiler 时显示在 API 统计视图中。</p><h4 id="2-5-1-2-The-“SM-Active-”-metric"><a href="#2-5-1-2-The-“SM-Active-”-metric" class="headerlink" title="2.5.1.2 The “SM Active%” metric"></a>2.5.1.2 The “SM Active%” metric</h4><h4 id="2-5-1-3-GPU-Trace"><a href="#2-5-1-3-GPU-Trace" class="headerlink" title="2.5.1.3 GPU Trace"></a>2.5.1.3 GPU Trace</h4><h3 id="2-5-2-If-the-Top-SOL-Unit-is-the-SM"><a href="#2-5-2-If-the-Top-SOL-Unit-is-the-SM" class="headerlink" title="2.5.2 If the Top SOL Unit is the SM"></a>2.5.2 If the Top SOL Unit is the SM</h3><h4 id="2-5-2-1-Case-1-“SM-Throughput-For-Active-Cycles”-80"><a href="#2-5-2-1-Case-1-“SM-Throughput-For-Active-Cycles”-80" class="headerlink" title="2.5.2.1 Case 1: “SM Throughput For Active Cycles” &gt; 80%"></a>2.5.2.1 Case 1: “SM Throughput For Active Cycles” &gt; 80%</h4><h4 id="2-5-2-2-Case-2-“SM-Throughput-For-Active-Cycles”-60"><a href="#2-5-2-2-Case-2-“SM-Throughput-For-Active-Cycles”-60" class="headerlink" title="2.5.2.2 Case 2: “SM Throughput For Active Cycles” &lt; 60%"></a>2.5.2.2 Case 2: “SM Throughput For Active Cycles” &lt; 60%</h4><h4 id="2-5-2-3-Case-3-SM-Throughput-For-Active-Cycles-in-60-80"><a href="#2-5-2-3-Case-3-SM-Throughput-For-Active-Cycles-in-60-80" class="headerlink" title="2.5.2.3 Case 3: SM Throughput For Active Cycles % in [60,80]"></a>2.5.2.3 Case 3: SM Throughput For Active Cycles % in [60,80]</h4><h3 id="2-5-3-If-the-Top-SOL-unit-is-not-the-SM"><a href="#2-5-3-If-the-Top-SOL-unit-is-not-the-SM" class="headerlink" title="2.5.3 If the Top SOL unit is not the SM"></a>2.5.3 If the Top SOL unit is not the SM</h3><h4 id="2-5-3-1-If-the-Top-SOL-unit-is-TEX-L2-or-VRAM"><a href="#2-5-3-1-If-the-Top-SOL-unit-is-TEX-L2-or-VRAM" class="headerlink" title="2.5.3.1 If the Top SOL unit is TEX, L2, or VRAM"></a>2.5.3.1 If the Top SOL unit is TEX, L2, or VRAM</h4><h4 id="2-5-3-2-If-the-Top-SOL-unit-is-CROP-or-ZROP"><a href="#2-5-3-2-If-the-Top-SOL-unit-is-CROP-or-ZROP" class="headerlink" title="2.5.3.2 If the Top SOL unit is CROP or ZROP"></a>2.5.3.2 If the Top SOL unit is CROP or ZROP</h4><h4 id="2-5-3-3-If-the-Top-SOL-unit-is-PD"><a href="#2-5-3-3-If-the-Top-SOL-unit-is-PD" class="headerlink" title="2.5.3.3 If the Top SOL unit is PD"></a>2.5.3.3 If the Top SOL unit is PD</h4><h4 id="2-5-3-4-If-the-Top-SOL-unit-is-VAF"><a href="#2-5-3-4-If-the-Top-SOL-unit-is-VAF" class="headerlink" title="2.5.3.4 If the Top SOL unit is VAF"></a>2.5.3.4 If the Top SOL unit is VAF</h4><h1 id="3-Optimizing-VK-VKR-and-DX12-DXR-Applications-Using-Nsight-Graphics-GPU-Trace-Advanced-Mode-Metrics"><a href="#3-Optimizing-VK-VKR-and-DX12-DXR-Applications-Using-Nsight-Graphics-GPU-Trace-Advanced-Mode-Metrics" class="headerlink" title="3 Optimizing VK&#x2F;VKR and DX12&#x2F;DXR Applications Using Nsight Graphics: GPU Trace Advanced Mode Metrics"></a>3 Optimizing VK&#x2F;VKR and DX12&#x2F;DXR Applications Using Nsight Graphics: GPU Trace Advanced Mode Metrics</h1><h2 id="3-1-Capturing-GPU-Trace-data-with-Advanced-Mode-Metrics"><a href="#3-1-Capturing-GPU-Trace-data-with-Advanced-Mode-Metrics" class="headerlink" title="3.1 Capturing GPU Trace data with Advanced Mode Metrics"></a>3.1 Capturing GPU Trace data with Advanced Mode Metrics</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a name="[1]">[1]</a> <a href="https://developer.nvidia.com/content/life-triangle-nvidias-logical-pipeline">https://developer.nvidia.com/content/life-triangle-nvidias-logical-pipeline</a></p><p><a name="[2]">[2]</a> <a href="https://developer.nvidia.com/blog/the-peak-performance-analysis-method-for-optimizing-any-gpu-workload/">https://developer.nvidia.com/blog/the-peak-performance-analysis-method-for-optimizing-any-gpu-workload/</a></p><p><a name="[3]">[3]</a> <a href="https://developer.nvidia.com/blog/optimizing-vk-vkr-and-dx12-dxr-applications-using-nsight-graphics-gpu-trace-advanced-mode-metrics/">https://developer.nvidia.com/blog/optimizing-vk-vkr-and-dx12-dxr-applications-using-nsight-graphics-gpu-trace-advanced-mode-metrics/</a></p><p><a name="[4]">[4]</a> [Structured Buffer Performance](.&#x2F;Structured Buffer Performance.md)</p>]]></content>
    
    
    <categories>
      
      <category>Rendering Blogs</category>
      
      <category>Profile</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Disney BRDF</title>
    <link href="/2024/10/14/Rendering%20Blogs/Graphics%20Basis/Disney%20Principled%20BRDF/"/>
    <url>/2024/10/14/Rendering%20Blogs/Graphics%20Basis/Disney%20Principled%20BRDF/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Summary"><a href="#1-Summary" class="headerlink" title="1 Summary"></a>1 Summary</h1><p>Disney Principled BRDF 是迪士尼动画工作室在 SIGGRAPH 2012 的 Physically-based shading at Disney <a href="#%5B1%5D">[1]</a> 提出。该工作室通过分析 <strong>MERL</strong> BRDF 材质库，总结出对 microfacet Cook-Torrance BRDF 的各项的观察，如 diffuse、specular D F G等四项。基于观察结论，进一步改进 Cook-Torrance BRDF 模型，并设计出对艺术家友好的参数集。<a href="#%5B2%5D">[2]</a> 对这项工作总结得很好，目前不再进行赘述，只追加一些自己新的理解。</p><h1 id="2-Cook-Torrance-BRDF-的改进"><a href="#2-Cook-Torrance-BRDF-的改进" class="headerlink" title="2 Cook-Torrance BRDF 的改进"></a>2 Cook-Torrance BRDF 的改进</h1><img src="/images/Rendering Blogs/Graphics Basis/Disney Principled BRDF.assets/image-20211223113437451.png" alt="image-20211223113437451" style="zoom:67%;">$$\begin{align}f(\boldsymbol{l},\boldsymbol{v})= diffuse + \frac{F(\theta_d)\cdot G(\theta_l, \theta_v)\cdot D(\theta_h)}{4\cdot \cos\theta_l\cdot \cos\theta_v}\end{align} \tag{1} \label{Cook-Torrance BRDF}$$<h2 id="2-1-Diffuse"><a href="#2-1-Diffuse" class="headerlink" title="2.1 Diffuse"></a>2.1 Diffuse</h2><h3 id="2-1-1-如何理解漫反射"><a href="#2-1-1-如何理解漫反射" class="headerlink" title="2.1.1 如何理解漫反射"></a>2.1.1 如何理解漫反射</h3><p><strong>中学时期漫反射的解释</strong>：光照射在非常凹凸不平的物体表面，光线向四面八方反射，可近似看成各个角度均匀反射。但对于微表面模型而言，microfacet BRDF 已经将物体表面看作很多个微表面，对于某一特定方向的入射光，反射到观察方向上的比例，这一反射过程相当于考虑到光在微表面上的 Specular 反射，已经解释了中学时期的所谓的漫反射过程。$\eqref{Cook-Torrance BRDF}$ 中着色模型，分成了 diffuse 项与 微表面模型下的 specular 项，如果采用上述粗浅的漫反射理解，相当于 diffuse 项与 specular 项计算的是相同的东西。</p><p><strong>微表面模型下的漫反射的准确理解</strong>：光打到物体表面，进入物体表面以下，发生浅层散射，进行多次反射射 (subsurface scattering) ，期间部分光被吸收，剩下的光离开表面。部分光被吸收带来的 diffuse 响应就是表面颜色，被着色的非金属材质的任意出射部分都可以视为 diffuse，可以得知漫反射过程的出射能量比例收到 Fresnel 的影响。</p><p><strong>观察结论</strong></p><ol><li>grazing retroreflection  情况下，有很明显的着色，即 retroreflective peak。</li><li>出射能量的多少受到 Fresnel 影响，而 roughness 会影响到 Fresnel，因此精准的 diffuse 项需要考虑到 Fresnel 与 roughness。</li><li>粗糙表面的漫反射能量要高于平滑表面的漫反射能量，特别是 grazing retroreflection，粗糙表面出现了一个峰值。</li></ol><h3 id="2-1-2-现有-diffuse-模型的不足"><a href="#2-1-2-现有-diffuse-模型的不足" class="headerlink" title="2.1.2 现有 diffuse 模型的不足"></a>2.1.2 现有 diffuse 模型的不足</h3><ul><li><strong>Lambert Diffuse Model</strong><br>Lambert Diffuse Model 假设折射光进行了充足的散射，最终出射的光在所有方向上均匀分布。在距离一定的情况下，漫反射出射的能量由 $(\boldsymbol{n}\cdot\boldsymbol{l})$ 决定，即入射光与红表面法线的夹角越大，出射能量越小。在材质球上的表现为 grazing 角度会较暗，使得材质球边缘有阴影感，视觉上更加立体化。但通过观察，很少有材质与 Lambert Diffuse Model 表现一致。例如，观察 1 中 grazing retroreflection(接近 90° 角) 着色会变强，而不是 Lambert  模型所说，角度越大，出射能量越小。</li><li><strong>Oren-Nayar Model</strong><br>Oren-Nayar Model 有预测到 retroreflective peak，因此 grazing 角度相较于 Lambert  模型会较亮，边缘不会有阴影感，整个材质球更加平，但其峰值相比于观察数据，不够强。并且对于粗糙材质，颜色表现得过于平。</li><li><strong>Hanrahan-Krueger Model</strong><br>Hanrahan-Krueger Model 同样也预测到 retroreflective peak，并且 grazing 角度相较于 Oren-Nayar 模型会更亮，并且其颜色过渡非常平滑。但在观察的数据中，颜色与光强度会在 $\theta_l&#x2F;\theta_v$ 等值线上具有变化。</li></ul><h3 id="2-1-3-较为精确的经验模型"><a href="#2-1-3-较为精确的经验模型" class="headerlink" title="2.1.3 较为精确的经验模型"></a>2.1.3 较为精确的经验模型</h3><p>根据观察结论，Disney 开了一种漫反射的经验模型，该模型可以在光滑表面的 Fresnel 阴影与粗糙表面的亮度增加之间过渡。并且该模型的 Fresnel Factor 采用了一种遵循 Helmholtz  reciprocity 性质的形式，即互换入射与出射(观察)方向，结果不变。此外 Fresnel Factor 采用 Schlick 近似，即入射角为 $\theta$ 的 Fresnel 反射率：<br>$$<br>F_R \approx F(\theta)&#x3D;F_0+(1-F_0)(1-\cos\theta)^5<br>$$<br> 其中 $F_0$ 与折射前后的介质的折射率有关，$F_0&#x3D;\left(\frac{\eta_1-\eta_2}{\eta_1+\eta_2}\right)^2$ 。</p><p>Disney 的diffuse 经验模型为：<br>$$<br>f_d &#x3D; \frac{baseColor}{\pi}\cdot\left(1+(F_{D90}-1)(1-\cos\theta_l)^5\right)\cdot\left(1+(F_{D90}-1)(1-\cos\theta_v)^5\right) \tag{2} \label{Diffuse Model}<br>$$<br>其中，$F_{D90}&#x3D;0.5+2\cdot roughness \cdot \cos^2\theta_d$ ，$\theta_d$ 为入射与出射方向的夹角的一半。可以看出该模型满足互换入射与出射方向，结果相同。从公式中可以看出，越往 grazing retroreflection 偏移，即 $\theta_l$ 与 $\theta_v$ 向 $90$ 偏移，次幂项系数越大，对应了 grazing retroreflection 处的峰值，并且 $F_{D90}$ 与 roughness 相关，越粗糙越大，对应了粗糙表面，漫反射会更亮。</p><p> Disney 对上式的实现代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// [Burley 2012, &quot;Physically-Based Shading at Disney&quot;]</span><br><span class="hljs-function">float3 <span class="hljs-title">Diffuse_Burley_Disney</span><span class="hljs-params">( float3 DiffuseColor, <span class="hljs-type">float</span> Roughness, <span class="hljs-type">float</span> NoV, <span class="hljs-type">float</span> NoL, <span class="hljs-type">float</span> VoH )</span></span>&#123;<br><span class="hljs-type">float</span> FD90 = <span class="hljs-number">0.5</span> + <span class="hljs-number">2</span> * VoH * VoH * Roughness;<br><span class="hljs-type">float</span> FdV = <span class="hljs-number">1</span> + (FD90 - <span class="hljs-number">1</span>) * <span class="hljs-built_in">Pow5</span>( <span class="hljs-number">1</span> - NoV );<br><span class="hljs-type">float</span> FdL = <span class="hljs-number">1</span> + (FD90 - <span class="hljs-number">1</span>) * <span class="hljs-built_in">Pow5</span>( <span class="hljs-number">1</span> - NoL );<br><span class="hljs-keyword">return</span> DiffuseColor * ( (<span class="hljs-number">1</span> / PI) * FdV * FdL );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-Specular-D"><a href="#2-2-Specular-D" class="headerlink" title="2.2 Specular D"></a>2.2 Specular D</h2><p>当前的微表面法线分布函数的 specular lobe 不够长，GGX 具有比其他法线分布函数更长的尾部，但仍然无法捕捉到 chrome sample 中高光附近的余晖。如下图所示</p><img src="/images/Rendering Blogs/Graphics Basis/Disney Principled BRDF.assets/image-20211229135245256.png" alt="image-20211229135245256" style="zoom: 50%;"><center>左图为 chrome(黑)、GGX(红)、Benckmann(绿) 的镜面反射随 $\theta_h$ 变化的曲线；    右图分别为 chrome、GGX、Beckmann 对点光源的响应 </center><p>在流行的模型中，GGX(Trowbridge-Reitz) 具有最长的尾部，但很多材质需要更长的尾部。</p><h3 id="2-2-1-GTR-分布函数"><a href="#2-2-1-GTR-分布函数" class="headerlink" title="2.2.1 GTR 分布函数"></a>2.2.1 GTR 分布函数</h3><p>GTR 根据 Berry 和 GGX(TR) 分布函数的相似之处，而推广得到的广义形式。GTR 参数化分母的次幂，调整尾部的长度。Berry、TR 、GTR 微表面法线分布函数的形式如下：<br>$$<br>\begin{align}<br>D_{Berry}&amp;&#x3D;\frac{c}{(\alpha^2\cos^2\theta_h+\sin^2\theta_h)} \<br>D_{TR}&amp;&#x3D;\frac{c}{(\alpha^2\cos^2\theta_h+\sin^2\theta_h)^2} \<br>D_{GTR}&amp;&#x3D;\frac{c}{(\alpha^2\cos^2\theta_h+\sin^2\theta_h)^\gamma}<br>\end{align}<br>$$<br>其中，$c$ 为缩放常数；$\alpha$ 为 roughness；$\theta_h$ 为入射方向与观察方向的 half vector，与法线该 half vector 一致的微表面才可能将入射光反射到观察方向，因此分布函数得到这个方向上的微表面法线的重要程度，从而知道宏表面的微表面集合有多少比例可以贡献到观察方向上；$\gamma$ 可以调整 BRDF lobe 的长度，越大越长，如下图所示</p><img src="/images/Rendering Blogs/Graphics Basis/Disney Principled BRDF.assets/image-20211229151526527.png" alt="image-20211229151526527" style="zoom: 50%;"><p>Disney 设计的 BRDF 具有两个 GTR BRDF lobe：</p><ul><li>Primary lobe：$\gamma &#x3D; 2$，表示基础底材质，可以是各向同性&#x2F;各向异性的金属或非金属。</li><li>Secondary lobe：$\gamma &#x3D; 1$，表示基础材质层上的 clearcoat layer(清漆层)，一般为各向同性的非金属。</li></ul><p>友好的参数调控交互处理：</p><ul><li>重新定义公式中的 $\alpha$：$\alpha &#x3D; roughness^2$ 的变化更加线性，因此 UI 调参时，调整的是 $\alpha^{1&#x2F;2}$。</li><li></li></ul><p>各向同性的 GTR 代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Generalized-Trowbridge-Reitz distribution</span><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">D_GTR1</span><span class="hljs-params">(<span class="hljs-type">float</span> alpha, <span class="hljs-type">float</span> dotNH)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> a2 = alpha * alpha;<br>    <span class="hljs-type">float</span> cos2th = dotNH * dotNH;<br>    <span class="hljs-type">float</span> den = (<span class="hljs-number">1.0</span> + (a2 - <span class="hljs-number">1.0</span>) * cos2th);<br><br>    <span class="hljs-keyword">return</span> (a2 - <span class="hljs-number">1.0</span>) / (PI * <span class="hljs-built_in">log</span>(a2) * den);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">D_GTR2</span><span class="hljs-params">(<span class="hljs-type">float</span> alpha, <span class="hljs-type">float</span> dotNH)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> a2 = alpha * alpha;<br>    <span class="hljs-type">float</span> cos2th = dotNH * dotNH;<br>    <span class="hljs-type">float</span> den = (<span class="hljs-number">1.0</span> + (a2 - <span class="hljs-number">1.0</span>) * cos2th);<br><br>    <span class="hljs-keyword">return</span> a2 / (PI * den * den);<br>&#125;<br></code></pre></td></tr></table></figure><p>各向异性的 GTR 代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">D_GTR2_aniso</span><span class="hljs-params">(<span class="hljs-type">float</span> dotHX, <span class="hljs-type">float</span> dotHY, <span class="hljs-type">float</span> dotNH, <span class="hljs-type">float</span> ax, <span class="hljs-type">float</span> ay)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> deno = dotHX * dotHX / (ax * ax) + dotHY * dotHY / (ay * ay) + dotNH * dotNH;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / (PI * ax * ay * deno * deno);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-2-Specular-F"><a href="#2-2-2-Specular-F" class="headerlink" title="2.2.2 Specular F"></a>2.2.2 Specular F</h3><p>Disney 直接使用 Schlick 近似代替 Fresnel equation：<br>$$<br>F_{Schlick}&#x3D;F_0+(1-F_0)(1-\cos\theta_d)^5<br>$$<br> 其中，常数 $F_0$ 表示垂直入射时的镜面反射率，$\theta_d$ 表示入射光与微表面法线(入射方向与观察方向的 half vector)的夹角。</p><p>Schlick Fresnel 的 shader 代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// [Schlick 1994, &quot;An Inexpensive BRDF Model for Physically-Based Rendering&quot;]</span><br><span class="hljs-function">float3 <span class="hljs-title">F_Schlick</span><span class="hljs-params">(<span class="hljs-type">float</span> HdotV, float3 F0)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> F0 + (<span class="hljs-number">1</span> - F0) * <span class="hljs-built_in">pow</span>(<span class="hljs-number">1</span> - HdotV , <span class="hljs-number">5.0</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，Disney 在 SIGGRAPH 2015 提出在介质间相对IOR接近1时，Schlick近似误差较大，这时采用精确的菲涅尔方程。</p><h2 id="2-3-Specular-G"><a href="#2-3-Specular-G" class="headerlink" title="2.3 Specular G"></a>2.3 Specular G</h2><h2 id="参数设计"><a href="#参数设计" class="headerlink" title="参数设计"></a>参数设计</h2><ul><li><p>baseColor：表面颜色，通常由纹理贴图提供。</p></li><li><p>subsurface（次表面）：漫反射向次表面散射的靠拢程度。</p></li><li><p>metallic（金属度）：0 &#x3D; 电介质（绝缘体），1 &#x3D;金属。这是两种不同模型之间的线性混合。金属模型没有漫反射成分，并且还具有等于基础色的着色入射镜面反射。</p></li><li><p>specular（镜面反射强度）：入射镜面反射量。用于取代折射率。</p></li><li><p>specularTint（镜面反射颜色）：对美术控制的让步，用于对基础色（basecolor）的入射镜面反射进行颜色控制。掠射镜面反射仍然是非彩色的。</p></li><li><p>roughness（粗糙度）：表面粗糙度，控制漫反射和镜面反射。</p></li><li><p>anisotropic（各向异性强度）：各向异性程度。用于控制镜面反射高光的纵横比。（0 &#x3D;各向同性，1 &#x3D;最大各向异性。）</p></li><li><p>sheen（光泽度）：一种额外的掠射分量（grazing component），主要用于布料。</p></li><li><p>sheenTint（光泽颜色）：对sheen（光泽度）的颜色控制。</p></li><li><p>clearcoat（清漆强度）：有特殊用途的第二个镜面波瓣（specular lobe）。</p></li><li><p>clearcoatGloss（清漆光泽度）：控制透明涂层光泽度，0 &#x3D; “缎面（satin）”外观，1 &#x3D; “光泽（gloss）”外观。</p></li></ul><p>以上参数取值都为 $[0,1]$。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a name="[1]">[1]</a> Burley B, Studios W D A. Physically-based shading at disney[C] ACM SIGGRAPH. 2012, 2012: 1-7.</p><p><a name="[2]">[2]</a> <a href="https://zhuanlan.zhihu.com/p/60977923">https://zhuanlan.zhihu.com/p/60977923</a></p>]]></content>
    
    
    <categories>
      
      <category>Rendering Blogs</category>
      
      <category>Graphics</category>
      
      <category>PBR</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PBR Material</title>
    <link href="/2024/10/14/Rendering%20Blogs/Graphics%20Basis/Real-Time%20Physically%20Based%20Material%20Basics/"/>
    <url>/2024/10/14/Rendering%20Blogs/Graphics%20Basis/Real-Time%20Physically%20Based%20Material%20Basics/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Summary"><a href="#1-Summary" class="headerlink" title="1 Summary"></a>1 Summary</h2><h2 id="2-Microfacet-BRDF"><a href="#2-Microfacet-BRDF" class="headerlink" title="2 Microfacet BRDF"></a>2 Microfacet BRDF</h2><p>微表面模型认为宏观表面的着色区域上分布着很多微表面，不同材质具有不同的微表面法线分布。如集中的微表面法线分布对应 glossy 材质，反之分散的分布对应 diffuse 材质。有如下表面及入射光、视角，</p><img src="/images/Rendering Blogs/Graphics Basis/Real-Time Physically Based Material Basics.assets/image-20211223113437451.png" alt="image-20211223113437451" style="zoom:67%;"><p>入射光方向 $\boldsymbol{l}$、观察方向 $\boldsymbol{v}$、宏观表面法向量 $\boldsymbol{n}$、half vector $\boldsymbol{h}&#x3D;\frac{\boldsymbol{l}+\boldsymbol{v}}{||\boldsymbol{l}+\boldsymbol{v}||}$；$\boldsymbol{l}$ 与 $\boldsymbol{n}$ 夹角为 $\theta_l$，$\boldsymbol{v}$ 与 $\boldsymbol{n}$ 的夹角为 $\theta_v$，$\boldsymbol{h}$ 与 $\boldsymbol{n}$ 的夹角为 $\theta_h$，$\boldsymbol{l}$ 与 $\boldsymbol{h}$ 的夹角等于 $\boldsymbol{v}$ 与 $\boldsymbol{h}$ 的夹角为 $\theta_d$。微表面 BRDF 定义为：<br>$$<br>\begin{align}<br>f(\boldsymbol{l},\boldsymbol{v})&amp;&#x3D;\frac{F(\boldsymbol{l},\boldsymbol{v})\cdot G(\boldsymbol{l},\boldsymbol{v},\boldsymbol{h})\cdot D(\boldsymbol{h})}{4(\boldsymbol{n}\cdot \boldsymbol{l})(\boldsymbol{n}\cdot \boldsymbol{v})} \<br>&amp;&#x3D;\frac{F(\theta_d)\cdot G(\theta_l, \theta_v)\cdot D(\theta_h)}{4\cdot \cos\theta_l\cdot \cos\theta_v}<br>\end{align}<br>$$<br>Microfacet BRDF 有三个重要成分，</p><ul><li>Fresnel term : $F(\theta_d)$，反射率，即给定入射方向，在观察方向上有多少能量会被反射。</li><li>NDF(distribution of normal) : $D(\theta_h)$，微表面的法线分布。</li><li>Shadow-Masking term : $G(\theta_l,\theta_v)$，微表面产生的自遮挡。</li></ul><p>除此之外，分母中的 $4\cdot \cos\theta_l\cdot \cos\theta_v$ 是微表面 BRDF 推导得到。</p><h3 id="2-1-Fresnel-term-Specular-F-1"><a href="#2-1-Fresnel-term-Specular-F-1" class="headerlink" title="2.1 Fresnel term (Specular F) [1]"></a>2.1 Fresnel term (Specular F) <a href="#%5B1%5D">[1]</a></h3><p>入射光在物体表面可能会发生反射、折射或两者都会发生，Fresnel term 则用来描述物体反射或折射入射能量的多少。</p><h4 id="2-1-1-Reflection"><a href="#2-1-1-Reflection" class="headerlink" title="2.1.1 Reflection"></a>2.1.1 Reflection</h4><p>只考虑反射，即入射光打到镜面。如下图所示</p><img src="/images/Rendering Blogs/Graphics Basis/Real-Time Physically Based Material Basics.assets/image-20211224230728118.png" alt="image-20211224230728118" style="zoom:50%;"><p>入射光  $\boldsymbol{l}$、反射光方向 $\boldsymbol{r}$、法线方向 $\boldsymbol{n}$，入射光与法线夹角 $\theta_l$ 、发射光与法线夹角 $\theta_r$， 由反射定律可知 $\theta_l$ 与 $\theta_r$ 相等。已知入射光线、法线，可以求得反射光线：<br>$$<br>\boldsymbol{r}&#x3D;2\cdot (\boldsymbol{n}\cdot \boldsymbol{l}) \boldsymbol{n} - \boldsymbol{l}<br>$$</p><blockquote><p>这个反射公式可以由简单的几何推导得到，$\boldsymbol{l}$  与 $\boldsymbol{r}$ 的夹角被 $\boldsymbol{n}$ 均分，并且由于是方向向量长度都为 1，因此可做菱形</p><img src="/images/Rendering Blogs/Graphics Basis/Real-Time Physically Based Material Basics.assets/image-20211225100712673.png" alt="image-20211225100712673" style="zoom:50%;"><p>其中 $\boldsymbol{n}$ 所在对角线长度为 $2\cdot ||\boldsymbol{l}||\cdot \cos\theta_l&#x3D;2\cdot \cos\theta_l$，对角线向量为 $2\cdot cos\theta_l \cdot \boldsymbol{n}$，因此反射向量<br>$$<br>\boldsymbol{r} &#x3D; 2\cdot \cos\theta_l\cdot \boldsymbol{n} - \boldsymbol{l}&#x3D;2\cdot (\boldsymbol{n}\cdot \boldsymbol{l}) \boldsymbol{n} - \boldsymbol{l}<br>$$<br>如果将入射光方向写为光源指向交点形式，那么反射向量为<br>$$<br>\boldsymbol{r}&#x3D; \boldsymbol{l} - 2\cdot (\boldsymbol{n}\cdot \boldsymbol{l}) \boldsymbol{n}<br>$$</p></blockquote><p>对于单条入射光，只有观察方向与反射方向重合，才能看到反射的入射光与物体交点信息。如波光粼粼的效果</p><p>![image-20211226133750761](&#x2F;images&#x2F;Rendering Blogs&#x2F;Graphics Basis&#x2F;Real-Time Physically Based Material Basics.assets&#x2F;image-20211226133750761.png)</p><h4 id="2-1-2-Refraction-transmission"><a href="#2-1-2-Refraction-transmission" class="headerlink" title="2.1.2 Refraction (transmission)"></a>2.1.2 Refraction (transmission)</h4><p>对于具有透明性质的物体，光接触时会有折射发生，即光会传播至物体内部。折射光的方向与传输介质的折射率有关 (index of refraction、ior)。折射率定义为 $\eta &#x3D; \frac{c}{v}$，其中 $c$ 为光在真空中的传播速度，$v$ 为光在传播介质中的传播速度。</p><p><strong>折射定律 (snell’s law)</strong>：已知入射光 $\boldsymbol{l}$，法线 $\boldsymbol{n}$，入射角 $\theta_1$，光折射前后的传播介质的折射率分别为 $\eta_1$、$\eta_2$，光接触到表面发生折射得到折射角为 $\theta_2$ 的 transmissive ray $\boldsymbol{t}$，有<br>$$<br>\frac{\sin\theta_1}{\sin\theta_2} &#x3D; \frac{\eta_2}{\eta_1}<br>$$<br>如下图所示：</p><img src="/images/Rendering Blogs/Graphics Basis/Real-Time Physically Based Material Basics.assets/image-20211226132421570.png" alt="image-20211226132421570" style="zoom:50%;"><p>求解 transmissive ray $\boldsymbol{t}$ 有：</p><img src="/images/Rendering Blogs/Graphics Basis/Real-Time Physically Based Material Basics.assets/image-20211226141121612.png" alt="image-20211226141121612" style="zoom: 50%;"><p>如上图所示，入射光与物体的交点处切向量为 $M$，transmissive ray $\boldsymbol{t}$ 在切线方向与法线方向的分量分别为 $A,B$，因此有<br>$$<br>\begin{align}<br>\boldsymbol{t} &amp;&#x3D; A+B \<br>A &amp;&#x3D; ||\boldsymbol{t}|| \cdot \sin\theta_2 \cdot M &#x3D; \sin\theta_2 \cdot M \<br>B &amp;&#x3D; ||\boldsymbol{t}|| \cdot \cos\theta_2 \cdot -\boldsymbol{n} &#x3D; \cos\theta_2 \cdot -\boldsymbol{n} \<br>\boldsymbol{t} &amp;&#x3D; \sin\theta_2 \cdot M - \cos\theta_2 \cdot \boldsymbol{n}<br>\end{align}<br>$$</p><ul><li><p>求交点处的切向量<br>$$<br>\begin{align}<br>&amp; ||M|| \cdot \sin\theta_1 \cdot M&#x3D;\cos\theta_1\cdot \boldsymbol{n}-\boldsymbol{l} \<br>&amp; M &#x3D; \frac{\cos\theta_1\cdot \boldsymbol{n}-\boldsymbol{l}}{\sin\theta_1}<br>\end{align}<br>$$</p></li><li><p>由折射定律求 $\theta_2$<br>$$<br>\begin{align}<br>\sin\theta_2 &amp;&#x3D; \frac{\eta_1}{\eta_2}\cdot \sin\theta_1\<br>\cos\theta_2 &amp;&#x3D; \sqrt{1-\sin^2\theta_2}&#x3D;\sqrt{1-\frac{\eta_1^2}{\eta_2^2}\cdot \sin^2\theta_1}<br>\end{align}<br>$$</p></li></ul><p>最终有：<br>$$<br>\boldsymbol{t} &#x3D; \frac{\eta_1}{\eta_2}\cdot (\cos\theta_1\cdot \boldsymbol{n}-\boldsymbol{l})-\sqrt{1-\frac{\eta_1^2}{\eta_2^2}\cdot \sin^2\theta_1}\cdot \boldsymbol{n}<br>$$<br>令<br>$$<br>\begin{align}<br>\eta &amp;&#x3D; \frac{\eta_1}{\eta_2}\<br>c_1 &amp;&#x3D; \cos\theta_1&#x3D;\boldsymbol{l}\cdot\boldsymbol{n}\<br>c_2 &amp;&#x3D; \sqrt{1-\frac{\eta_1^2}{\eta_2^2}\cdot \sin^2\theta_1} &#x3D; \sqrt{1-\eta^2\cdot(1-c_1^2)}<br>\end{align}<br>$$<br>有，<br>$$<br>\begin{align}<br>\boldsymbol{t}&amp;&#x3D;\eta \cdot (c_1\cdot\boldsymbol{n}-\boldsymbol{l})-c_2\cdot \boldsymbol{n} \<br>&amp;&#x3D;(\eta\cdot c_1-c_2)\cdot \boldsymbol{n}-\eta\cdot\boldsymbol{l}<br>\end{align}<br>$$</p><blockquote><p>如果入射光方向写为指向交点的形式，上述推导需要些许修改</p><ul><li><p>交点处切向量<br>$$<br>\begin{align}<br>&amp; ||M|| \cdot \sin\theta_1 \cdot M&#x3D;\boldsymbol{l} + \cos\theta_1\cdot \boldsymbol{n} \<br>&amp; M &#x3D; \frac{\boldsymbol{l} + \cos\theta_1\cdot \boldsymbol{n}}{\sin\theta_1}<br>\end{align}<br>$$</p></li><li><p>参数定义</p></li></ul><p>$$<br>c_1&#x3D;\cos\theta_1&#x3D;-\cos(\pi-\theta_1)&#x3D;-\boldsymbol{l}\cdot\boldsymbol{n}<br>$$</p><p>折射光为<br>$$<br>\begin{align}<br>\boldsymbol{t} &amp;&#x3D; \eta\cdot(\boldsymbol{l} + c_1\cdot \boldsymbol{n})-c_2\cdot \boldsymbol{n} \<br>&amp;&#x3D; (\eta\cdot c_1-c_2)\cdot \boldsymbol{n}+\eta\cdot\boldsymbol{l}<br>\end{align}<br>$$</p></blockquote><h4 id="2-1-3-Fresnel"><a href="#2-1-3-Fresnel" class="headerlink" title="2.1.3 Fresnel "></a>2.1.3 Fresnel <a name="Fresnel"></a></h4><p>Fresnel 用来描述物体反射入射光的多少、折射入射光的多少，其精确的数学模型为 Fresnel equation。Fresnel equation 将入射光分解为一组互相垂直的波，即<strong>平行偏振（p 极化）光</strong>，位于入射光、反射光与折射光组成的平面内；<strong>垂直偏振（s 极化）光</strong>，垂直于入射光、反射光与折射光组成的平面。p 极化入射光与 s 极化入射光的反射比（反射光能量占入射光能量的比例）分别为，<br>$$<br>F_{R_{||}}&#x3D;\left(\frac{\eta_2\cos\theta_1-\eta_1\cos\theta_2}{\eta_2\cos\theta_1+\eta_1\cos\theta_2}\right)^2 \<br>F_{R_{\perp}}&#x3D;\left(\frac{\eta_1\cos\theta_2-\eta_2\cos\theta_1}{\eta_1\cos\theta_2+\eta_2\cos\theta_1}\right)^2<br>$$<br>其中，$\eta_1,\eta_2$ 分别为折射前后的介质的折射率(ior)，$\theta_1$ 为入射角，$\theta_2$ 为折射角。特殊地，图形学中通常考虑无偏振入射光，即含有等量的 s 极化与 p 极化，反射比为，<br>$$<br>F_R&#x3D;\frac{1}{2}(F_{R_{||}}+F_{R_{\perp}})<br>$$<br>无论入射光是否有偏振，根据能量守恒，透射比（折射光能量占入射光能量的比例）都为，<br>$$<br>F_T&#x3D;1-F_R<br>$$<br>下面两图为 s 极化、p 极化以及无极化的入射光条件下，不同入射角度的反射比曲线图，左图为绝缘体（Dielectric，$\eta&#x3D;1.5$），右图为导体</p><p><img src="/images/Rendering Blogs/Graphics Basis/Real-Time Physically Based Material Basics.assets/image-20211226183133063.png" alt="image-20211226183133063" style="zoom: 45%;"><img src="/images/Rendering Blogs/Graphics Basis/Real-Time Physically Based Material Basics.assets/image-20211226183325979.png" alt="image-20211226183325979" style="zoom: 45%;"></p><center>左图为绝缘体反射比曲线，右图为导体反射比曲线</center><p><strong>Schlick’s Approximation</strong></p><p>精确的 Fresnel equation 计算非常复杂，通常使用其近似形式——Schlick’s 近似。<br>$$<br>\begin{align}<br>F_R\approx F_{Schlick}&amp;&#x3D;F_0+(1-F_0)(1-\cos\theta)^5 \<br>&amp;&#x3D;(1-\cos\theta)^5\cdot 1 + (1-(1-\cos\theta)^5)\cdot F_0\<br>where \quad F_0&#x3D;&amp;\left(\frac{\eta_1-\eta_2}{\eta_1+\eta_2}\right)^2,\cos\theta&#x3D;\boldsymbol{l}\cdot\boldsymbol{h}<br>\end{align}<br>$$</p><p>$F_0$ 是沿着法线方向垂直入射时的反射率，当入射方向与法线夹角越来越大时，反射率也随之增大，直至入射方向与法线呈 $90^\circ$ 达到最大，由上式可知，此时为 $1$。上式的含义就是在垂直入射反射率与 grazing 入射反射率(白光) 之间的插值，角度越接近 $90^\circ$，反射率越接近白光。</p><h3 id="2-2-NDF-Specular-D"><a href="#2-2-NDF-Specular-D" class="headerlink" title="2.2 NDF (Specular D)"></a>2.2 NDF (Specular D)</h3><p>NDF(Normal Distribution Function) 为微表面法线分布函数，描述微观表面的微表面法线的统计分布。着色时，我们需要得到观察方向能够看到的信息，并且当入射光方向和观察方向的 half vector 与法线重合时，对应信息才能被观察到。 因此我们需要得到微表面法线在此 half vector 方向上的分布情况，即概率。 NDF 输入某点的 roughness(微表面法线集中程度，越集中 roughness 越低)、宏观表面法线以及入射光方向与观察方向的 half vector 作为微表面法线方向，输出分布函数在此微表面法线方向的概率。</p><p><a href="#%5B2%5D">[2]</a> 这篇博客总结得很好，不再赘述</p><h3 id="2-3-Shadow-Masking-Term-Specular-G"><a href="#2-3-Shadow-Masking-Term-Specular-G" class="headerlink" title="2.3 Shadow-Masking Term (Specular G)"></a>2.3 Shadow-Masking Term (Specular G)</h3><p><a href="#%5B3%5D">[3]</a> 这篇博客总结得很好，不再赘述</p><h2 id="3-Diffuse-BRDF"><a href="#3-Diffuse-BRDF" class="headerlink" title="3 Diffuse BRDF"></a>3 Diffuse BRDF</h2><h3 id="3-1-Lambertian-Diffuse-BRDF"><a href="#3-1-Lambertian-Diffuse-BRDF" class="headerlink" title="3.1 Lambertian Diffuse BRDF"></a>3.1 Lambertian Diffuse BRDF</h3><p>Lambertian 模型将漫发射理解为：光交于 diffuse 表面发生折射，在物体表面下进行了充足的散射后离开表面，向每个方向均匀反射，因此 Lambertian Diffuse BRDF 是一个常数。假设该常数为 $\mathcal{C}$，下面根据能量守恒推算出 $\mathcal{C}$。我们先来介绍 Lambert’s Consine Law。</p><h4 id="3-1-1-Lambert’s-Cosine-Law"><a href="#3-1-1-Lambert’s-Cosine-Law" class="headerlink" title="3.1.1 Lambert’s Cosine Law"></a>3.1.1 Lambert’s Cosine Law</h4><p>对于以一定角度入射的 irradiance，物体接受到的 irradiance 与角度余弦成正比，该角度为入射方向与法线的夹角。详情查看 <a href="#%5B4%5D">[4]</a> 的 Irradiance(辐照度)部分。</p><h4 id="3-1-2-能量守恒计算-Lambertian-Diffuse-BRDF"><a href="#3-1-2-能量守恒计算-Lambertian-Diffuse-BRDF" class="headerlink" title="3.1.2 能量守恒计算 Lambertian Diffuse BRDF"></a>3.1.2 能量守恒计算 Lambertian Diffuse BRDF</h4><p>假设空间中任何方向入射的光 radiance 都一样，即 unifom incident lighting。如果物体不吸收光，根据能量守恒，入射 irradiance 等于出射 irradiance。假设入射方向 $\omega_i$ 的入射 irradiance 为 $L_i(\omega_i)$，入射角为 $\theta_i$，那么在 $\omega_o$ 出射方向上的出射 irradiance 为，<br>$$<br>L_o(\omega_o)&#x3D;\int_{\Omega^+} \mathcal{C}\cdot L_i(\omega_i)\cdot \cos\theta_i\space d\omega_i<br>$$<br>由于是 uniform incident lighting，因此入射 irradiance 是常数，上式可变为，<br>$$<br>\begin{align}<br>L_o(\omega_o)&amp;&#x3D;\mathcal{C}\cdot L_i\cdot\int_{\Omega^+}\cos\theta_i\space d\omega_i \<br>&amp;&#x3D; \mathcal{C}\cdot L_i\cdot\int_0^{2\pi}\int_0^{\pi&#x2F;2}\cos\theta_i\sin\theta_i\space d\theta_id\phi_i \<br>&amp;&#x3D; \mathcal{C}\cdot L_i\cdot\pi<br>\end{align}<br>$$<br>由于 Lambertian 模型认为每个方向均匀反射，因此 $L_o$ 是常数，所以有 $L_o&#x3D;L_i$，<strong>Lambertian Diffuse BRDF (无能量损失情况下)为</strong><br>$$<br>\mathcal{C}&#x3D;\frac{1}{\pi}<br>$$</p><h4 id="3-1-3-具有能量损失的-diffuse-材质"><a href="#3-1-3-具有能量损失的-diffuse-材质" class="headerlink" title="3.1.3 具有能量损失的 diffuse 材质"></a>3.1.3 具有能量损失的 diffuse 材质</h4><p>上述为了计算出 diffuse brdf 假定了无能量损失，但大多数材质会有能量吸收，只有部分能量反射出。反射能量的多少即为反射率，听起来像是前述 <a href="#Fresnel">Fresnel</a> 的功能，但并非如此。Fresnel 是定义在无限小且无限光滑的微表面上的，例如前述的反射定律与折射定律的计算过程。而 Lambertian diffuse 材质是针对整个宏表面，在整个宏表面上均匀反射，因此 diffuse 材质的反射率不需要 Fresnel 这样精确的微观尺度。</p><p>实际中的 Lambertian diffuse 材质的反射率是通过 albedo 来定义，albedo 一般又定义为 diffuse color。这也符合我们常识中对颜色的认知——颜色即物体吸收了入射光的部分波段而反射出剩余波段的能量。diffuse color 在图形学中视为物体的固有色，即在自然界日光照射下所呈现的颜色。</p><p>因此，<strong>在具有能量损失时，Lambertian Diffuse BRDF</strong> 为<br>$$<br>f_{diffuse}&#x3D;\frac{albedo}{\pi}&#x3D;\frac{C_{diffuse}}{\pi}<br>$$</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a name="[1]">[1]</a> <a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel">https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel</a></p><p><a name="[2]">[2]</a> <a href="https://zhuanlan.zhihu.com/p/69380665">https://zhuanlan.zhihu.com/p/69380665</a></p><p><a name="[3]">[3]</a> <a href="https://zhuanlan.zhihu.com/p/81708753">https://zhuanlan.zhihu.com/p/81708753</a></p><p><a name="[4]">[4]</a> [Basic Radiometry](.&#x2F;Basic Radiometry.md)</p>]]></content>
    
    
    <categories>
      
      <category>Rendering Blogs</category>
      
      <category>Graphics</category>
      
      <category>PBR</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SlabHash</title>
    <link href="/2024/08/19/Rendering%20Blogs/GPGPU/Parrallel%20Scan/"/>
    <url>/2024/08/19/Rendering%20Blogs/GPGPU/Parrallel%20Scan/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><h1 id="2-2-Phase-Parallel-Scan"><a href="#2-2-Phase-Parallel-Scan" class="headerlink" title="2 2-Phase Parallel Scan"></a>2 2-Phase Parallel Scan</h1><p>使用一种在并行计算中经常出现的算法模式：平衡树。其思想是，在输入数据上构建一棵平衡的二叉树，并通过自根向上和向下的遍历来计算前缀和。一棵有n<em>n</em>个叶子的二叉树有log⁡nlog<em>n</em>层，每一层d∈[0,n)<em>d</em>∈[0,<em>n</em>)有2d2<em>d</em>个节点。如果我们对每个节点执行一次加法操作，那么在一次树的遍历中，我们将执行O(n)<em>O</em>(<em>n</em>)次加法操作。</p><h2 id="2-1-Reduce-Phase-Up-Sweep-Phase"><a href="#2-1-Reduce-Phase-Up-Sweep-Phase" class="headerlink" title="2.1 Reduce Phase (Up-Sweep Phase)"></a>2.1 Reduce Phase (Up-Sweep Phase)</h2><img src="/images/Rendering Blogs/GPGPU/Parrallel Scan.assets/image-20240820110843745.png" alt="image-20240820110843745" style="zoom:67%;"><h2 id="2-2-Down-Sweep-Phase"><a href="#2-2-Down-Sweep-Phase" class="headerlink" title="2.2 Down-Sweep Phase"></a>2.2 Down-Sweep Phase</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>Guy E. Blelloch. “Prefix Sums and Their Applications”. In John H. Reif (Ed.), Synthesis of Parallel Algorithms, Morgan Kaufmann, 1990.<br><a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/scandal/public/papers/CMU-CS-90-190.html">http://www.cs.cmu.edu/afs/cs.cmu.edu/project/scandal/public/papers/CMU-CS-90-190.html</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Rendering Blogs</category>
      
      <category>GPGPU</category>
      
      <category>Scan</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GI-1.0 - A Fast Scalable Two-Level Radiance Caching Scheme for Real-Time Global Illumination</title>
    <link href="/2024/04/12/Paper%20Notes/GI/GI-1.0%20A%20Fast%20Scalable%20Two-Level%20Radiance%20Caching%20Scheme%20for%20Real-Time%20Global%20Illumination/"/>
    <url>/2024/04/12/Paper%20Notes/GI/GI-1.0%20A%20Fast%20Scalable%20Two-Level%20Radiance%20Caching%20Scheme%20for%20Real-Time%20Global%20Illumination/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Summary"><a href="#1-Summary" class="headerlink" title="1 Summary"></a>1 Summary</h1><h1 id="2-GI-1-0"><a href="#2-GI-1-0" class="headerlink" title="2 GI-1.0"></a>2 GI-1.0</h1><p>对于实时渲染，尽管是在目前的高端显卡上，也只能支持每像素很少的样本数量。本文提出的全局光照管线，通过设计的两级radiance cache，在空间、时间上复用样本的光照信息，如下图所示：</p><ul><li>screen cache：将primary path上顶点的入射radiance缓存到直接可见表面上的probe中，具有精细的光照表示。</li><li>world cache：缓存了secondary path上顶点的出射radiance，相比于screen cache，不够精细但具有稳定和持久的优点。</li></ul><img src="/images/Paper Notes/GI/GI-1.0 A Fast Scalable Two-Level Radiance Caching Scheme for Real-Time Global Illumination.assets/image-20240412142048484.png" alt="image-20240412142048484" style="zoom: 80%;"><p>基于这两级radiance cache，本文提出的GI管线可以提以 1&#x2F;4 spp 的采样率实现高保真的直接与间接光。</p><h2 id="2-1-Screen-Cache"><a href="#2-1-Screen-Cache" class="headerlink" title="2.1 Screen Cache"></a>2.1 Screen Cache</h2><p>screen cache 是基于screen probe的实现，本章节会介绍如何将screen probe稀疏地生成在像素上；如何在帧间管理cache数据结构的完整性；以及如何应用 filtering 启发式策略来确保光照在任意距离下的时序稳定性。</p><p>与 <a href="#%5B2%5D">[2]</a> 一样，在半球面入射的radiance会以八面体映射<a href="#%5B3%5D">[3]</a>的方式编码到 8x8 单元的地图集中。</p><h3 id="2-1-1-Temporal-Upscale"><a href="#2-1-1-Temporal-Upscale" class="headerlink" title="2.1.1 Temporal Upscale"></a>2.1.1 Temporal Upscale</h3><p>前面提到，screen probe 只能在屏幕像素上稀疏地生成。在本文提出的方法中，screen probe的生成分摊在多帧。先预设屏幕多大tile放置一个probe，每帧生成不同tile的probe，然后通过重投影复用历史帧的probe，最终几帧后达到覆盖屏幕的全部 tile，即 upscale 到全分辨率。upscale 系数决定了采样率，可以作为性能与质量的权衡。本文的实现中选择使用一个 probe 来编码一个大小为 $8\times 8$ 的 tile 的半球radiance信息，同时每个probe分辨率为 $8\times 8$。因此，这里可以将生成screen probe的tile大小定义为 $8\cdot (upscale_x, upscale_y)$ ，其中 $upscale_x$、$upscale_y$ 分别表示 X、Y 上的时序 upscale 量，越大意味着需要更多帧达到全分辨率。</p><p>在为每个tile生成一个screen probe时，作者使用 Halton 低差异序列在 tile 内抖动选择一个像素作为生成位置。当 upscale 选择 $(2,2)$​ 时，则需要4帧能够达到完全填充，即每个tile至少具有一个probe，如图 <a href="#Fig-2">Fig-2</a> 所示。</p><blockquote><p>这里的说法有点冲突。Halton序列应该是将spawn tile划分成立 upscale_x * upscale_y 份，每次在其中一份（probe grid&#x2F;tile）中抖动生成一个probe</p></blockquote><p><a name="Fig-2"></a></p><img src="/images/Paper Notes/GI/GI-1.0 A Fast Scalable Two-Level Radiance Caching Scheme for Real-Time Global Illumination.assets/image-20240412152316538.png" alt="image-20240412152316538" style="zoom:67%;"><center>Fig-2: 图中将不存在probe的tile像素标为红色。左图为第一帧时的probe分布，此时只填充了1/4数量的tile；右图为4帧后的probe分布</center><p>temporal upscale 依赖于probe重投影。为了不降低质量，需要确保重投影过程的准确性。在使用 motion vector 重投影上一帧probe时，得到的对应是当前帧的一个 probe tile，因此还需要确定重投影到tile的哪个像素上。作者提出一个启发式策略，用来在probe tile内找到与上一帧probe最匹配的像素。下面是确定最匹配像素的算法伪代码，其中 <code>cell_size</code> 是一个启发式参数，用于控制能够接受多大程度的 spatial error，该参数在后面也会用到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">_kernel <span class="hljs-title">reproject_screen_probes</span><span class="hljs-params">(pixel p)</span> <span class="hljs-comment">// 表示workgroup的一个线程任务，pixel p为local_lane对应的像素</span></span><br><span class="hljs-function"></span>&#123;<br>    _local uint reprojection_score = (<span class="hljs-built_in">pack_half</span>(<span class="hljs-number">65504.0</span>) &lt;&lt; <span class="hljs-number">16</span>) | <span class="hljs-number">0xFFFFu</span>;<br>    <span class="hljs-built_in">barrier</span>();<br>    <span class="hljs-keyword">if</span> (p is <span class="hljs-keyword">not</span> a sky pixel) &#123;<br>        q = p in previous frame;<span class="hljs-comment">// 像素p投影回上一帧</span><br>    <span class="hljs-keyword">if</span> (probe_q is valid) &#123; <span class="hljs-comment">// probe_q 是什么？</span><br>            <span class="hljs-comment">// world_probe、normal_probe 应该是重投影probe所位于的像素属性</span><br>            <span class="hljs-comment">// world_p、normal_p 是像素p的属性</span><br>            plane_dist = <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">dot</span>(world_probe - world_p, normal_p));<br>            normal_check = <span class="hljs-built_in">dot</span>(normal_probe, normal_p);<br>            <span class="hljs-keyword">if</span> (plane_dist &lt; cell_size &amp;&amp; normal_check &gt; <span class="hljs-number">0.95</span>) &#123; <span class="hljs-comment">// 剔除掉平面距离与法线差异超出阈值的像素</span><br>                dist = <span class="hljs-built_in">distance</span>(world_probe, world_p);<span class="hljs-comment">// 使用像素到重投影probe的距离作为分数</span><br>                uint probe_score = (<span class="hljs-built_in">pack_half</span>(dist) &lt;&lt; <span class="hljs-number">16</span>) | local_lane;<br>                <span class="hljs-built_in">atom_min</span>(reprojection_score, probe_socre);<br>            &#125;<br>&#125;<br>    &#125;<br>    <span class="hljs-built_in">barrier</span>();<br>    <span class="hljs-comment">// decode and use 𝑙𝑜𝑐𝑎𝑙_𝑙𝑎𝑛𝑒 as destination pixel</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述算法应该是要先将上一帧probe所属tile投影到当前帧，得到 probe tile，然后再对 probe tile 内的每个像素执行上述打分过程，分数越高表示像素与重投影probe的差异越大，因此需要取其中的最小值。此外，算法使用一个 32bit 的高16位存储socre、低16位存储lane编号，这种做法是为了让比较过程由score的关系确定，而lane编号对比较没有影响。最终得到最小score时，同时可以得到lane编号，从而确定对应的pixel。但不知道 <code>pack_half</code> 怎么实现的？ :confused:</p><h3 id="2-1-2-Adaptive-Sampling"><a href="#2-1-2-Adaptive-Sampling" class="headerlink" title="2.1.2 Adaptive Sampling"></a>2.1.2 Adaptive Sampling</h3><p>前一小节描述了重投影复用上一帧的probe，可以很快达到覆盖全分辨率，但实际中往往会发生去遮挡 (disocclusion) 情况，此时去遮挡区域会找不到重投影probe，如 <a href="#Fig-3">Fig-3</a> 左图所示</p><p><a name="Fig-3"></a></p><img src="/images/Paper Notes/GI/GI-1.0 A Fast Scalable Two-Level Radiance Caching Scheme for Real-Time Global Illumination.assets/image-20240412194247447.png" alt="image-20240412194247447" style="zoom:67%;"><center>Fig-3: 左图，相机移动出现无法找到重投影probe的去遮挡区域；右图，stochastic ray re-balancing 算法填充空洞后的结果</center><p>当发生去遮挡时，一种解决办法可以是创建新的probe，来填充这些空白区域，但这会导致spp增大、开销增加。作者提出从时序重投影成功的tiles中随机挑选一部分，分配给这些空白tiles，这样可以保持稳定的开销。为此需要生成两个queues：</p><ul><li>empty_tiles buffer：存储重投影失败且没有新生成probe的tile列表</li><li>override_tiles buffer：存储重投影成功且新生成probe的tile列表</li></ul><p>接下来，为每个 empty tile 随机选择一个 override tile，并放入<code>spawn_tiles</code>内，算法如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">_kernel <span class="hljs-title">patch_screen_probes</span><span class="hljs-params">(uint global_id)</span> </span>&#123;<span class="hljs-comment">// global_id 应该是在整个dispatch里的线程id</span><br>tile = empty_tiles[global_id];<br>index = <span class="hljs-built_in">random</span>(<span class="hljs-number">0</span>, override_tile_count - <span class="hljs-number">1</span>);<br><span class="hljs-built_in">atom_xchg</span>(spawn_tiles[override_tiles[index]], tile);<span class="hljs-comment">// 使用数组将override tile重定向到empty tile</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该算法通过重分配一定的光线样本预算，来填充时序空洞，效果如 <a href="#Fig-3">Fig-3</a> 右图所示。</p><p>算法使用数组存储索引的方式来重定向tile，在生成光线样本阶段，会从 spawn_tiles 中获取真正的tile。spawn_tiles 应该是总tile数量的大小，存储的是每个tile索引对应要生成probe的tile索引。在没有重分配算法下，spawn_tiles[index] &#x3D; index。重分配算法中，会将其中一部分override tile修改为empty tile，即 spawn_tiles[override tile] &#x3D; empty tile。</p><h3 id="2-1-3-Ray-Guiding"><a href="#2-1-3-Ray-Guiding" class="headerlink" title="2.1.3 Ray Guiding"></a>2.1.3 Ray Guiding</h3><p>前面小节完成了放置probe，接下来需要为probe生成光线样本，即如何在八面体的cells中分配光线。作者采用与 <a href="#%5B2%5D">[2]</a> 相同的方法，根据上一帧结果进行重要性采样。实现上，先将重投影的radiance的luminance写入Local Data Share (LDS)，再通过warp&#x2F;subgroup指令并行扫描，标准化为 Cumulative Distribution Function (CDF)，最后使用 CDF 随机选择一个cell。</p><p><a name="Fig-4"></a></p><img src="/images/Paper Notes/GI/GI-1.0 A Fast Scalable Two-Level Radiance Caching Scheme for Real-Time Global Illumination.assets/image-20240415110725456.png" alt="image-20240415110725456" style="zoom:67%;"><center>Fig-4: 左图为uniform sampling；右图为temporal ray guiding</center><p>为了提高guiding过程的准确性，需要半球重建尽可能忠实。这里的重建在 3x3 tiles邻域内迭代重投影probe，并累积radiance值到还未计算的新生成probe中最匹配的cell上。但在不同probe的cell之间重用数据，需要先解决它们之间的视差问题，如 <a href="#Fig-5">Fig-5</a>。光线样本的 alpha 存储了hit距离，因此可以恢复出重投影cell的 hit position，基于此可以在重投影的radiance散布到新生成probe之前，执行视差矫正。</p><p><a name="Fig-5"></a></p><img src="/images/Paper Notes/GI/GI-1.0 A Fast Scalable Two-Level Radiance Caching Scheme for Real-Time Global Illumination.assets/image-20240415113213730.png" alt="image-20240415113213730" style="zoom: 67%;"><center>Fig-5: 不同probe的cell之间的视差</center><p>radiance的scatering过程通过在LDS中分配 8x8 八面体图来高效实现重建与采样。与 2.1.1 小节类似，使用 cell_size 拒绝掉较远的probe。</p><p>到此，probe的光线样本都已生成，接下来执行光追与场景求交。当无交点时，认为交到天空，将环境光加入光线；当有交点时，则需要计算交点处的光照，这是通过后面的hash cells data structure来实现的。</p><h3 id="2-1-4-Radiance-Blending"><a href="#2-1-4-Radiance-Blending" class="headerlink" title="2.1.4 Radiance Blending"></a>2.1.4 Radiance Blending</h3><p>此时，我们得到了所有光线样本的radiance信息，但由于ray guiding，八面体的同一cell可能会由多个光线样本，这些样本直接使用重要性采样加权平均即可得到当前新的radiance。除此之外，还需要将新的radiance与上一小节重建的radiance进行时序混合。对于blend方式的选择，exponential moving average <a href="#%5B4%5D">[4]</a> 如下式所示<br>$$<br>s_t &#x3D; \alpha x_t + (1-\alpha)s_{t-1} &#x3D; \alpha\sum_{k&#x3D;0}^{\infty}(1-\alpha)^kx_{t-k}<br>$$<br>其中 $x_t$ 为 $t$ 时刻新的样本，$s_t$ 为 $t$ 时刻累积样本，可以看出历史数据是以指数级别衰减，即随着 k 增大，而在最终结果中占比降低。probe无论空间，还是方向上，都是相对比较稀疏的分布，因此八面体一个cell会占据半球面上相当大的区域。</p><p>作者发现这种方式会明显损失真实感。相反，作者选择将新得到的光线样本radiance与重建的radiance之间的标准化差异作为temporal blending amount的一个因素。下面是blend过程的算法伪代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">function <span class="hljs-title">temporal_blend</span><span class="hljs-params">(curr_radiance, prev_radiance)</span></span><br><span class="hljs-function"></span>&#123;<br>    l1 = <span class="hljs-built_in">dot</span>(curr_radiance, <span class="hljs-number">1.0</span> / <span class="hljs-number">3.0</span>);<br>    l2 = <span class="hljs-built_in">dot</span>(prev_radiance, <span class="hljs-number">1.0</span> / <span class="hljs-number">3.0</span>);<br>    alpha = <span class="hljs-built_in">max</span>(l1 - l2 - <span class="hljs-built_in">min</span>(l1, l2), <span class="hljs-number">0.0</span>) / <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(l1, l2), <span class="hljs-number">1e-4</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">lerp</span>(curr_radiance, prev_radiance, alpha);<br>&#125;<br></code></pre></td></tr></table></figure><p>上述算法以图像一定程度的变暗为代价，更好了保留了遮挡与阴影。除此之外，该算法还有荧光点去除的作用，过滤掉比八面体cell对应的立体角小得多的明亮信号，提高时序稳定性。</p><p>另一点，由于guiding策略，会有部分cells不存在任何样本，这时如果直接重用时序重建的结果会导致明显的视觉artifact，然后对这些cells直接留空又会由于能量损失而过暗。对此，作者选择对已填充cell的radiance进行平均，并均匀分布到未追踪的cell中。这种做法是通过近似缺失的样本来恢复一些丢失的能量，如 <a href="#Fig-6">Fig-6</a> 所示。在测试中，这种情况只会应用到低概率cell上，同时没有发现明显的visual artifacts。</p><blockquote><p>这种情况的处理，非常trick。仅仅是求其他所有光追样本的平均值，作为没有追踪的cell的近似样本。</p></blockquote><p><a name="Fig-6"></a></p><img src="/images/Paper Notes/GI/GI-1.0 A Fast Scalable Two-Level Radiance Caching Scheme for Real-Time Global Illumination.assets/image-20240415140118581.png" alt="image-20240415140118581" style="zoom:67%;"><center>Fig-6: 左图，由于空cells变暗；右图，使用平均值作为空cell的样本</center><h3 id="2-1-5-Probe-Masking"><a href="#2-1-5-Probe-Masking" class="headerlink" title="2.1.5 Probe Masking"></a>2.1.5 Probe Masking</h3><p>probe是放置在 8x8 screen tiles内的任意一个像素上，因此使用 32-bit 整数编码 tile 内的像素坐标，来确定probe位置。该整数使用一张2D贴图存储 <code>probe_mask</code>。对于empty tile或者无效tile，使用一个 sentinel value 表示，如 <a href="#Fig-7">Fig-7</a> 所示。</p><p><a name="Fig-7"></a></p><p>![image-20240415151024688](&#x2F;images&#x2F;Paper Notes&#x2F;GI&#x2F;GI-1.0 A Fast Scalable Two-Level Radiance Caching Scheme for Real-Time Global Illumination.assets&#x2F;image-20240415151024688.png)</p><center>Fig-7: sentinel 被标记为红色。</center><p>在运动中，有大量区域缺失probe。在采样probe时，通常需要查找某一方向上最近的probe。作者提出生成 probe_mask 的 mip chain 来实现高效查找最近的有效probe，其中 mip chain 维护了上一层 2x2 中第一个找到的有效probe。查找像素给定方向上的最近有效probe的算法如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">function <span class="hljs-title">find_closest_probe</span><span class="hljs-params">(int2 pixel, int2 offset)</span></span><br><span class="hljs-function"></span>&#123;<br>    pixel /= <span class="hljs-number">8</span>;<span class="hljs-comment">// 变换到 probe 空间</span><br>    foreach mip in [<span class="hljs-number">0</span>, mip)count - <span class="hljs-number">1</span>] <span class="hljs-keyword">do</span> &#123;<br>        int2 pos = pixel + offset;<br>        <span class="hljs-keyword">if</span> (pos is out of bounds) <span class="hljs-keyword">break</span>;<br>        <br>        uint porbe = probe_mask.<span class="hljs-built_in">Load</span>(pos, mip);<br>        <span class="hljs-keyword">if</span> (probe is <span class="hljs-keyword">not</span> sentinel) <span class="hljs-keyword">return</span> probe;<span class="hljs-comment">// 找到 probe</span><br>        <br>        pixel /= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sentinel;<span class="hljs-comment">// could not find any probe</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-6-Probe-Filtering"><a href="#2-1-6-Probe-Filtering" class="headerlink" title="2.1.6 Probe Filtering"></a>2.1.6 Probe Filtering</h3><p>由于probe的光线样本在八面体cell内每帧都会抖动，以及后面提出的hash cell返回的radiance也会很噪，因此导致probe非常噪。作者使用前一小节的高效搜索算法，再执行一次 7x7 稀疏blur。filter 算法伪代码如下所示，其中再次用到了 cell_size 来排除掉较远的probe以及避免light leaking。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">__kernel <span class="hljs-title">filter_screen_probes</span><span class="hljs-params">(global_id, local_id, group_id)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 提取目标 probe 的信息，即 filter 到哪个probe内</span><br>    p = <span class="hljs-built_in">decode_probe_mask</span>(spawn_tiles[group_id]);<br>    dir = <span class="hljs-built_in">calculate_cell_direction</span>(local_id, normal_p);<br>    radiance = probe_buffer[global_id]; <span class="hljs-comment">// 应该是local_id吧。看前两行，globa_id对应probe，local_id对应cell</span><br>    hit_dist = radiance.a;<br>    weight = <span class="hljs-number">1.0</span>;<br>    <br>    foreach i in [<span class="hljs-number">0</span>, <span class="hljs-number">5</span>] <span class="hljs-keyword">do</span> &#123;<span class="hljs-comment">// 6个周围probe加上自身整个 7x7 区域</span><br>        step = (((t &amp; <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>) * ((i &gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);<br>        probe = <span class="hljs-built_in">find_closest_probe</span>(p, step * blur_direction);<span class="hljs-comment">// blur_direction 应该用于控制filter方向，x、y 方向各一次</span><br>        <span class="hljs-keyword">if</span> (probe is sentinel) <span class="hljs-keyword">continue</span>;<br>        <br>        q = <span class="hljs-built_in">decode_probe_mask</span>(probe);<span class="hljs-comment">// q下标为当前查找到的相邻probe</span><br>        plane_dist = <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">dot</span>(world_q - world_p, normal_p));<br>        normal_check = <span class="hljs-built_in">dot</span>(direction, normal_q);<br>        <span class="hljs-keyword">if</span> (plane_dist &gt; cell_size <span class="hljs-keyword">or</span> normal_check &lt; <span class="hljs-number">0.0</span>) <span class="hljs-keyword">continue</span>;<br>        <br>        hit_dist_clamped = <span class="hljs-built_in">min</span>(hit_dist_q, hit_dist);<br>        hit_Point = world_q + dir * hit_dist_clamped;<span class="hljs-comment">// 查找probe样本起点沿着目标光线样本方向行进，应该是用于计算视差</span><br>        angle_error = <span class="hljs-built_in">dot</span>(dir, <span class="hljs-built_in">normalize</span>(hit_point - world_p));<br>        <span class="hljs-keyword">if</span> (angle_error &lt; <span class="hljs-built_in">cos</span>(pi / <span class="hljs-number">50.0</span>)) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// angle_error 为视差夹角余弦，越小表示偏差越大</span><br>        <br>        depth_weight = <span class="hljs-built_in">calculate_depth_weight</span>(depth_p, depth_q);<br>        radiance += depth_weight * <span class="hljs-built_in">float4</span>(radiance_q, hit_dist_clamped);<br>        weight += depth_weight;<br>        hit_dist = radiance.a / weight;<br>    &#125;<br>    <br>    <span class="hljs-comment">// store radiance/weight</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：前面的ray guiding策略，会导致cell上对应的光线样本可能属于其它cell，但后续处理已经将每个cell的radiance结果处理到对应位置，因此上述算法仅仅对不同probe之间对应的cell进行filter。</p><p>算法最后使用了与 <a href="#%5B2%5D">[2]</a> 相似的角度误差检测方法，用来保留一些小尺度的遮挡细节，如图 <a href="#Fig-8">Fig-8</a>。</p><p><a name="Fig-8"></a></p><img src="/images/Paper Notes/GI/GI-1.0 A Fast Scalable Two-Level Radiance Caching Scheme for Real-Time Global Illumination.assets/image-20240415154453580.png" alt="image-20240415154453580" style="zoom:67%;"><center>Fig-8: 7x7 probe space下的稀疏filter。左图不带有角度误差，右图带有角度误差</center><h3 id="2-1-7-Adaptive-Cell-Size"><a href="#2-1-7-Adaptive-Cell-Size" class="headerlink" title="2.1.7 Adaptive Cell Size"></a>2.1.7 Adaptive Cell Size</h3><p>前面这些小节多次用到了<code>cell_size</code>，这个量直接关系到相邻probe之间的radiance重用对空间误差的容忍度。cell_size 的值越小能够保留更好的细节，但时序稳定性差，越大能有更好的时序稳定性，但降低光照质量。作者提出使用基于与相机的距离，自适应调整 cell_size，效果如 <a href="Fig-9">Fig-9</a> 所示。</p><p><a name="Fig=9"></a></p><img src="/images/Paper Notes/GI/GI-1.0 A Fast Scalable Two-Level Radiance Caching Scheme for Real-Time Global Illumination.assets/image-20240415154324296.png" alt="image-20240415154324296" style="zoom:80%;"><center>Fig-9: 基于距离的radiance重用启发式策略。左图，近距离下捕获细节；右图，远距离下优雅地退化细节</center><p>自适应调整 cell_size 的算法伪代码如下，其中 fov_y 为垂直 fov，单位为radians；proj_size 是投影后cell size，单位为像素，作者选择 8.0，即相邻probe之间粗略的像素距离。此外，distance_scale 在每帧是固定，可以在 CPU 上计算好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">function <span class="hljs-title">calculate_cell_size</span><span class="hljs-params">(distance_to_camera)</span></span><br><span class="hljs-function"></span>&#123;<br>distance_scale = <span class="hljs-built_in">tan</span>(<br>        fov_Y * proj_size * <br>        <span class="hljs-built_in">max</span>(<span class="hljs-number">1.0</span> / view_Height, view_height / <span class="hljs-built_in">pow2</span>(view_width))<br>    );<br>    <span class="hljs-keyword">return</span> distance_scale * distance_to_camera;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-8-Persistent-Least-Recently-Used-LRU-Side-Cache"><a href="#2-1-8-Persistent-Least-Recently-Used-LRU-Side-Cache" class="headerlink" title="2.1.8 Persistent Least-Recently Used (LRU) Side Cache"></a>2.1.8 Persistent Least-Recently Used (LRU) Side Cache</h3><p>对于具有细小几何特征的情况下，会出现probe的时序-空间的radiance重用一直失败的情况，从而导致时序上的不稳定性。例如 <a href="#Fig-10">Fig-10</a> 中，一个tile内的细小几何特征，有如下过程：</p><ul><li><p>第一帧 probe 1 生成在细小的几何特征上，并计算probe数据</p></li><li><p>第二帧 probe 2 （同一tile内）生成，但由于 cell_size 测试失败，无法重用来自上一帧 1 的信息。因此，它需要从头开始重新计算（在忽略掉 3x3 邻域重建过程的情况下）。</p><blockquote><p>这里的cell_size测试失败不理解，感觉更多是 probe 2 不在细小几何特征上，normal测试或者 probe 2 所在位置失效导致失败</p></blockquote></li><li><p>第三帧 probe 3 重新生成在几何特征上，因此同样无法重用上一帧 2 的信息</p></li></ul><p><a name="Fig-10"></a></p><img src="/images/Paper Notes/GI/GI-1.0 A Fast Scalable Two-Level Radiance Caching Scheme for Real-Time Global Illumination.assets/image-20240415163819243.png" alt="image-20240415163819243" style="zoom: 67%;"><center>Fig-10: 由于细小几何导致时序重用失败</center><p>上述情况中，probe 3 可以重用 probe 1 的信息，但由于 probe 2 由于重用失败，导致 probe 1 的信息已经被覆盖。因此在这种情况下，该tile内的时序重投影、ray guiding以及blending在每帧一直处于失败状态。作者提出使用一个 LRU queue 来维护被逐出的 (evicted) probe，这样就可以让这些probe能在任意帧后被使重用。当新生成的probe无法从同一tile的重投影probe中复用数据时，则尝试重用queue中的cache probe。</p><p>queue中存储的是cache probe的索引，其数据存储在贴图中索引对应位置。由于cache probe可能会存在很多帧，无法使用depth buffer还原其世界坐标。因此需要为每个cache probe保存 float3 position 以及编码到单个 float 中的world normal，作者使用 128-bit integer存储。 </p><p>在 2.1.3 小节的guiding策略前，需要 3x3 probe space 的半球重建。在这里，更新该半球重建过程为完成 3x3 重投影 tile 搜索后，再在 3x3 相邻 tile 上搜索 cache probe。与之前一样，radiance进行视差矫正并累积到 LDS 中。当完成搜索后，side cache 的更新有三种情况：</p><ul><li><p>当前一帧probe被新生成probe逐出且无有效cache entry时，创建一个新的cache entry，并在blending pass将重投影radiance更新到cache。</p><blockquote><p>上一帧probe被当前帧逐出，也就是说重投影失败。在blending pass写入cache应该是指重投影radiance以blend形式写入。</p></blockquote></li><li><p>当前一帧被新生成probe逐出且找到匹配cache entry，在blending pass将重投影radiance写入cache，并将该cache entry放入 most-recently used (MRU) queue。</p></li><li><p>无论前一帧probe是否被逐出，都会识别参与重建的最匹配cache entry。如果有的话，则在blending pass将重投影radiance写入cache，这可以确保cache数据不会落后于光照状态改变。</p><blockquote><p>在cache中查找匹配cache entry，是在 3x3 相邻 tile 上进行的。如前所述，先将cache entry投影到屏幕，判断哪些位于 3x3 相邻tile。其中最匹配的cache entry的数据会被更新，这应该包括了第二种情况</p></blockquote></li></ul><p>每帧还要执行 re-ordering pass，将 MRU 中的cache entries永远放在LRU queue最前面。上述情况中，更新cache entry需要使用 atomic compare and swap，避免多个work groups在radiance blending阶段同时更新同一cache。</p><h2 id="2-2-World-Cache"><a href="#2-2-World-Cache" class="headerlink" title="2.2 World Cache"></a>2.2 World Cache</h2><p>world cache 维护了次级光路顶点的出射radiance（按照forward path tracing的方向来看），作者基于 <a href="#%5B5%5D">[5]</a> 中的 hash cells 数据结构，提出新的 tiling 方法，该方法能够更高效地在相邻cells之间filter。</p><h3 id="2-2-1-Caching-Outgoing-Radiance-for-Secondary-Path-Vertices"><a href="#2-2-1-Caching-Outgoing-Radiance-for-Secondary-Path-Vertices" class="headerlink" title="2.2.1 Caching Outgoing Radiance for Secondary Path Vertices"></a>2.2.1 Caching Outgoing Radiance for Secondary Path Vertices</h3><p>world cache通过对顶点描述的hash来寻址hash table中的radiance cell。寻址过程如下图所示，先使用一个fast hash定位bucket index；再使用另一个hash函数计算一个fingerprint，用于在bucket内 linear probing，确定cell的存储位置。作者选择了两个彼此之间几乎不会冲突的hash函数，即linear probing过程不会比较顶点描述，而是直接比较第二次hash生成fingerprint，忽略了第二次hash冲突的可能性。</p><p>![image-20240426133627889](&#x2F;images&#x2F;Paper Notes&#x2F;GI&#x2F;GI-1.0 A Fast Scalable Two-Level Radiance Caching Scheme for Real-Time Global Illumination.assets&#x2F;image-20240426133627889.png)</p><p>作者构建的顶点描述包含：</p><ul><li>顶点坐标、光线方向：邻近顶点间的重用与filter</li><li>层级：</li><li>光线长度与cell_size的比较结果</li></ul><p>每个cell还会关联一个衰减值decay，用于管理cell entry的生命周期。在每次访问cell时都会重置decay，否则就会持续衰减，如果一个cell的decay到0，则释放cell entry。hash table的主要瓶颈来自于大量使用atomic，例如每次插入，这可以通过存储下来顶点的查找结果来避免。</p><h3 id="2-2-2-Eliminating-Light-Leaks"><a href="#2-2-2-Eliminating-Light-Leaks" class="headerlink" title="2.2.2 Eliminating Light Leaks"></a>2.2.2 Eliminating Light Leaks</h3><p>在与周围顶点进行filter时，会存在light leaking异常效果，如下图所示情况。遮挡边缘的两个相邻顶点，离得近，同时secondary ray的方向接近评选，导致descriptor经过hash后落入同一cell。这种情况下，相邻顶点的filter会导致漏光</p><img src="/images/Paper Notes/GI/GI-1.0 A Fast Scalable Two-Level Radiance Caching Scheme for Real-Time Global Illumination.assets/image-20240426140012373.png" alt="image-20240426140012373" style="zoom: 80%;"><p>作者发现这类light leaking大部分出现在次级光线长度小于要查找cell大小的情况下，也就是光线没有离开cell。对于此，向descriptor中加入比较结果 (ray_length &lt; cell_size)，可以避免这种情况发生。</p><h3 id="2-2-3-Prefiltering-Radiance"><a href="#2-2-3-Prefiltering-Radiance" class="headerlink" title="2.2.3 Prefiltering Radiance"></a>2.2.3 Prefiltering Radiance</h3><p>cell之间filter需要访问 3x3x3 相邻cell，但在hash space的开销非常大。作者提出 two-level 数据结构，其中 cell 被组织到 tile 内，bucket 中索引的是tile，cell由tile内的局部坐标来索引，如下图所示。</p><p>![image-20240426145746727](&#x2F;images&#x2F;Paper Notes&#x2F;GI&#x2F;GI-1.0 A Fast Scalable Two-Level Radiance Caching Scheme for Real-Time Global Illumination.assets&#x2F;image-20240426145746727.png)</p><p>每个tille表示了场景固定大小的区域，相当于一个比较大的voxel，但tile中的cell在三维空间下是相对稀疏的，同时小范围的表面接近于二维平面，因此作者选择将cell投影到2D tile上的方式，将cell向最大outgoing方向的轴向投影。</p><blockquote><p> 最大outgoing方向应该是值tile内所有cell的所有光线方向取最大</p><p>tile 是一个超大的voxel，被hash table索引。cell是tile内连续的小voxel，按照局部位置连续排放。这也意味着tile需要更大的存储空间。对于 3x3x3 cells 的filter，如果没有这么多相邻cells呢？</p></blockquote><p>这种做法以不高的存储开销，使得tile之内相邻cell之间filter操作更加高效，但tile之间仍然无法解决，作者选择依赖于screen cache来掩盖这部分偏差。</p><p>将方差降低到可接受的水平通常需要cell内几帧的累积。对于时序累积，第一层 mip level 使用 exponential moving average <a href="#%5B4%5D">[4]</a> ，后续层级都是上一层级使用box filter。在实现中，作者选择 8x8 tile size，这样性能最佳。最终，通过查询第一层，累积radiance到screen cache。</p><h3 id="2-2-4-Evaluating-Lighting-at-Secondary-Path-Vertices"><a href="#2-2-4-Evaluating-Lighting-at-Secondary-Path-Vertices" class="headerlink" title="2.2.4 Evaluating Lighting at Secondary Path Vertices"></a>2.2.4 Evaluating Lighting at Secondary Path Vertices</h3><p>前面描述了如何在two-level hash数据结构中缓存和filter次级路径顶点的直接光照。但直接光照仍然需要计算。首先执行重投影，如果重投影成功则复用上一帧的光照；否则，需要计算顶点光照着色，这是 Light Sampling 小节的内容。</p><p>对于重用的上一帧radiance样本，既包含了直接光照，又包含了间接光照。这种重用会为当前帧带来多一次间接路径，近似无限反弹，称为 temporal radiance feedback。</p><blockquote><p>但cell中的顶点只有直接光照，并没有间接光照。从PPT里看到，这里的重投影是在屏幕上执行的，即将顶点重投影到上一帧，看是否在屏幕上，在屏幕上则重投影成功，否则重投影失败。也就是world cache本身无法做到无限反弹，只有屏幕上看到的顶点具有无限反弹。</p><p>无限反弹过程：</p><ul><li>第一帧<ul><li>screen probe光追得到hash cell顶点，hash cell计算一次反射点的直接光</li><li>screen probe从hash cell得到一次反射间接光</li><li>计算屏幕的直接光照，从screen probe得到的一次反射间接光</li></ul></li><li>第二帧<ul><li>screen probe光追得到hash cell顶点<ul><li>hash cell顶点重投影成功，得到其上一帧的直接光照与一次反射间接光。hash cell顶点作为一次反射点，意味着属于当前帧的一次反射间接光、二次反射间接光</li><li>hash cell顶点重投影失败，计算其直接光照，即一次反射间接光</li></ul></li><li>screen probe从hash cell得到间接光，此时融合了二次反射间接光</li><li>计算屏幕像素的直接光照，从screen probe采样间接光，这里采样得到的最多反射是二次反射</li></ul></li><li>第三帧：最大三次反射</li></ul><p>因此无限反弹只有部分cell顶点具有。</p></blockquote><h2 id="2-3-Light-Sampling"><a href="#2-3-Light-Sampling" class="headerlink" title="2.3 Light Sampling"></a>2.3 Light Sampling</h2><p>hit points 的着色</p><h3 id="2-3-1-Reservoir-based-Resampling"><a href="#2-3-1-Reservoir-based-Resampling" class="headerlink" title="2.3.1 Reservoir-based Resampling"></a>2.3.1 Reservoir-based Resampling</h3><h3 id="2-3-2-Light-Grid-Lookup-Structure"><a href="#2-3-2-Light-Grid-Lookup-Structure" class="headerlink" title="2.3.2 Light Grid Lookup Structure"></a>2.3.2 Light Grid Lookup Structure</h3><h2 id="2-4-Irradiance-Estimation"><a href="#2-4-Irradiance-Estimation" class="headerlink" title="2.4 Irradiance Estimation"></a>2.4 Irradiance Estimation</h2><p>本小节使用probe数据评估屏幕像素的 irradiance。</p><h3 id="2-4-1-Per-Pixel-Interpolation"><a href="#2-4-1-Per-Pixel-Interpolation" class="headerlink" title="2.4.1 Per-Pixel Interpolation"></a>2.4.1 Per-Pixel Interpolation</h3><p>使用像素周围的probe进行加权平均来重建像素光照。使用 2.1.5 小节定义的 <code>find_closest_probe</code> 函数查找四个方向上相邻probes，基于表面深度、normal的edge-aware function的权重设计。同样使用 cell_size 排除掉远离的probe，即赋予权重 0。</p><p>对于周围4个probe权重都为0或很小的情况，使用均值代替。</p><p>除此之外，在查找相邻probe之前，会先抖动像素位置，这样可以打破 structured artifact，但当抖动位置远离原像素所在平面时，则取消这次抖动。</p><h3 id="2-4-2-Spherical-Harmonics"><a href="#2-4-2-Spherical-Harmonics" class="headerlink" title="2.4.2 Spherical Harmonics"></a>2.4.2 Spherical Harmonics</h3><p>在评估irradiance时，通常需要提取所有附近的radiance样本。更好的方式是在插值之前，先将probe投影到SH，SH 具有以下优点：</p><ul><li>只使用前三阶可以过滤掉高频噪声</li><li>能够以低存储开销较好地表示 irradiance</li><li>reprojection pass 可以只重投影 SH</li></ul><h3 id="2-4-3-Denoising"><a href="#2-4-3-Denoising" class="headerlink" title="2.4.3 Denoising"></a>2.4.3 Denoising</h3><p>自适应blur</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a name="[1]">[1]</a> Boissé, G. and Meunier, S. 2022. GI-1.0: A Fast Scalable Two-Level Radiance Caching Scheme for Real-Time Global Illumination.</p><p><a name="[2]">[2]</a> Daniel Wright. 2021. Radiance Caching for Real-Time Global Illumination. <a href="https://advances.realtimerendering.com/s2021/index.html#_mrnver3hf0ag">https://advances.realtimerendering.com/s2021/index.html#_mrnver3hf0ag</a> </p><p><a name="[3]">[3]</a> Zina H. Cigolle, Sam Donow, Daniel Evangelakos, Michael Mara, Morgan McGuire, and Quirin Meyer. 2014. A Survey of Efficient Representations for Independent Unit Vectors. Journal of Computer Graphics Techniques (JCGT) 3, 2 (17 April 2014), 1–30. <a href="http://jcgt.org/published/0003/02/01/">http://jcgt.org/published/0003/02/01/</a> </p><p><a name="[4]">[4]</a> Brian Karis. 2014. HIGH-QUALITY TEMPORAL SUPERSAMPLING. <a href="http://advances.realtimerendering.com/s2014/#_HIGH-QUALITY_TEMPORAL_SUPERSAMPLING">http://advances.realtimerendering.com/s2014/#_HIGH-QUALITY_TEMPORAL_SUPERSAMPLING</a> </p><p><a name="[5]">[5]</a> Binder, N., Fricke, S., and Keller, A. 2021. Massively Parallel Path Space Filtering. </p>]]></content>
    
    
    <categories>
      
      <category>Paper Notes</category>
      
      <category>GI</category>
      
      <category>Light Probe</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Surface Light Cones - Sharing Direct Illumination for Efficient Multi-viewer Rendering</title>
    <link href="/2024/04/07/Paper%20Notes/Cloud%20Rendering/Surface%20Light%20Cones%20Sharing%20Direct%20Illumination%20for%20Efficient%20Multi-viewer%20Rendering/"/>
    <url>/2024/04/07/Paper%20Notes/Cloud%20Rendering/Surface%20Light%20Cones%20Sharing%20Direct%20Illumination%20for%20Efficient%20Multi-viewer%20Rendering/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Summary"><a href="#1-Summary" class="headerlink" title="1 Summary"></a>1 Summary</h1><p>直接光照与视角相关，无法直接缓存，但渲染方程中表面着色点的入射radiance与视角无关。基于此，这篇论文提出了一种基于cone的缓存表面入射radiance的方法——surface light cone。依靠这些cones来表示主要可见光源的投影，允许跨帧甚至同一场景内的多个相机之间复用入射radiance。</p><p>作者提出的 surface light cone 方法主要分为两部分：</p><ul><li>direct light 信息收集以及 cone 构建：使用光追对场景中光源进行随机采样，基于采样点到 surface point 的样本，不断更新其cone的radiance信息以及微调几何机构，以满足静态、动态场景下的DI收敛。</li><li>shading阶段采样 cone cache，使用 gbuffer 进行着色。着色过程近似为对每个 cone 的迭代采样累积。</li></ul><h1 id="2-Cone-based-Radiance-Caching"><a href="#2-Cone-based-Radiance-Caching" class="headerlink" title="2 Cone-based Radiance Caching"></a>2 Cone-based Radiance Caching</h1><p>一个cone使用一个方向 $D$ 与开口角度 $\alpha$，如下图所示。对于一个 surface point，使用多个 cones (通常为3个)来描述所有入射radiance信息。除了cone之外，作者还存储cone数量与累积数量用于radiance降噪。增大 cone 的最大数量可以提升对空间更精细地划分，从而提高这种抽象表示的精度。</p><img src="/images/Paper Notes/Cloud Rendering/Surface Light Cones Sharing Direct Illumination for Efficient Multi-viewer Rendering.assets/image-20240408133612290.png" alt="image-20240408133612290" style="zoom:67%;"><p>Surface Light Cone 方法实现在 <a href="#%5B2%5D">[2]</a> 提出的 effect-cache 系统中，位于 cache update stage，如下图所示。一个统一的更新为每个surface point执行，以构建cones。在最终着色阶段，从cones中采样并进行着色，与其它effect组合得到最终着色结果。</p><p>![image-20240408144341361](&#x2F;images&#x2F;Paper Notes&#x2F;Cloud Rendering&#x2F;Surface Light Cones Sharing Direct Illumination for Efficient Multi-viewer Rendering.assets&#x2F;image-20240408144341361.png)</p><h2 id="2-1-DI-Gathering-and-Cone-Construction"><a href="#2-1-DI-Gathering-and-Cone-Construction" class="headerlink" title="2.1 DI Gathering and Cone Construction"></a>2.1 DI Gathering and Cone Construction</h2><p>DI 信息收集与 cone 表示构建过程是本文所提方法最重要的一部分，该过程位于 cache update stage。cache update是以一定周期为每个可见的surface point执行的。当一个surface point变为可见时，它的每个周期开始于对已存储的cone 进行unpack，除非它的 cone 表示为空（新出现的surface point）。之后确定是否在更高细节级别 (LOD) 上存在该 surface point 的cache entry，如果存在则重用这些信息。</p><p>该过程被划分为两步：先将radiance信息加入到cone表示中；对于光源的移动，仅仅加入radiance到cache中是不够的，还需要处理移动过程中膨胀的cone，第二步则收缩cone。</p><h3 id="2-1-1-Incoming-Radiance-Updates"><a href="#2-1-1-Incoming-Radiance-Updates" class="headerlink" title="2.1.1 Incoming Radiance Updates"></a>2.1.1 Incoming Radiance Updates</h3><p>为了加入新的 radiance 到 cone 中，先随机采样场景光源，包括发光表面、解析面积光源以及environment map。采样数量与质量、效率要求有关，论文实验中选择 8 个样本，可以达到高帧率，同时由于时序累积，DI信息也可以保持准确。</p><p>对于每个样本，先通过光追确定surface point到采样点是否有直接可见（无遮挡）路径。之后只会将对surface point可见的采样点的radiance信息加入到cone结构中。实际中，surface point 可以长时间（相对于帧数而言）保持可见以及光源也会保持相对稳定，因此在没有动态改变被检测到时，光追样本数量可以逐渐减少，用以避免不必要的计算。</p><p>当得到一个新的入射radiance样本，将其加入到cone cache时，会面临四种不同的情况，对应四种不同的处理，如下图所示，</p><ul><li>A：新样本位于已存在cone之内，直接将样本radiance累积加入即可。否则，</li><li>B：如果已有cone数量未达到最大限制，则为新样本创建一个新的cone。否则，</li><li>C：如果新样本与距其最近的cone的夹角要小于cone之间的最小夹角，那么扩展该最近cone以将新样本包含其中。否则，</li><li>D：合并两个最近的cone，并为新样本创建一个新的cone。</li></ul><img src="/images/Paper Notes/Cloud Rendering/Surface Light Cones Sharing Direct Illumination for Efficient Multi-viewer Rendering.assets/image-20240408150858211.png" alt="image-20240408150858211" style="zoom:80%;"><p>可以看出，样本加入cone的过程包含了cone几何结构的更新以及radiance的累积。基于累积次数 $C$，累积更新过程如下<br>$$<br>L_{i,new} &#x3D; L_{i,old} \cdot (1-1&#x2F;C) + L_{i,sampled} * (1 &#x2F; C)<br>$$<br>在每个周期根据确切的样本来增加 $C$，仅在静态场景中有效。为了捕获动态改变，可以通过重置 $C$，但会导致信息丢失。作者发现在实践中，cone structure中的改变预示着场景发生了改变，因此一个cone改变了方向意味着影响其surface point的光照环境发生了变换。这时可以通过降低 $C$ 以加快新信息的吸收。作者使用 $\beta$ 来表示cone前一个方向与当前方向的夹角，当 $\beta$ 与 $C$ 超过一个小的阈值时，执行自适应更新<br>$$<br>C &#x3D; C &#x2F; \min(\max(1 + \beta \cdot 0.05, 1.01), 3.0)<br>$$</p><h3 id="2-1-2-Dynamic-Scene-Updates"><a href="#2-1-2-Dynamic-Scene-Updates" class="headerlink" title="2.1.2 Dynamic Scene Updates"></a>2.1.2 Dynamic Scene Updates</h3><p>在样本加入cone的过程中，cone总是执行扩展操作。对于动态改变，必须有方式能够自适应更新cone结构。以一个光源移动为例，如下图所示。在光源移动过程中，为了包含新的样本，cone可能会扩展的越来越大。因此，还需一个检测cone的哪些部分不再需要的方法。</p><img src="/images/Paper Notes/Cloud Rendering/Surface Light Cones Sharing Direct Illumination for Efficient Multi-viewer Rendering.assets/image-20240408164550421.png" alt="image-20240408164550421" style="zoom: 80%;"><p>作者通过在cone中采样一个偏离 opening angle 一定角度 $\varepsilon$ 的方向样本来检测是否有光源存在，基于opening angle的百分比来选择 $\varepsilon$ 。如果该样本击中一个光源，该样本被丢弃，cone在该方向上是准确的。如果没有光源被击中，则收缩cone。收缩过程如下图所示，首先确定有多少cone应该被收缩，<br>$$<br>\delta &#x3D; \alpha - \arccos(dot(D,s))<br>$$<br>其中 $\alpha$ 是cone开口角度，$D$ 是cone方向，$s$ 是样本方向。最终 $\alpha$ 收缩了 $\delta$ ，而 cone 向远离 $s$ 的方向旋转了 $\delta&#x2F;2$ 。</p><img src="/images/Paper Notes/Cloud Rendering/Surface Light Cones Sharing Direct Illumination for Efficient Multi-viewer Rendering.assets/image-20240408165535845.png" alt="image-20240408165535845"><h2 id="2-2-Shading"><a href="#2-2-Shading" class="headerlink" title="2.2 Shading"></a>2.2 Shading</h2><p>对于每个viewer，基于gbuffer中的材质信息与cache数据对像素进行着色。求解渲染方程则通过为每个cone采样 $nS$ 个样本，如下式<br>$$<br>L_o(x,\omega_o) &#x3D; L_e(x, \omega_o) + \sum_c^{nC}\sum_s^{nS}f_r(x,\omega_{i,c,s},\omega_o)\frac{L_{i,DI,SLC}(c)}{nS}(\omega_{i,c,s}\cdot n)<br>$$<br>其中，$nC$ 与 $nS$ 分别是 cone 的数量与样本的数量，$L_{i,DL,SLC}$ 是存储在surface light cone内的 radiance，而 $\omega_{i,c,s}$ 是采样方向。</p><p>作者使用 16 个样本达到高质量着色，注意这里的样本不需要求解visibility，因为在cone cache更新过程中考虑了 visibility，即只会加入可见的光源采样点的radiance信息。</p><blockquote><p>个人感觉 cone 还是一种 prefilter 思想。cone 中先累积了入射radiance，相当于把渲染方程被积函数 $L_i * f_r$ 的 $L_i$ 单独拿出来积分。</p></blockquote><h2 id="2-3-Cache-Compression"><a href="#2-3-Cache-Compression" class="headerlink" title="2.3 Cache Compression"></a>2.3 Cache Compression</h2><p>cone cache 的数据是以紧凑的方式存储。每个cone包括以下部分，共 91 bits：</p><ul><li>位于表面局部空间的方向（即TBN坐标系下），并转换为球坐标，使用 16-bit floats。球坐标应该是两个分量，共 32 bits</li><li>开口角度，使用 6-bit 定点数</li><li>radiance RGB，每个channel使用 18 bits。共 54 bits</li></ul><p>一个 surface point 会有多个 cone（文中为3个），累积计数 $C$ 使用 8 bits，cone数量使用 2 bits。因此一个 surface point 共需 $91\times 3+8+2&#x3D;283$ bits。作者使用 RGB32 的贴图格式，使用 3 个texel，有 2 bits 多余。</p><p>此外，在论文实验中，作者使用 cache bias 1.0，3 个 cones ，以及最初 8 个primary样本用于cache更新，之后便降为 1 个样本，除非检测到动态改变。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a name="[1]">[1]</a> Pascal Stadlbauer, Alexander Weinrauch, Wolfgang Tatzgern, and Markus Steinberger. 2023. Surface Light Cones: Sharing Direct Illumination for Efficient Multi-viewer Rendering. In <em>High-Performance Graphics - Symposium Papers</em>, 2023. The Eurographics Association.</p><p><a name="[2]">[2]</a> Alexander Weinrauch. 2023. Effect-based Multi-viewer Caching for Cloud-native Rendering. <em>siggraph</em> (2023).</p>]]></content>
    
    
    <categories>
      
      <category>Paper Notes</category>
      
      <category>Cloud Rendering</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SlabHash</title>
    <link href="/2024/01/07/Rendering%20Blogs/Graphics%20Basis/Projection%20Transformations/"/>
    <url>/2024/01/07/Rendering%20Blogs/Graphics%20Basis/Projection%20Transformations/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Summary"><a href="#1-Summary" class="headerlink" title="1 Summary"></a>1 Summary</h1><p>本文介绍投影变换的计算，包括正交投影、透视投影。最后介绍一些实际应用中的技巧、以及如何运用到 Vulkan 坐标系。</p><ul><li><p>Settings：本文的向量采用列向量，与 glm 库的默认为列主序一致，只需将本文描述的公式整体转置即可转为行向量形式；clip 空间的深度值范围采用与 OpenGL 的 $[-1,1]$ ；相机 forward 方向为 $-z$，up 方向为 $+y$ 。相机坐标系与正交投影的长方体视锥体 如下图所示：</p><img src="/images/Rendering Blogs/Graphics Basis/Projection Transformations.assets/image-20211125103026931.png" alt="image-20211125103026931" style="zoom: 33%;"></li></ul><p>其中 $l,r$ 为 $x$ 轴方向的左右表面到视锥体中心的距离，$b,t$ 为 $y$ 轴方向的上下表面到视锥体中心的距离，$n,f$ 为 $z$ 轴方向的前后表面到原点的距离(即近平面与远平面)。相机坐标系采用 Vulkan 的右手坐标系。注意：近平面 $n$ 并不是成像屏幕，只是裁剪平面，这个裁剪平面的大小由fov与近平面z值决定。</p><h1 id="2-Orthographic-Projection"><a href="#2-Orthographic-Projection" class="headerlink" title="2 Orthographic Projection"></a>2 Orthographic Projection</h1><p>正交投影将 $(-l,r)\times(-b,t)\times(-n,-f)$ 的视锥体变换为 $(-1,1)\times(-1,1)\times(-1,1)$。注意：<strong>通常情况下正交投影的视锥体定义为关于 $z$ 轴对称</strong>，即 $l&#x3D;r,b&#x3D;t$，在本文最后结果对应替换即可。正交投影的过程可分为两步：先将视锥体近平面的中心平移至相机坐标系的原点；再将大小进行缩放。</p><h2 id="2-1-视锥体的中心平移至原点"><a href="#2-1-视锥体的中心平移至原点" class="headerlink" title="2.1 视锥体的中心平移至原点"></a>2.1 视锥体的中心平移至原点</h2><p>视锥体中心坐标为 $\large \left(\frac{r-l}{2},\frac{t-b}{2},-\frac{n+f}{2}\right)$，因此构建平移矩阵<br>$$<br>M_{orthoT}&#x3D;<br>\begin{pmatrix}<br>1 &amp; 0 &amp; 0 &amp; \frac{l-r}{2} \<br>0 &amp; 1 &amp; 0 &amp; \frac{b-t}{2} \<br>0 &amp; 0 &amp; 1 &amp; \frac{n+f}{2} \<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix}<br>$$</p><blockquote><p>验证一下：对于左右表面的 $x$ 坐标，左表面 $x$ 坐标变换前 $-l$，有 $-l+\frac{l-r}{2}&#x3D;\frac{-l-r}{2}$ ；右表面 $x$ 坐标变换前 $r$，有 $r+\frac{l-r}{2}&#x3D;\frac{l+r}{2}$ 。变换后的 $x$ 坐标对称。</p><p>对于近平面，变换前 $-n$，有 $-n+\frac{n+f}{2}&#x3D;\frac{f-n}{2}$；对于远平面，变换前 $-f$，有 $-f+\frac{n+f}{2}&#x3D;\frac{n-f}{2}$</p></blockquote><h2 id="2-2-frustum-进行缩放"><a href="#2-2-frustum-进行缩放" class="headerlink" title="2.2 frustum 进行缩放"></a>2.2 frustum 进行缩放</h2><p>经过平移后的视锥体为 $(\frac{-l-r}{2},\frac{l+r}{2})\times(\frac{-b-t}{2},\frac{b+t}{2})\times(\frac{n-f}{2},\frac{f-n}{2})$，将平移后的视锥体缩放为<br> $(-1,1)\times(-1,1)\times(-1,1)$，构建缩放矩阵<br>$$<br>M_{orthoS}&#x3D;<br>\begin{pmatrix}<br>\frac{2}{l+r} &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; \frac{2}{b+t} &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; \frac{2}{f-n} &amp; 0 \<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix}<br>$$<br>至此就完成了构建正交投影矩阵<br>$$<br>M_{ortho} &#x3D; M_{orthoS} \cdot M_{orthoT}<br>$$</p><h1 id="3-Perspective-Projection"><a href="#3-Perspective-Projection" class="headerlink" title="3 Perspective Projection"></a>3 Perspective Projection</h1><p>透视投影为了模拟现实中近大远小，采用截去头部的金字塔形状的 frustum，如下图所示</p><img src="/images/Rendering Blogs/Graphics Basis/Projection Transformations.assets/image-20230917103045854.png" alt="image-20230917103045854" style="zoom: 50%;"><p>右图为左图的二维投影，透视投影的 frustum 是通过 fov 参数定义，所以是右图中过原点的情况，其中 $n,f$ 分别是近平面和远平面。</p><p>求解透视投影的投影矩阵可以分为两步：将透视投影的视锥体变形为正交投影的视锥体；再进行正交投影变换。</p><h2 id="3-1-frustum-视锥体挤压为长方体视锥体"><a href="#3-1-frustum-视锥体挤压为长方体视锥体" class="headerlink" title="3.1 frustum 视锥体挤压为长方体视锥体"></a>3.1 frustum 视锥体挤压为长方体视锥体</h2><h3 id="3-1-1-一般情况推导出变换矩阵的部分元素"><a href="#3-1-1-一般情况推导出变换矩阵的部分元素" class="headerlink" title="3.1.1 一般情况推导出变换矩阵的部分元素"></a>3.1.1 一般情况推导出变换矩阵的部分元素</h3><p>将 frustum 远平面四个角进行挤压，将远平面变形为与近平面一样大小。假设变形前 frustum 内任一点为 $(x,y,z)$，变形为 $(x’,y’,z’)$ 。变换前后的点有如下关系:</p><img src="/images/Rendering Blogs/Graphics Basis/Projection Transformations.assets/image-20211125194917924.png" alt="image-20211125194917924" style="zoom:50%;"><p>朝 $-x$ 方向看去的平面图，可以根据相似三角形有(注意使用边长)：<br>$$<br>\frac{y’}{y}&#x3D;\frac{-z’}{-z}&#x3D;\frac{n}{-z}<br>\<br> y’&#x3D;\frac{n}{-z}\cdot y<br>$$<br>同理，从 $-y$ 方向看去的平面图，可得到：<br>$$<br>\frac{x’}{x}&#x3D;\frac{n}{-z} \<br>x’&#x3D;\frac{n}{-z}\cdot x<br>$$<br>注意：对于 $z$ 变换前后是没有直观关系的，经过挤压变形 $z$ 坐标可能前移后移。</p><p>此时变换后的坐标为 $(\large \frac{n}{-z}\cdot x,\frac{n}{-z}\cdot y,z’,1)$ ，对于齐次坐标，同时乘上一个坐标，不改变其表示的点，同时乘 $-z$ 有：<br>$$<br>(nx,ny,-zz’,-z)<br>$$<br>假设 frustum 到长方体的变换矩阵为 $M_{persp-&gt;ortho}$，目前已知以下变换成立：<br>$$<br>M_{persp-&gt;ortho}\cdot (x,y,z,1)^T &#x3D;(nx,ny,-zz’,-z)^T<br>$$<br>有变换前后对应关系可知 $M_{persp-&gt;ortho}$ 的第一行可以确定为 $(n,0,0,0)$，第二行可以确定为 $(0,n,0,0)$，第三行未知，第四行可以确定为 $(0,0,-1,0)$。因此，此时<br>$$<br>M_{persp-&gt;ortho}&#x3D;<br>\begin{pmatrix}<br>n &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; n &amp; 0 &amp; 0 \<br>? &amp; ? &amp; ? &amp; ? \<br>0 &amp; 0 &amp; -1 &amp; 0<br>\end{pmatrix}<br>$$</p><h3 id="3-1-2-代入特殊点得到未知的-z-坐标变换"><a href="#3-1-2-代入特殊点得到未知的-z-坐标变换" class="headerlink" title="3.1.2 代入特殊点得到未知的 $z$ 坐标变换"></a>3.1.2 代入特殊点得到未知的 $z$ 坐标变换</h3><p>虽然任意点的 $z$ 坐标变换前后的对应关系不能直观看出，但是对于在近平面和远平面上的点，其 $z$ 坐标变换前后不改变，因此有 $z’&#x3D;z&#x3D;-n$。代入近平面，将 $z’&#x3D;z&#x3D;-n$ 代入得到变换前的点有 $(x,y,-n,1)$，变换后的点有 $(nx,ny,-n^2,n)$。因此有<br>$$<br>M_{persp-&gt;ortho}\cdot (x,y,-n,1)^T&#x3D;(nx,ny,-n^2,n)^T<br>$$<br>由变换前后的 $z$ 坐标对应关系，有 $M_{persp-&gt;ortho}$ 的第三行前两个元素为 $0$，假设后两个元素为 $C,D$，可以列<br>$$<br>-Cn+D&#x3D;-n^2<br>$$<br>代入远平面，将 $z’&#x3D;z&#x3D;-f$ 代入得到变换前的点有 $(x,y,-f,1)$ ，变换后的点有 $(nx,ny,-f^2,f)$。因此有<br>$$<br>M_{persp-&gt;ortho}\cdot (x,y,-f,1)^T&#x3D;(nx,ny,-f^2,f)^T<br>$$<br>可以列<br>$$<br>-Cf+D&#x3D;-f^2<br>$$<br>于是有 $C&#x3D;n+f,D&#x3D;nf$，于是 frustum 变形为长方体的变换矩阵为：<br>$$<br>M_{persp-&gt;ortho}&#x3D;<br>\begin{pmatrix}<br>n &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; n &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; n+f &amp; nf \<br>0 &amp; 0 &amp; -1 &amp; 0<br>\end{pmatrix}<br>$$</p><h2 id="3-2-完整的投影变换矩阵"><a href="#3-2-完整的投影变换矩阵" class="headerlink" title="3.2 完整的投影变换矩阵"></a>3.2 完整的投影变换矩阵</h2><p>$$<br>\begin{align} M_{persp} &amp;&#x3D; M_{ortho}\cdot M_{persp-&gt;ortho}&#x3D;M_{orthoS} \cdot M_{orthoT}\cdot M_{persp-&gt;ortho} \<br>&amp;&#x3D;\begin{pmatrix}<br>\frac{2}{l+r} &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; \frac{2}{b+t} &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; \frac{2}{f-n} &amp; 0 \<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix} \cdot<br>\begin{pmatrix}<br>1 &amp; 0 &amp; 0 &amp; \frac{l-r}{2} \<br>0 &amp; 1 &amp; 0 &amp; \frac{b-t}{2} \<br>0 &amp; 0 &amp; 1 &amp; \frac{n+f}{2} \<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix} \cdot<br>\begin{pmatrix}<br>n &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; n &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; n+f &amp; nf \<br>0 &amp; 0 &amp; -1 &amp; 0<br>\end{pmatrix} \<br>&amp;&#x3D; \begin{pmatrix}<br>\frac{2}{l+r} &amp; 0 &amp; 0 &amp; \frac{l-r}{l+r} \<br>0 &amp; \frac{2}{b+t} &amp; 0 &amp; \frac{b-t}{b+t} \<br>0 &amp; 0 &amp; \frac{2}{f-n} &amp; \frac{n+f}{f-n} \<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix} \cdot<br>\begin{pmatrix}<br>n &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; n &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; n+f &amp; nf \<br>0 &amp; 0 &amp; -1 &amp; 0<br>\end{pmatrix} \<br>&amp;&#x3D; \begin{pmatrix}<br>\frac{2n}{l+r} &amp; 0 &amp; -\frac{l-r}{l+r} &amp; 0 \<br>0 &amp; \frac{2n}{b+t} &amp; -\frac{b-t}{b+t} &amp; 0 \<br>0 &amp; 0 &amp; \frac{n+f}{f-n} &amp; \frac{2nf}{f-n} \<br>0 &amp; 0 &amp; -1 &amp; 0<br>\end{pmatrix}<br>\end{align}<br>$$</p><h3 id="3-2-1-使用-Fov-和-Aspect-简化投影矩阵"><a href="#3-2-1-使用-Fov-和-Aspect-简化投影矩阵" class="headerlink" title="3.2.1 使用 Fov 和 Aspect 简化投影矩阵"></a>3.2.1 使用 Fov 和 Aspect 简化投影矩阵</h3><p>fov 为相机在 $y$ 轴方向的视锥范围的角度，由于视锥通常取关于 $z$ 轴对称，$+y$ 轴部分视锥范围为 fov 的一半，如下图所示</p><img src="/images/Rendering Blogs/Graphics Basis/Projection Transformations.assets/image-20220705093400595.png" alt="image-20220705093400595" style="zoom: 50%;"><p>有<br>$$<br>\tan \frac{fov}{2}&#x3D;\frac{t}{n}, \quad t&#x3D;n\cdot \tan\frac{fov}{2}<br>$$<br>由于视锥关于 $z$ 轴对称有 $l&#x3D;r,t&#x3D;b$，aspect 为宽高比，即 $aspect &#x3D; \frac{r}{t}$，因此有<br>$$<br>\begin{cases}<br>\begin{align}<br>t&amp;&#x3D;b&#x3D;n\cdot \tan\frac{fov}{2} \<br>l&amp;&#x3D;r&#x3D;aspect\cdot n \cdot tan\frac{fov}{2}<br>\end{align}<br>\end{cases}<br>$$<br>代入矩阵 $M_{persp}$ 中有<br>$$<br>M_{persp}&#x3D;\begin{pmatrix}<br>\frac{1}{aspect\cdot \tan\frac{fov}{2}} &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; \frac{1}{\tan\frac{fov}{2}} &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; \frac{n+f}{f-n} &amp; \frac{2nf}{f-n} \<br>0 &amp; 0 &amp; -1 &amp; 0<br>\end{pmatrix}<br>$$</p><h2 id="3-3-对于深度范围为-0-1-的投影变换"><a href="#3-3-对于深度范围为-0-1-的投影变换" class="headerlink" title="3.3 对于深度范围为 [0,1] 的投影变换"></a>3.3 对于深度范围为 [0,1] 的投影变换</h2><p>Direct3D 与 Vulkan 的深度范围为 $[0,1]$，因此对应 clip space 的 view volume 为 $(-1,1)\times(-1,1)\times(0,1)$。因此需要修改正交投影变换：</p><ol><li><p>首先将视锥体的近平面中心点平移至原点，近平面中心点坐标为 $\large \left(\frac{r-l}{2},\frac{t-b}{2},-n\right)$<br>$$<br>M_{orthoT}&#x3D;<br>\begin{pmatrix}<br>1 &amp; 0 &amp; 0 &amp; \frac{l-r}{2} \<br>0 &amp; 1 &amp; 0 &amp; \frac{b-t}{2} \<br>0 &amp; 0 &amp; 1 &amp; n \<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix}<br>$$</p></li><li><p>然后缩放平移后的视锥体 $(\frac{-l-r}{2},\frac{l+r}{2})\times(\frac{-b-t}{2},\frac{b+t}{2})\times(0,-(f-n))$ 为 $(-1,1)\times(-1,1)\times(0,1)$<br>$$<br>M_{orthoS}&#x3D;<br>\begin{pmatrix}<br>\frac{2}{l+r} &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; \frac{2}{b+t} &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; -\frac{1}{f-n} &amp; 0 \<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix}<br>$$</p></li><li><p>最后的投影变换为<br>$$<br>\begin{align} M_{persp} &amp;&#x3D; M_{ortho}\cdot M_{persp-&gt;ortho}&#x3D;M_{orthoS} \cdot M_{orthoT}\cdot M_{persp-&gt;ortho} \<br>&amp;&#x3D;\begin{pmatrix}<br>\frac{2}{l+r} &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; \frac{2}{b+t} &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; -\frac{1}{f-n} &amp; 0 \<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix} \cdot<br>\begin{pmatrix}<br>1 &amp; 0 &amp; 0 &amp; \frac{l-r}{2} \<br>0 &amp; 1 &amp; 0 &amp; \frac{b-t}{2} \<br>0 &amp; 0 &amp; 1 &amp; n \<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix} \cdot<br>\begin{pmatrix}<br>n &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; n &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; n+f &amp; nf \<br>0 &amp; 0 &amp; -1 &amp; 0<br>\end{pmatrix} \<br>&amp;&#x3D; \begin{pmatrix}<br>\frac{2}{l+r} &amp; 0 &amp; 0 &amp; \frac{l-r}{l+r} \<br>0 &amp; \frac{2}{b+t} &amp; 0 &amp; \frac{b-t}{b+t} \<br>0 &amp; 0 &amp; -\frac{1}{f-n} &amp; -\frac{n}{f-n} \<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix} \cdot<br>\begin{pmatrix}<br>n &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; n &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; n+f &amp; nf \<br>0 &amp; 0 &amp; -1 &amp; 0<br>\end{pmatrix} \<br>&amp;&#x3D; \begin{pmatrix}<br>\frac{2n}{l+r} &amp; 0 &amp; -\frac{l-r}{l+r} &amp; 0 \<br>0 &amp; \frac{2n}{b+t} &amp; -\frac{b-t}{b+t} &amp; 0 \<br>0 &amp; 0 &amp; \frac{f}{n-f} &amp; \frac{nf}{n-f} \<br>0 &amp; 0 &amp; -1 &amp; 0<br>\end{pmatrix}<br>\end{align}<br>$$</p></li><li><p>代入 fov 与 aspect 简化有<br>$$<br>M_{persp}&#x3D;\begin{pmatrix}<br>\frac{1}{aspect\cdot \tan\frac{fov}{2}} &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; \frac{1}{\tan\frac{fov}{2}} &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; \frac{f}{n-f} &amp; \frac{nf}{n-f} \<br>0 &amp; 0 &amp; -1 &amp; 0<br>\end{pmatrix}<br>$$</p></li></ol><h2 id="3-4-透视投影非线性"><a href="#3-4-透视投影非线性" class="headerlink" title="3.4 透视投影非线性"></a>3.4 透视投影非线性</h2><p>透视投影具有非线性的性质，其非线性是由于最后的齐次坐标<strong>除以 $w$ 分量 (divide z)</strong> 引入的。这里我们只需关注 $w$ 分量的变换操作，因此只需关注透视投影矩阵变换的第四行。对于原坐标 $(x,y,z,1)$，经过透视变换后的 $w$ 分离由 $1$ 变为 $z$，即变换后的点为 $(x’,y’,z’,z)$。</p><ul><li><p>非线性带来的问题</p><p>顶点面片光栅化为像素的插值操作，是以三角面片在像素点的重心坐标为参数进行插值的，这个过程是线性过程。但由于投影变换引入了非线性，在三维空间线性变化的顶点属性，经过投影变换，在屏幕空间并不是线性变化，因此不能直接使用重心坐标进行顶点属性的插值。如下图所示：</p><img src="/images/Rendering Blogs/Graphics Basis/Projection Transformations.assets/image-20211125204304543.png" alt="image-20211125204304543" style="zoom:50%;"><p>三维空间的线 $AB$，投影到屏幕空间 $ab$。$ab$ 的中点对应的却不是 $AB$ 的中点。</p></li></ul><p>为了解决透视投影带来的非线性问题，插值引入了 <a href="https://www.comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf">perspective-correct interpolation</a>，目前 vertex shader 到 pixel shader 的变量，默认都为 perspective-correct interpolation。</p><h1 id="4-Practical-Tricks"><a href="#4-Practical-Tricks" class="headerlink" title="4 Practical Tricks"></a>4 Practical Tricks</h1><h2 id="4-1-w-分量归一化与-divide-z"><a href="#4-1-w-分量归一化与-divide-z" class="headerlink" title="4.1 $w$ 分量归一化与 divide z"></a>4.1 $w$ 分量归一化与 divide z</h2><p>在 shader 中，对坐标进行透视投影后进行齐次坐标 $w$ 分量归一化时，除以 $w$ 和除以 $z$ 分量都一样，因为透视投影得到的 $w$ 分量与 $z$ 恒有 $w&#x3D;z$ （或 $w&#x3D;-z$，依赖于推导过程）。</p><h2 id="4-2-屏幕空间的像素坐标到相机空间的逆变换"><a href="#4-2-屏幕空间的像素坐标到相机空间的逆变换" class="headerlink" title="4.2 屏幕空间的像素坐标到相机空间的逆变换"></a>4.2 屏幕空间的像素坐标到相机空间的逆变换</h2><p>在某些算法中，经常需要从屏幕像素坐标恢复到相机空间的坐标。</p><ul><li><p>在 pixel shader 中进行逆投影变换（低效）</p><p>使用透视投影的逆矩阵可以直接做到，如</p></li></ul><p>$$<br>inverse(M_{persp})\cdot (clip.x,clip.y,clip.z)<br>$$</p><ul><li><p>vertex shader 中进行 $(x,y)$ 逆变换，pixel shader 中进行 depth 逆变换（高效）</p><p>直接在 pixel shader 中进行逆投影变换，较为低效，可以在 vertex shader 中计算。对于具有顶点输入的 pass，vertex shader 中只进行 view transform，不进行透视变换，此时变换后的顶点还处于三维线性空间中，即变换后的 $w$ 分量还是 $1$，因此到 pixel shader 的插值还是线性插值。</p><p>多数情况是 postprocess 的算法，vertex shader 只是 quad 绘制，没有顶点信息。可以在 vertex shader 中 quad 绘制得到的 texcoord 坐标进行逆透视投影，转到 view space 中，此时只需要传逆变换后的 $( x,y)$ 坐标到 pixel shader。在 pixel shader 中，只将 depth 信息变换回 view space。只是 depth 的逆变换，不需要对整个透视投影进行求逆。变换前点为 $(x,y,z,1)$，有投影变换（使用深度范围 [0,1] 的投影变换）：</p></li></ul><p>$$<br>\begin{align}<br>M_{persp}\cdot (x,y,z,1)^T &amp;&#x3D;\begin{pmatrix}<br>\frac{1}{aspect\cdot \tan\frac{fov}{2}} &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; \frac{1}{\tan\frac{fov}{2}} &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; \frac{f}{n-f} &amp; \frac{nf}{n-f} \<br>0 &amp; 0 &amp; -1 &amp; 0<br>\end{pmatrix} \cdot (x,y,z,1)^T \<br>&amp;&#x3D;\left(\frac{x}{aspect\cdot \tan\frac{fov}{2}}, \frac{y}{\tan\frac{fov}{2}}, \frac{f\cdot z + nf}{n-f}, -z\right)^T<br>\end{align}<br>$$</p><p>​即变换后的像素深度$0&lt;n&lt;f,-f&lt;z&lt;-n&lt;0,0&lt;clip.z&lt;1$<br>$$<br>\begin{align}<br>clip.z &amp;&#x3D; \frac{f\cdot z + nf}{n-f}\cdot \frac{1}{-z} &#x3D; \frac{f\cdot (z+n)}{z\cdot(f-n)} &#x3D; (1+\frac{n}{z})\cdot \frac{1}{1-\frac{n}{f}} &#x3D; (1-\frac{n}{-z})\cdot \frac{1}{1-\frac{n}{f}} \<br>z &amp;&#x3D;\frac{-nf}{(n-f)clip.z+f}<br>\end{align}<br>$$<br>​pixel shader 中只需要进行上式对 $z$ 的逆变换，即 <strong>Linearize Depth</strong>。</p><ul><li><p>pixel shader中进行逆投影变换<br>通过矩阵变换可以求都逆投影矩阵 $InvM_{persp}$，逆投影变换有<br>$$<br>\begin{align}<br>&amp; \quad InvM_{persp} \cdot (clip.x, \space clip.y, \space clip.z, \space 1)^T \<br>&amp;&#x3D; \begin{pmatrix}<br>aspect\cdot \tan\frac{fov}{2} &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; \tan\frac{f}{2} &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; 0 &amp; -1 \<br>0 &amp; 0 &amp; \frac{n-f}{nf} &amp; \frac{1}{n}<br>\end{pmatrix} \cdot  (clip.x, \space clip.y, \space clip.z, \space 1)^T \<br>&amp;&#x3D; (aspect\cdot \tan\frac{fov}{2}\cdot clip.x, \space \tan\frac{fov}{2}\cdot clip.y, \space -1, \space \frac{(n-f)clip.z+f}{nf}) \<br>&amp;&#x3D; (aspect\cdot \tan\frac{fov}{2}\cdot clip.x, \space \tan\frac{fov}{2}\cdot clip.y, \space -1, \space -\frac{1}{z}) \<br>&amp;&#x3D; (-z\cdot aspect\cdot \tan\frac{fov}{2}\cdot clip.x, \space -z \cdot \tan\frac{fov}{2}\cdot clip.y, \space z, \space 1)<br>\end{align}<br>$$<br>可以看出最后一步除w分量，除得是 $\Large -\frac{1}{z}$。由于是线性变换，因此可以先乘上 $-z$ 避免最后一步除w，即要进行逆变换的坐标为<br>$$<br>(-z\cdot clip.x, \space -z\cdot clip.y, \space -z\cdot clip.z, \space -z \cdot 1)<br>$$</p><blockquote><p>注意，如果只取结果xyz分量，最后一个分量乘不乘没有影响，因为 w 分量除了规范化三维坐标没有其他作用，不乘也只是最后得到的 w 分量不是 1 而已</p></blockquote></li></ul><h2 id="4-3-像素抖动偏移"><a href="#4-3-像素抖动偏移" class="headerlink" title="4.3 像素抖动偏移"></a>4.3 像素抖动偏移</h2><p>$$<br>\begin{align}<br>M_{persp}\cdot (x,y,z,1)^T &amp;&#x3D;\begin{pmatrix}<br>\frac{1}{aspect\cdot \tan\frac{fov}{2}} &amp; 0 &amp; jitter_x &amp; 0 \<br>0 &amp; \frac{1}{\tan\frac{fov}{2}} &amp; jitter_y &amp; 0 \<br>0 &amp; 0 &amp; \frac{f}{n-f} &amp; \frac{nf}{n-f} \<br>0 &amp; 0 &amp; -1 &amp; 0<br>\end{pmatrix} \cdot (x,y,z,1)^T \<br>&amp;&#x3D;\left(\frac{x}{aspect\cdot \tan\frac{fov}{2}} + z\cdot jitter_x, \frac{y}{\tan\frac{fov}{2}}+z\cdot jitter_y, \frac{f\cdot z + nf}{n-f}, -z\right)^T<br>\end{align}<br>$$</p><p>最后除w得到clip pos，则得到 clip.x 与 clip.y 的偏移量为 $(-jitter_x, -jitter_y)$，因此像素内的抖动值取值范围是 [-1, 1] &#x2F; resolution</p><h1 id="5-任意z处的投影"><a href="#5-任意z处的投影" class="headerlink" title="5 任意z处的投影"></a>5 任意z处的投影</h1><p>视锥体每个面的法向量如下图所示，而这些法向量也比较容易得到。首先考虑，投影变换后的  $(-1,1)\times(-1,1)\times(-1,1)$ ，可以得到六个平面方程为<br>$$<br>x &#x3D; \pm1, y &#x3D; \pm 1,z &#x3D; \pm 1<br>$$<br>将这六个平面法向量代入透视投影逆变换即可。</p><img src="/images/Rendering Blogs/Graphics Basis/Projection Transformations.assets/image-20230917145603222.png" alt="image-20230917145603222" style="zoom: 50%;"><p>只考虑关于z轴对称的视锥体，因此有 $\vec{l},\vec{r}$ 与 xoz 面平行，$\vec{b},\vec{t}$ 与yoz面平行，$\vec{n}&#x3D;(0, 0, 1), \vec{f}&#x3D;(0, 0, -1)$。</p><p>只看 xoz 面，如下俯视图</p><img src="/images/Rendering Blogs/Graphics Basis/Projection Transformations.assets/image-20230917153537979.png" alt="image-20230917153537979" style="zoom:50%;"><p>可以得到<br>$$<br>\tan\alpha_0&#x3D;\frac{r.z}{r.x}<br>$$<br>对于yoz面，如下侧视图</p><img src="/images/Rendering Blogs/Graphics Basis/Projection Transformations.assets/image-20230917153610395.png" alt="image-20230917153610395" style="zoom:50%;">$$\tan\alpha_1=\frac{t.z}{t.y}$$那么，在 $z_i$ 处的截面宽、高为$$w_i = 2 \cdot z_i \cdot \frac{1}{\tan\alpha_0} \\h_i = 2 \cdot z_i \cdot \frac{1}{\tan\alpha_1}$$至此，我们可以得到视锥体任意截面的大小，这意味着，我们可以将屏幕空间的像素大小逆投影到任意远的截面上。相同的像素大小，在越远的截面上对应区域则越大。<p>截面位于世界空间，截面的尺度是实际的几何大小，因此假设几何半径 $R_g$，不同尺度间的变换可以通过标准化的中间量 $R_n$，屏幕空间的尺度单位为像素 $R_p$。</p><p>因此，投影过程：将 $z_i$ 处的几何半径标准化，再将标准化的半径转为屏幕空间有<br>$$<br>\begin{align}<br>R_{n_x} &amp;&#x3D; R_g \cdot \frac{1}{w_i} &#x3D; 0.5 \cdot R_g \cdot \tan\alpha_0 \cdot \frac{1}{z_i} \<br>R_{n_y} &amp;&#x3D; R_g \cdot \frac{1}{h_i} &#x3D; 0.5 \cdot R_g \cdot \tan\alpha_1 \cdot \frac{1}{z_i} \<br>\<br>R_{p} &amp;&#x3D; screenWidth \cdot R_{n_x} \quad or \<br>R_{p} &amp;&#x3D; screenHeight \cdot R_{n_y}<br>\end{align}<br>$$<br>逆投影过程：将屏幕空间半径（以像素为单位）先标准化，再转为世界空间的几何半径有<br>$$<br>\begin{align}<br>R_{n_x} &amp;&#x3D; R_{p} * 1.0 &#x2F; screenWidth \<br>R_{n_y} &amp;&#x3D; R_{p} * 1.0 &#x2F; screenHeight \<br>\<br>R_g &amp;&#x3D; R_{n_x} * w_i &#x3D; R_{n_x} * 2.0 * z_i * \frac{1}{\tan\alpha_0} \quad or\<br>R_g &amp;&#x3D; R_{n_y} * w_i &#x3D; R_{n_y} * 2.0 * z_i * \frac{1}{\tan\alpha_1}<br>\end{align}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>Rendering Blogs</category>
      
      <category>Graphics</category>
      
      <category>Projection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Path Space Filtering</title>
    <link href="/2023/12/15/Paper%20Notes/Ray%20Tracing/Path%20Space%20Filtering/"/>
    <url>/2023/12/15/Paper%20Notes/Ray%20Tracing/Path%20Space%20Filtering/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Summary"><a href="#1-Summary" class="headerlink" title="1 Summary"></a>1 Summary</h1><p>本文提出一种在path space对着色点平滑邻近区域的光线路径的算法，提高光线传播的蒙特卡洛追踪过程的效率。提出的平滑算法基于光子映射框架，采样着色点附近的光线路径，并基于几何、材质、可见性等方面的相似性设计平滑权重。</p><h1 id="2-Background"><a href="#2-Background" class="headerlink" title="2 Background"></a>2 Background</h1><h2 id="2-1-Particle-Tracing"><a href="#2-1-Particle-Tracing" class="headerlink" title="2.1 Particle Tracing"></a>2.1 Particle Tracing</h2><p>particle tracing算法从光源出发，进行追踪，与表面相交时在交点放置能量，然后再进行反射。与之相对的是path tracing，从相机出发，为每个像素采样光线样本。particle tracing算法生成一批样本，表示一点 $p_j$ 收到来自方向 $\omega_j$ 的throughput weight $\beta_j$ 如下所示<br>$$<br>(p_j, \omega_j, \beta_j)<br>$$<br>其中，$\beta_j$ 为throughput与采样概率密度的比值，这个采样概率密度指的是? :confused: 。</p><blockquote><p>throughput与flux&#x2F;功率类似，但不是物理量，指的是某一时刻光子携带的能量，例如经过一次反射后会乘上BSDF系数，相当于scaled radiance。那么 $\beta_j$ 也就是 $f\cdot radiance &#x2F; pdf&#x3D;f\cdot L_i &#x2F; p$ 正好是蒙特卡洛积分的重要性采样形式。</p></blockquote><p>基于tracing阶段得到的particle，我们可以计算任意测量的估计。测量量使用重要性函数 $W_e(p,\omega)$ 来描述，$W_e$应该满足测量量的定义与估计量之间的无偏，<br>$$<br>E\left[\frac{1}{N}\sum_{j&#x3D;1}^N\beta_jW_e(p_k,\omega_j)\right]&#x3D;\int_A\int_{S^2}W_e(p,\omega)L_i(p,\omega)|\cos\theta|\space \mathrm{d}\omega \mathrm{d}A \label{importance-func} \tag{1}<br>$$</p><p>其实就是将半球面上的积分再嵌套一层表面上点的积分，最外层嵌套 ($\mathrm{d}A$) 就是为了对所有粒子上的测量，而内层 ($\mathrm{d}\omega$) 是在着色点半球面内的测量，可以理解为粒子框架下的渲染方程。</p><h3 id="2-1-1-例子：测量墙的入射通量"><a href="#2-1-1-例子：测量墙的入射通量" class="headerlink" title="2.1.1 例子：测量墙的入射通量"></a>2.1.1 例子：测量墙的入射通量</h3><p>以测量一面墙入射的通量为例，该通量定义如下<br>$$<br>\Phi &#x3D; \int_{A_{wall}}\int_{H^2(\mathbf{n})}L_i(p,\omega)|\cos\theta|\space \mathrm{d}A\mathrm{d}\omega<br>$$<br>对于该测量可以定义如下重要性函数，用来选取位于墙上并且来自normal方向定义的半球区域的入射部分：<br>$$<br>W_e(p,\omega)&#x3D;\begin{cases}\begin{align}<br>&amp; 1 \quad \quad \text{p is on wall and } (\omega\cdot \mathbf{n}) &gt; 0\<br>&amp; 0 \quad \quad otherwise<br>\end{align}\end{cases}<br>$$</p><p>如果 $\eqref{importance-func}$ 式满足，那么上述测量量就可以使用粒子加权和形式来估计。如果想要测量另一面墙 (或者墙的一部分) 的通量，我们可以重新定义 $W_e$，只需要重新计算粒子的加权和即可，粒子可以重复利用。</p><h2 id="2-2-Photon-Mapping"><a href="#2-2-Photon-Mapping" class="headerlink" title="2.2 Photon Mapping"></a>2.2 Photon Mapping</h2><p>为了计算 $p$ 点在 $\omega_o$ 方向上反射的radiance，可以等价地表示为对场景表面的所有点的测量，其中Dirac delta分布仅选择精确在 $p$ 点处的粒子，如下式<br>$$<br>\int_{S^2}L_i(p,\omega_i)f(p,\omega_o,\omega_i)|\cos\theta_i|\space\mathrm{d}\omega_i &#x3D; \int_A\int_{S^2}\delta(p-p’)L_i(p’,\omega_i)f(p’,\omega_o,\omega_i)|\cos\theta_i|\space\mathrm{d}\omega_i\mathrm{d}A(p’) \label{exit-radiance} \tag{2}<br>$$<br>左边是 $p$ 点处的渲染方程，右边是一种转为对表面点积分的等价表示。按照 $\eqref{importance-func}$ 式，可以得到描述测量量的重要性函数<br>$$<br>W_e(p’,\omega)&#x3D;\delta(p’-p)f(p,\omega_o,\omega_i) \label{pm-importance-func} \tag{3}<br>$$<br>光子映射引入的有偏近似：基于附近点的光照信息可以看作着色点的照明的合理近似的假设，提出在着色点周围的光子中进行插值来提供着色点接收的光照信息。因此，$\eqref{pm-importance-func}$ 式的delta分布可以替换为一种filter函数。</p><h3 id="2-2-1-光子映射算法"><a href="#2-2-1-光子映射算法" class="headerlink" title="2.2.1 光子映射算法"></a>2.2.1 光子映射算法</h3><p>光子映射是一种particle tracing算法，其过程是2-pass算法：</p><ol><li>light pass：光源发出光子，光子与表面相交的信息存储在kd-tree结构上（光子贴图）。存储的信息用于后面的着色，包括光子位置、方向以及throughput。</li><li>camera pass：由相机出发的光路，光路顶点即为着色点。每个光路顶点在光子贴图中查找其周围的光子信息，进行加权着色。</li></ol><p>光子映射的优点：光子可以被重用以及开销容易被分摊；着色点使用附近的光子提供光照，更容易解决无偏算法 (例如path tracing、BDPT等) 中无法基于增量路径构建的路径采样问题。例如如下场景，针孔相机与场景之间有一块能折射光线的玻璃板，以及场景中的点光源。没有能够采样到一个能够到达点光源的入射方向的采样策略。但光子映射可以通过追踪由光源出发后在diffuse表面沉淀的光子，着色点附近的光子可以用来很好地估算照明。</p><blockquote><p>传统的path tracing选择与点光源直接相连，但中间光路会由于折射被改变，会导致这样采样得到的方向并不能到达光源。还要在求交后再进行调整，调整后再求交。</p></blockquote><img src="/images/Paper Notes/Ray Tracing/Path Space Filtering.assets/image-20231217201735872.png" alt="image-20231217201735872" style="zoom:50%;"><h3 id="2-2-2-Density-Estimation"><a href="#2-2-2-Density-Estimation" class="headerlink" title="2.2.2 Density Estimation"></a>2.2.2 Density Estimation</h3><p>使用着色点附近的光子进行照明的一个统计方法density estimation：即先假设这些样本来自同一个总体分布，构造该组样本点的概率密度函数(PDF)。比如直方图这一简单例子，1D情况下可以划分等宽区间，然后计算每个区间的样本数量，最后进行归一化得到概率密度。</p><p><strong>kernel method</strong></p><p>kernel method可以得到更加平滑的PDF，给定核函数(kernel function) $k(x)$，有 $\int_{-\infin}^{+\infin} k(x)\mathrm{d}x &#x3D; 1$。对于 $N$ 个样本，在$x_i$ 处的的核估计量(kernel estimator)为<br>$$<br>\hat{p}(x)&#x3D;\frac{1}{Nh}\sum_{i&#x3D;1}^N k\left(\frac{x-x_i}{h}\right) \label{kernel-estimator} \tag{4}<br>$$<br>其中，$h$ 是窗口大小(window width)（或者平滑参数、kernel bandwidth）。给定 $N$ 个样本，核估计就是在每个样本上应用核估计函数，然后将这些核函数值加起来形成整体的密度估计。下图就是1D下应用 Epanechnikov kernel 的示例，核函数为<br>$$<br>k(t) &#x3D;<br>\begin{cases}<br>0.75(1-2t^2)&#x2F;\sqrt{5}, \quad t &lt; \sqrt{5} \<br>0,\quad  otherwise<br>\end{cases}<br>$$<br>图中每条圆弧形虚曲线都对应在某一点处的核估计，所有核估计形成实线形状的整体密度估计</p><img src="/images/Paper Notes/Ray Tracing/Path Space Filtering.assets/image-20231224143050504.png" alt="image-20231224143050504" style="zoom: 33%;"><h3 id="2-2-3-nth-nearest-neighbor-estimate"><a href="#2-2-3-nth-nearest-neighbor-estimate" class="headerlink" title="2.2.3 nth nearest neighbor estimate"></a>2.2.3 nth nearest neighbor estimate</h3><p>kernel method的关键问题是 $h$ 的选取，太宽会模糊具有许多样本的区域的相关细节；太窄会导致PDF在尾部的分布由于样本不够而凹凸不平。Nearest-neighbor 基于局部样本密度来自适应选择窗口大小，附近样本越多，窗口越小；反之，窗口越大。</p><p>nth nearest neighbor estimate 选择 $Nth$ nearest 样本到估计点 $x$ 的距离 $d_N(x)$ 作为窗口大小，代入到 $\eqref{kernel-estimator}$ 有<br>$$<br>\hat{p}(x)&#x3D;\frac{1}{Nd_N(x)}\sum_{i&#x3D;1}^Nk\left(\frac{x-x_i}{d_N(x)}\right)<br>$$<br>扩展到 $d$ 维，有<br>$$<br>\hat{p}(x)&#x3D;\frac{1}{N(d_N(x))^d}\sum_{i&#x3D;1}^Nk\left(\frac{x-x_i}{d_N(x)}\right) \label{density-estimate} \tag{5}<br>$$<br>将密度估计代入到 $p$ 点在出射方向 $\omega_o$ 上的出射radiance测量 $\eqref{exit-radiance}$ ，能够得到以下估计量<br>$$<br>L_o(p, \omega_o) \approx \frac{1}{N_p(d_N(p))^2}\sum_{j&#x3D;1}^{N_p}k\left(\frac{p-p_j}{d_N(p)}\right)\beta_jf(p,\omega_o,\omega_j) \label{exit-radiance-pm} \tag{6}<br>$$<br>其中 $N_p$ 表示光子数量，重要性函数使用密度估计方程代替，同时对于超出 N nearest距离的采样点，核函数为0。这个估计过程是先在 $p$ 点的 tangent plane 上采样一点 $p_j$ (即内层积分的 $p’$)，因此这里的密度估计是2维。如前所述，$\beta_j$ 是 $p$ 在入射方向 $\omega_j$ 收到的 throughput与采样概率密度（渲染方程积分的采样）的比值。注意观察与标准渲染方程积分估计的区别：</p><ul><li>渲染方程积分采样点永远是着色点，而这里近似为了着色点附近区域以某一密度估计下的采样点。这是一种着色点邻近区域的插值过程。</li><li>如果将着色点附近区域内的采样改为（着色点处为1，其余为0）的分布，上式恰好可以退化为渲染方程</li></ul><p>$\eqref{exit-radiance-pm}$​ 在光子上的测量是一种插值过程，该过程引入的偏差难以估计，但通过提高光子密度往往可以得到更好的结果。如果直接光照使用传统方式，而对于更加低频的间接光通常问题不大。</p><blockquote><p> $\eqref{exit-radiance-pm}$ 式过程的理解，$\eqref{exit-radiance-pm}$ 是对以下积分的近似：<br>$$<br>\int_{S^2}L_i(p,\omega_i)f(p,\omega_o,\omega_i)|\cos\theta_i|\space\mathrm{d}\omega_i &#x3D; \int_A\int_{S^2}\hat{p}(p’)L_i(p’,\omega_i)f(p’,\omega_o,\omega_i)|\cos\theta_i|\space\mathrm{d}\omega_i\mathrm{d}A(p’)<br>$$<br>particle tracing与path tracing的不同，导致二者在求渲染方程积分上不同</p><ul><li>path tracing：从着色点出发，采样不同的光线，对光线交点着色得到光线方向上的入射radiance。光线相交于表面后，再采样下一级反射方向，递归执行。</li><li>particle tracing：从光源出发，</li></ul><p>每个光子携带了其从光源传播到当前位置整条光路累积后的 $f \cdot radiance &#x2F; pdf$。光子映射本质上是采样着色点周围的光子，作为着色点的近似，是一种filter过程。因此渲染方程则近似为了对光子的加权平均，权重与光子的分布有关</p><p>从上式积分形式看，外层是对表面上（着色点附近）光子的积分，而内层积分则是对于光子 $p’$ 的 $\beta$ 积分。</p></blockquote><p>[2.2.1 光子映射算法](#2.2.1 光子映射算法) 小节描述的最初形式的光子映射算法先进行光子生成，存放到光子贴图上；再进行测量过程。这会导致光子数量受存储空间限制，当存储耗尽时，质量就无法再进一步提高，限制了算法上限。</p><h2 id="2-3-Progressive-Photon-Mapping-PPM"><a href="#2-3-Progressive-Photon-Mapping-PPM" class="headerlink" title="2.3 Progressive Photon Mapping (PPM)"></a>2.3 Progressive Photon Mapping (PPM)</h2><p>PPM算法重构了最初形式的光子映射，避免光子存储带来的限制，同样也是2-pass算法：</p><ul><li>camera pass：追踪从相机出发的光路，直至第一个diffuse表面，记录下来交点(visible point)几何信息以及漫反射，同时累积光路经过的specular表面的BSDF。</li><li>light pass：从光源发出光子光路(多级)，每一级光子与表面的相交时，都会向其周围的visible points贡献radiance估计</li></ul><p>这种方法不需要存储光子，只需要存储camera pass得到的visible point，这部分要远小于记录场景的光子贴图。但对于高分辨率以及需要高SPP的情况下，存储开销依然较高。</p><h2 id="2-4-Stochastic-Progressive-Photon-Mapping-SPPM"><a href="#2-4-Stochastic-Progressive-Photon-Mapping-SPPM" class="headerlink" title="2.4 Stochastic Progressive Photon Mapping (SPPM)"></a>2.4 Stochastic Progressive Photon Mapping (SPPM)</h2><p>SPPM对PPM进一步改进，做到不受内存限制的影响。SSPM依然是从camera pass出发，但其限制了每像素的采样数（可以低至1SPP），即visible points的存储固定；之后light pass同样是从光源出发，使用光子对周围visible points贡献radiance。不同的是，SPPM将这个过程迭代执行，使用同样的visible points存储达到高SPP的结果。</p><p>SPPM 同样基于 $\eqref{exit-radiance-pm}$ 光子估计方程出发，但存在两个调整。首先它使用常数核函数，估计过程发生在visible point的tangent平面，$p$ 点在 $\omega_o$ 方向的出射radiance估计量如下，<br>$$<br>L_o(p,\omega_o)\approx \frac{1}{N_p\pi r^2}\sum_j^{N_p}\beta_jf(p,\omega_o,\omega_j) \label{constant-estimate} \tag{6}<br>$$<br>其中，$N_p$ 是光源发出的光子数量；$\pi r^2$ 是盘形 (disk-shaped) 核函数的表面积。</p><p>第二个调整是每次迭代逐步减小光子的搜索半径。这种做法的总体想法是，随着搜索半径内发现的光子数量增多，会有更多证据表明足够的光子密度可以很好估计入射分布；通过减小半径，可以更偏向于细节保留。而当减小半径时，意味着累积的光子来自不同的半径范围，那么同样需要对此进行调整。下面的更新规则描述了如何更新半径以及依赖的变量：<br>$$<br>\begin{align}<br>N_{i+1} &amp;&#x3D; N_i + \gamma M_i \<br>r_{i+1} &amp;&#x3D; r_i\sqrt{\frac{N_{i+1}}{N_i+M_i}} \<br>\tau_{i+1} &amp;&#x3D; (\tau_i + \Theta_i)\frac{r^2_{i+1}}{r^2_i}<br>\end{align}<br>$$<br>其中，$N_i$ 是 i-th 迭代之前的贡献给着色点的光子总数；$M_i$ 是当前迭代贡献的光子数量；$r_i$ 是i-th迭代的搜索半径；$\gamma$ 是用于调整收缩速度的超参，通常选择 2&#x2F;3；$\tau$ 是BSDF的累积；$\Theta_i$ 在i-th迭代的计算如下，即当前迭代光子的throughput之和。<br>$$<br>\Theta_i &#x3D; \sum_j^{M_i}\beta_jf(p,\omega_o,\omega_j)<br>$$</p><h1 id="3-Approach"><a href="#3-Approach" class="headerlink" title="3 Approach"></a>3 Approach</h1><p>本文提出的path space filter算法过程如下图所示：绿色部分展示了通过filter顶点 $x_i$ 的球邻域 $\mathcal{B}(n)$ 中顶点收到的光路贡献 $c_{s_i+j}$ 来近似到 $x_i$ 的光路贡献 $c_i$ ，其中 $\alpha_i$ 为 $x_i$ 到相机方向的衰减系数。</p><img src="/images/Paper Notes/Ray Tracing/Path Space Filtering.assets/image-20240114173422688.png" alt="image-20240114173422688" style="zoom: 50%;"><p>图像上像素计算为累积 $\alpha_i\cdot \bar{c_i}$，即累积每根采样光线<br>$$<br>\bar{c_i} &#x3D; \frac{\sum_{j&#x3D;0}^{b^m-1} \mathcal{X}<em>{\mathcal{B}(n)}(x</em>{s_i+j} - x_i) \cdot w_{i,j} \cdot c_{s_i+j}}{\sum_{j&#x3D;0}^{b^m-1} \mathcal{X}<em>{\mathcal{B}(n)}(x</em>{s_i+j} - x_i)\cdot w_{i,j}} \label{path-filter} \tag{7}<br>$$<br>其中 $ \mathcal{X}<em>{\mathcal{B}(n)}$ 为特征函数，在数学上也称为指示函数(indicator function)，这里意义为：位于球内为1；否则为0。 $\eqref{path-filter}$ 式遍历以 $x_i$ 为中心、半径为 $r(n)$ 的领域 $\mathcal{B}(n)$ 内的所有顶点 $x</em>{s_i+j}$，对每个顶点的光路贡献 $c_{s_i+j}$ 进行加权平均，得到 $\bar{c_i}$ 。其中 $n$ 为每个像素的光线总数，在每次迭代 1spp 的情况下（每次filter都会为像素采样一根光线），也可视为filter迭代次数。$\eqref{path-filter}$ 式的filter过程可以迭代执行，例如再由 $\bar{c_i}$ 计算 $\bar{\bar{c_i}}$，虽然高效，但光照细节被一定模糊，如下图</p><img src="/images/Paper Notes/Ray Tracing/Path Space Filtering.assets/image-20240418134159177.png" alt="image-20240418134159177" style="zoom: 80%;"><p>在迭代filter过程中，随着迭代次数，filter半径逐渐降低，初始半径为 $r_0$，以及参数 $\alpha \in (0, 1)$<br>$$<br>r(n) &#x3D; \frac{r_0}{n^{\alpha}}<br>$$<br>因此，随着迭代次数的增加，filter半径逐渐减少，filter区域逐渐消失，有 $\lim_{n\rightarrow \infty}\bar{c_i}&#x3D;c_i$​ 。</p><h2 id="3-1-Weighting-by-Similarity"><a href="#3-1-Weighting-by-Similarity" class="headerlink" title="3.1 Weighting by Similarity"></a>3.1 Weighting by Similarity</h2><p>一些降噪处理中，当光线于物体相交时，通常会根据交点材质来选择是否增加更多光线降低噪声，这被称为 trajectory splitting。$\eqref{path-filter}$ 式中的权重 $w_{i,j}$ 需要评估光路贡献 $c_{s_i+j}$ 通过轨迹分割在 $x_i$ 上被创建的可能性。下图是 path tracer结果、path filter后的结果，以及不同权重选择的效果对比。</p><img src="/images/Paper Notes/Ray Tracing/Path Space Filtering.assets/image-20240418141125937.png" alt="image-20240418141125937" style="zoom:80%;"><center> 左上图是16 spp的path tracer结果，左下图是带有path space filter的结果。</center><center>右侧图展示了单个权重的影响，从上到小依次为：uniform weights；normal weights；surface weights</center><h3 id="3-1-1-Blur-across-geometry"><a href="#3-1-1-Blur-across-geometry" class="headerlink" title="3.1.1 Blur across geometry"></a>3.1.1 Blur across geometry</h3><p>使用点 $x_i$ 与 $x_{s_i+j}$ 的法线相似度 $(n_i \cdot n_{s_i+j})$，实现中，只会选择  $(n_i \cdot n_{s_i+j}) \geq 0.95$ 的采样点。</p><h3 id="3-1-2-Blur-across-textures"><a href="#3-1-2-Blur-across-textures" class="headerlink" title="3.1.2 Blur across textures"></a>3.1.2 Blur across textures</h3><p>表面材质属性。比较 $x_i$ 与 $x_{s_i+j}$ 的材质属性差异，例如 BSDF。进选择低于阈值的采样点。</p><h3 id="3-1-3-Blurred-shadows"><a href="#3-1-3-Blurred-shadows" class="headerlink" title="3.1.3 Blurred shadows"></a>3.1.3 Blurred shadows</h3><p>光源可见性的处理。</p><p>对于点光源而言，点光源的阴影边缘是锐利，因此为了不模糊阴影边缘，选择仅会选择可见性一致的采样点。</p><p>对于ao或者环境光，可以通过比较进入 $x_i$ 与 $x_{s_i+j}$ 的半球面的光线长度差异，仅选择差异在阈值内的采样点。</p><h2 id="3-2-Range-Search"><a href="#3-2-Range-Search" class="headerlink" title="3.2 Range Search"></a>3.2 Range Search</h2><p>$\eqref{path-filter}$ 式中的特征函数 $\mathcal{X}<em>{\mathcal{B}(n)}(x</em>{s_i+j} - x_i)$ 用于在 $x_i$ 的邻域 $\mathcal{B}(n)$ 中选择 $x_{s_i+j}$ 。该过程涉及到的range search可以使用 hash grid、bvh或者kd-tree结构来实现高效查询。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a name="[1]">[1]</a> Alexander Keller, Ken Dahm, and Nikolaus Binder. 2016. Path space filtering. In <em>Monte Carlo and Quasi-Monte Carlo Methods: MCQMC, Leuven, Belgium, April 2014</em>, 2016. Springer, 423–436.</p><p><a name="[2]">[2]</a> Pharr, M., Jakob, W., Humphreys, G., 2017. Physically based rendering: from theory to implementation. EBSCO eBooks. 963~972.</p>]]></content>
    
    
    <categories>
      
      <category>Paper Notes</category>
      
      <category>Ray Tracing</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Massively Parallel Path Space Filtering</title>
    <link href="/2023/12/03/Paper%20Notes/Ray%20Tracing/Massively%20Parallel%20Path%20Space%20Filtering/"/>
    <url>/2023/12/03/Paper%20Notes/Ray%20Tracing/Massively%20Parallel%20Path%20Space%20Filtering/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Summary"><a href="#1-Summary" class="headerlink" title="1 Summary"></a>1 Summary</h1><h1 id="2-Background"><a href="#2-Background" class="headerlink" title="2 Background"></a>2 Background</h1><p>计算 $x$ 点处在 $\omega_r$ 方向上反射的 radiance $L_r$ 有如下四种方式：<br>$$<br>\begin{align}<br>&amp;L_r(x, \omega_r) \<br>&amp;&#x3D; \int_{S^2}L_i(x, \omega)f_r(\omega_r, x, \omega) \cos\theta_x \space d\omega \tag{1}\<br>&amp;&#x3D; \int_{\partial V}V(x,y) L_i(x, \omega)f_r(\omega_r, x, \omega)\cos\theta_x\frac{\cos\theta_y}{|x-y|^2}\space dy \tag{2}\<br>&amp;&#x3D; \lim_{r(x)\rightarrow 0}\int_{\partial V} \int_{S^2(y)}\frac{\mathcal{X_B}\left(x-h(y,\omega), r(x)\right)}{\pi r(x)^2}L_i(h(y,\omega),\omega)\cdot f_r(\omega_r,h(y,\omega), \omega)\cos\theta_y\space d\omega dy \tag{3}\<br>&amp;&#x3D; \lim_{r(x)\rightarrow 0}\int_{S^2}\frac{\int_{\partial V}\mathcal{X_B}(x-x’,r(x))\mathrm{w}(x,x’)L_i(x’,\omega)f_r(\omega_r,x,\omega)\cos\theta_{x’}\space dx’}{\int_{\partial V}\mathcal{X}_B(x-x’,r(x))\mathrm{w}(x,x’)\space dx’}\space d\omega \tag{4}<br>\end{align}<br>$$<br>其中 $\mathcal{X}_B$ 是特征函数（又称指示函数），点 $x$ 到球心 $c$ 距离为 $d&#x3D;||c-x||_2$，球半径为 $r$，有 $\mathcal{X_B}(d, r) &#x3D; \begin{cases} 1 \quad d^2 &lt; r^2 \ 0 \quad otherwise \end{cases}$ 。 上面描述了不同的技术：</p><ul><li>(1)：基础的forward path tracing下的反射项计算，对着色点处法线方向的半球面的积分。</li><li>(2)：Next Event Estimation and Subpath Connection，将 (1) 的积分域转换到场景中的表面上，采样表面上一点，与该点或者该点的路径进行连接。</li><li>(3)：Density Estimation，photon mapping理论。使用特征函数将 density estimation 区域限制在着色点附近以 $r(x)$​ 为半径的球内，density通过除以着色点所在平面与球相交部分的面积得到。</li><li>(4)：Path Space Filtering，与photon mapping的density estimation 不同，path space filtering在球内计算采样点相对于着色点的权重，进行加权平均。</li></ul><p>下图展示了不同技术的过程，</p><img src="/images/Paper Notes/Ray Tracing/Massively Parallel Path Space Filtering.assets/image-20240422153638298.png" alt="image-20240422153638298" style="zoom:80%;"><p>path space filter 原理如下<br>$$<br>\bar{c_i} &#x3D; \frac{\sum_{j&#x3D;0}^{b^m-1} \mathcal{X}<em>{\mathcal{B}(n)}(x</em>{s_i+j} - x_i) \cdot w_{i,j} \cdot c_{s_i+j}}{\sum_{j&#x3D;0}^{b^m-1} \mathcal{X}<em>{\mathcal{B}(n)}(x</em>{s_i+j} - x_i)\cdot w_{i,j}} \label{path-filter} \tag{5}<br>$$</p><h1 id="3-Algorithm"><a href="#3-Algorithm" class="headerlink" title="3 Algorithm"></a>3 Algorithm</h1><p>与 <a href="#%5B2%5D">[2]</a> 中类似，算法输入为一组顶点，这些radiance信息要被filtered。除此之外，在一个hash table中存储与查找。</p><h2 id="3-1-Averaging-in-Voxels"><a href="#3-1-Averaging-in-Voxels" class="headerlink" title="3.1 Averaging in Voxels"></a>3.1 Averaging in Voxels</h2><p>与 $\eqref{path-filter}$​ 中特征函数基于三维球不同，本文提出的算法使用从顶点描述中构建得到 key k。</p><h3 id="3-1-1-Characteristic-Function-of-a-Voxel"><a href="#3-1-1-Characteristic-Function-of-a-Voxel" class="headerlink" title="3.1.1 Characteristic Function of a Voxel"></a>3.1.1 Characteristic Function of a Voxel</h3><p>给定一个resolution selection函数 $s(k)$，voxel的特征函数定义为<br>$$<br>\mathcal{X}_V(k,k’) &#x3D;<br>\begin{cases}<br>1 \quad \lfloor s(k)k\rfloor&#x3D;\lfloor s(k’)k’\rfloor \wedge s(k)&#x3D;s(k’) \<br>0 \quad \mathrm{otherwise}<br>\end{cases}<br>\label{characteristic-function}\tag{6}<br>$$</p><blockquote><p>s(k) 可以理解为是一个基于key k的投影过程，将 k 投影到一个voxel中</p><ul><li>$s(k)k$ 向下取整，意味着 $s(k)$ 表示 1.0 &#x2F; resolution。第一项表示 k、k’ 所属 voxel 相同</li><li>$s(k)&#x3D;s(k’)$ ，表示所选resolution相同，即二者位于同一voxel层级</li></ul><p>这两个条件确定二者属于同一个voxel。 </p></blockquote><p>$s(k)$ 可以选择常量，即所有voxel具有相同的大小；更明智的，随着距离相机越远，voxel范围随之增大，这意味着距离远的voxel会更激进地filter以及具有更低密度的路径顶点。作者选择通过计算一块区域在屏幕上的投影大小来实现 $s(k)$ 的参数化。实现如 [算法1](#Algorithm 1) ，会先根据顶点到相机的距离计算一个层级，不同层级具有不同的分辨率。</p><img src="/images/Paper Notes/Ray Tracing/Massively Parallel Path Space Filtering.assets/image-20240422191956833.png" alt="image-20240422191956833" style="zoom: 67%;"><center>voxel 的特征函数为1表示 k、k'位于同一voxel，如上图，相同颜色的顶点属于同一voxel。</center><center>(a)图展示了常量 s(k) 得到uniform voxel；(b)图从左到右 s(k) 增大，这意味 resolution 递减，因此voxel逐渐减小</center><p>使用 $\mathcal{X}<em>V$ 替换 $\eqref{path-filter}$ 的特征函数，以及设置权重为1，得到<br>$$<br>L_r(x,\omega_r) \approx \int</em>{S^2}\frac{\int_{\partial V}\mathcal{X}<em>V(k,k’)L_i(x’,\omega)f_r(\omega_r,x,\omega)\cos\theta</em>{x’}\space dx’}{\int_{\partial V}\mathcal{X}<em>V(k,k’)\space dx’}d\omega<br>$$<br>上述积分项依赖于着色点，因此每次着色一个点时都需要计算一次。接下来，简化该积分，剥离着色点。将 $f_r(\omega_r,x,\omega)\approx f_r(\omega_r,x)\cdot f_i(x,\omega)$，$f_i(x,\omega)$ 在voxel近似为常量，因此可以得到<br>$$<br>L_r(x,\omega_r) \approx f_r(\omega_r,x)\cdot \int</em>{S^2}\frac{\int_{\partial V}\mathcal{X}<em>V(k,k’)L_i(x’,\omega)f_i(x’,\omega)\cos\theta</em>{x’}\space dx’}{\int_{\partial V}\mathcal{X}_V(k,k’)\space dx’}d\omega \label{voxel-filter} \tag{7}<br>$$<br>此时，积分项中还有隐藏的着色点，$k$ 是由着色点信息构建的，但 $\mathcal{X}_V(k,k’)$​ 对于具有 key k 的所有顶点都是相同的，因此积分项只与voxel中的顶点相关，每个voxel只需要计算一次该积分。</p><h3 id="3-1-2-Construction-of-Keys"><a href="#3-1-2-Construction-of-Keys" class="headerlink" title="3.1.2 Construction of Keys"></a>3.1.2 Construction of Keys</h3><p>key $k$ 只会包含描述中的一部分组件，$\eqref{voxel-filter}$ 式中积分只与 key 中包含的部分有关。key包含哪些components是bias与方差之间的权衡：</p><ul><li>包含更多components，可能会减少bias，但会导致方差增大</li><li>包含更少components，可能会减小方差，但会导致bias增加</li></ul><p>$\eqref{voxel-filter}$ 式中的近似很大程度取决于 $L_i$ 在 $x’$ 与 $x$ 之间的偏差。</p><ul><li>首先最重要的是限制voxel在世界空间的范围，这通过在 key 中包含顶点坐标实现。然而实际中，$L_i$ 不是连续的，例如锐利阴影边缘。近似带来的视觉误差会随着voxel减小而减小。</li><li>另一点 $\lim_{x’\rightarrow x}\cos\theta_{x’}&#x3D;\cos\theta_x$​ 也无法得到保证，也就是表面朝向不连续，例如，物体的锐利边缘。因此在key中包含顶点法线可以避免抹除或平坦边缘。</li><li>将 $f_r(\omega_r,x,\omega)$ 拆分为 $f_r(\omega_r,x)\cdot f_i(x,\omega)$ 对于高反射的镜面是不可行的。但在glossy表面，filtering可以以一定偏差高效降低方差。对于这类表面，拆分入射角，为每个拆分区间计算平均值可能是个可行的折衷方案。因此将入射角度包含到key中。</li><li>材质通常由多个具有不同属性的layers组成。独立地filter这些layers可以做到为不同layers的key选择不同的components，以及不同的resolutions。例如，一个material包含一个在diffuse layer之上的glossy layer，仅需要在glossy layer的filter中包含 $\omega_r$​，因为diffuse layer与观察角度无关。而diffuse layer也可以包含更多样本。在key中增加一个layer的标记，将平均值分割成几个单独的部分，并在之后组合起来。</li></ul><p>这些key的组成部分在经过 $\eqref{characteristic-function}$​ 的量化，会按照各组成部分划分区域，例如 position 组成部分划分世界空间、入射角度划分入射区域。</p><h3 id="3-1-3-Adaptive-Resolution"><a href="#3-1-3-Adaptive-Resolution" class="headerlink" title="3.1.3 Adaptive Resolution"></a>3.1.3 Adaptive Resolution</h3><p>分辨率选择函数 $s(k)$ 对于找到视觉偏差与方差之间的权衡非常重要。理论上，$s(k)$ 在具有高频细节 $L_i$ 的区域应该更大（1.0 &#x2F; resolution），但这样的信息是未知的。下图展示了，硬阴影由于filter而模糊，</p><img src="/images/Paper Notes/Ray Tracing/Massively Parallel Path Space Filtering.assets/image-20240423130259577.png" alt="image-20240423130259577" style="zoom:80%;"><center>从左到右 s(k) 逐渐减小，即filter size逐渐增大，shadow逐渐模糊</center><p>空间差异可用于适应性启发式算法，但需要引入一定的计算开销。具体如何，论文中没有提及。</p><h3 id="3-1-4-Filter-Kernel-Approximation-by-Jittering"><a href="#3-1-4-Filter-Kernel-Approximation-by-Jittering" class="headerlink" title="3.1.4 Filter Kernel Approximation by Jittering"></a>3.1.4 Filter Kernel Approximation by Jittering</h3><p>抖动key的组成部分可以消除 $s(k)$ 量化过程的不连续性。如何抖动取决于 key 组成部分的种类，例如顶点坐标选择在切平面抖动。</p><p>经过抖动产生的噪声明显由于量化产生的离散化伪影，且更容易被filter，如下图</p><img src="/images/Paper Notes/Ray Tracing/Massively Parallel Path Space Filtering.assets/image-20240423132711540.png" alt="image-20240423132711540" style="zoom:67%;"><p>![image-20240423132737345](&#x2F;images&#x2F;Paper Notes&#x2F;Ray Tracing&#x2F;Massively Parallel Path Space Filtering.assets&#x2F;image-20240423132737345.png)</p><center>voxel filer的二维示意图：(a) 是带噪声的输入；(b) 是为每个vertex执行path space filter的结果；(c) 是每个voxel内执行filter，得到block artifact；(d)在voxel filter之前增加额外的抖动</center><h2 id="3-2-Accumulation-and-Lookup-in-a-Hash-Table"><a href="#3-2-Accumulation-and-Lookup-in-a-Hash-Table" class="headerlink" title="3.2 Accumulation and Lookup in a Hash Table"></a>3.2 Accumulation and Lookup in a Hash Table</h2><p>计算 voxel 的积分项有两种方式：</p><ul><li>为每个voxel遍历其包含的顶点，这种方式需要维护voxel的顶点列表</li><li>直接遍历所有顶点，将顶点的贡献 $L_i(x’,\omega)f_i(x’,\omega)\cos\theta_{x’}$ 以原子操作累积到对应voxel上，并进行计数，这种方式无需维护列表。</li></ul><p>对于现代GPU，第二种方式更加高效，但需要一个顶点 key 到 voxel 的映射，这是通过一个hash table完成的。首先使用一个 fast hash function 计算key的hash，并使用取模运算 <code>%</code> 映射到 table cells 索引范围内。为了解决碰撞，还需要在hash table中存储key，在得到索引后，比较对应key。当不同key映射到同一index时，使用 linear probing，增加index继续搜索。</p><h3 id="3-2-1-Fingerprinting"><a href="#3-2-1-Fingerprinting" class="headerlink" title="3.2.1 Fingerprinting"></a>3.2.1 Fingerprinting</h3><p>key中包含了多个组成部分，因此比较完整的key是比较耗费性能的。作者选择再使用一个 hash，得到hash值作为 fingerprinting，来标记唯一的entry。fingerprinting也会小概率碰撞，但作者以小概率错误的代价换取性能提升，因为原key的比较非常耗费性能。过程如 [算法1](#Algorithm 1) 所示</p><p><a name="Algorithm 1"></a></p><img src="/images/Paper Notes/Ray Tracing/Massively Parallel Path Space Filtering.assets/image-20240423132404373.png" alt="image-20240423132404373" style="zoom: 80%;"><h3 id="3-2-2-Searching-by-Linear-Probing"><a href="#3-2-2-Searching-by-Linear-Probing" class="headerlink" title="3.2.2 Searching by Linear Probing"></a>3.2.2 Searching by Linear Probing</h3><p>如 [算法1](#Algorithm 1) 中所示，先将顶点坐标变换到voxel坐标 $\bar{x}$​ ，后续的hash操作都是针对voxel坐标进行的。线性探测过程可用于在更精细分辨率下区分光路的属性。如下图所示：</p><ul><li>(a)：将normal直接包含在main key中，即第一次hash过程。位于同一voxel的三个顶点由于normal不同，经过hash，落在了不同的cell。</li><li>(b)：如果main key中不包含normal，同一voxel的顶点落在同一cell中</li><li>(c)：normal加入第二次hash，得到的fingerprint可以区分normal的不同。线性探测的查找过程即可遍历这些位于同一voxel但不同normal的顶点。</li></ul><img src="/images/Paper Notes/Ray Tracing/Massively Parallel Path Space Filtering.assets/image-20240424095545075.png" alt="image-20240424095545075" style="zoom:67%;"><h2 id="3-3-Handling-Voxels-with-a-low-Number-of-Vertices"><a href="#3-3-Handling-Voxels-with-a-low-Number-of-Vertices" class="headerlink" title="3.3 Handling Voxels with a low Number of Vertices"></a>3.3 Handling Voxels with a low Number of Vertices</h2><p>对于只有少量顶点的voxel，上述variance reduction是较差的。</p><h3 id="3-3-1-Neighborhood-Search"><a href="#3-3-1-Neighborhood-Search" class="headerlink" title="3.3.1 Neighborhood Search"></a>3.3.1 Neighborhood Search</h3><p>voxel的累积过程需要对每个顶点的radiance的每个组成部分执行一次 atomicAdd，最终的均值只需要 non-atomic 读取每个component，求和并除以 counter。因此，只要访问hash table是常量时间，那么均值计算也是常量时间。</p><p>有两种方式，邻域搜索或者在更粗粒度层级的voxel中。邻域搜索需要多次查找hash table，而后者则只需要一次查找。</p><img src="/images/Paper Notes/Ray Tracing/Massively Parallel Path Space Filtering.assets/image-20240424104739917.png" alt="image-20240424104739917" style="zoom: 80%;"><h3 id="3-3-2-Multi-level-Accumulation"><a href="#3-3-2-Multi-level-Accumulation" class="headerlink" title="3.3.2 Multi-level Accumulation"></a>3.3.2 Multi-level Accumulation</h3><h2 id="3-4-Accumulation-Over-Time"><a href="#3-4-Accumulation-Over-Time" class="headerlink" title="3.4 Accumulation Over Time"></a>3.4 Accumulation Over Time</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a name="[1]">[1]</a> Binder, N., Fricke, S., and Keller, A. 2021. Massively Parallel Path Space Filtering. </p><p><a name="[2]">[2]</a> Alexander Keller, Ken Dahm, and Nikolaus Binder. 2016. Path space filtering. In <em>Monte Carlo and Quasi-Monte Carlo Methods: MCQMC, Leuven, Belgium, April 2014</em>, 2016. Springer, 423–436.</p>]]></content>
    
    
    <categories>
      
      <category>Paper Notes</category>
      
      <category>Ray Tracing</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SlabHash</title>
    <link href="/2023/11/08/Rendering%20Blogs/Graphics%20Basis/Basic%20Radiometry/"/>
    <url>/2023/11/08/Rendering%20Blogs/Graphics%20Basis/Basic%20Radiometry/</url>
    
    <content type="html"><![CDATA[<h1 id="辐射度量学基础"><a href="#辐射度量学基础" class="headerlink" title="辐射度量学基础"></a>辐射度量学基础</h1><p>Whitted style 光线追踪使用 Blinn-Phong 着色模型，着色效果不真实。因此有提出基于辐射度量学的着色模型，以物理正确的方式进行光照计算。</p><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><table><thead><tr><th>物理量</th><th>公式</th><th>单位</th></tr></thead><tbody><tr><td>Radiant Energy(辐射能)</td><td>$Q&#x3D;\frac{hc}{\lambda}$</td><td>$J$(焦耳)</td></tr><tr><td>Radiant Flux(辐射通量)或Power(功率)</td><td>$\Phi&#x3D;\frac{dQ}{dt}$</td><td>$W$(瓦特) 或 lm</td></tr><tr><td>Angle(角度)</td><td>$\theta&#x3D;\frac{l}{r}$</td><td>rad(弧度)</td></tr><tr><td>Solid Angle(立体角)</td><td>$\Omega&#x3D;\frac{A}{r^2}$</td><td>sr(球面角度)</td></tr><tr><td>Radiant Intensity(辐射强度)</td><td>$I&#x3D;\frac{\Phi}{4\pi}$</td><td>$W&#x2F;sr$ 或 cd(烛光)</td></tr><tr><td>Irradiance(辐照度)</td><td>$E(x)&#x3D;\frac{d\Phi (x)}{dA}$</td><td>$W&#x2F;m^2$ 或 lux(照度)</td></tr><tr><td>Radiance(辐射率)或luminance(亮度)</td><td>$L(p,\omega)&#x3D;\frac{d^2\Phi (p,\omega)}{d\omega dA cos\theta}$</td><td>$W&#x2F;(m^2\cdot sr)$ 或 nit(尼特)</td></tr></tbody></table><h4 id="1-Radiant-Energy-辐射能量"><a href="#1-Radiant-Energy-辐射能量" class="headerlink" title="1. Radiant Energy(辐射能量)"></a>1. Radiant Energy(辐射能量)</h4><p>电磁辐射的能量，单位焦耳 $J$</p><p>光源发射光子，每个光子具有特定的波长以及特定数量的能量。波长为 $\lambda$ 的光子携带的能量<br>$$<br>Q &#x3D; \frac{hc}{\lambda}<br>$$<br>其中，$c$ 为光速，$h$ 为普朗克常量</p><h4 id="2-Radiant-Flux-Power-辐射通量-功率"><a href="#2-Radiant-Flux-Power-辐射通量-功率" class="headerlink" title="2. Radiant Flux&#x2F;Power(辐射通量&#x2F;功率)"></a>2. Radiant Flux&#x2F;Power(辐射通量&#x2F;功率)</h4><p>单位时间内通过表面或空间区域的能量，即功率</p><p>$$<br>\Phi &#x3D; \frac{dQ}{dt}<br>$$</p><p>光源发出(emitted)的总量通常使用通量描述。下图描述了来自点光源的通量通过球面的能量，在两个球上测量得到的通量应该是相同的。</p> <img src="/images/Rendering Blogs/Graphics Basis/Basic Radiometry.assets/image-20231114163033588.png" alt="image-20231114163033588" style="zoom: 50%;"><p>经常会遇到throughput说法，但throughput并不是物理量，只是对光线传播时所保持能量的描述。例如由光源发出的光线，经过一级反射会累积交点处的BSDF，在下一级光路传播时，该光线的throughput指的是其携带能量乘上BSDF。可以理解为 scaled radiance。而辐射通量则是某点对到达该点的光线的throughput * 该点的BSDF的积分。</p><h4 id="3-Angle"><a href="#3-Angle" class="headerlink" title="3. Angle"></a>3. Angle</h4><p>圆上的弧长与半径的比值: $\theta&#x3D;\frac{l}{r}$ ，圆有 $2\pi$ 弧度</p><img src="/images/Rendering Blogs/Graphics Basis/Basic Radiometry.assets/image-20210418105514511.png" alt="image-20210418105514511" style="zoom:33%;"><h4 id="4-Solid-Angle-立体角"><a href="#4-Solid-Angle-立体角" class="headerlink" title="4. Solid Angle(立体角)"></a>4. Solid Angle(立体角)</h4><p>球面上的投影面积与半径的平方之比: $\Omega &#x3D; \frac{A}{r^2}$，球的立体角为 $4\pi$ 球面角度(steradians)</p><img src="/images/Rendering Blogs/Graphics Basis/Basic Radiometry.assets/image-20210418105703119.png" alt="image-20210418105703119" style="zoom:33%;"><h4 id="5-Differential-Solid-Angle-微分立体角"><a href="#5-Differential-Solid-Angle-微分立体角" class="headerlink" title="5. Differential Solid Angle(微分立体角)"></a>5. Differential Solid Angle(微分立体角)</h4><img src="/images/Rendering Blogs/Graphics Basis/Basic Radiometry.assets/image-20210418105937707.png" alt="image-20210418105937707" style="zoom: 25%;"><ul><li><p>球面坐标：$\theta\in[0,\pi],\phi\in[0,2\pi]$</p></li><li><p>单位面积：$dA&#x3D;(rd\theta)(rsin\theta d\phi)&#x3D;r^2sin\theta d\theta d\phi$，单位立体角对应的球面上单位区域的面积</p></li><li><p>单位立体角：$d\omega &#x3D; \frac{dA}{r^2}&#x3D;sin\theta d\theta d\phi$</p></li><li><p>球面的微分立体角：$\Omega&#x3D;\int_{S^2}d\omega&#x3D;\int_0^{2\pi}\int_0^{\pi}sin\theta d\theta d\phi&#x3D;4\pi$，其中 $S^2$ 是球面积</p><blockquote><p>$dA$ 的证明，$dA$ 可看作 $d\theta$ 和 $d\phi$ 对应的微分弧组成的小矩形，如下图中红色弧线与蓝色弧线</p><img src="/images/Rendering Blogs/Graphics Basis/Basic Radiometry.assets/2.PNG" alt="2" style="zoom: 50%;"><p>其中蓝色弧线位于半径为 $r_\phi$ 的小圆上，而红色弧线位于半径为 $r_\theta$ 的大圆上，又知道 $sin\theta &#x3D; \frac{r_\phi}{r_\theta}$，由弧长公式有</p><p>红色弧：$r_\theta d\theta$，蓝色弧：$r_\phi d\phi&#x3D;r_\theta sin\theta d\phi$。</p><p>因此 $dA&#x3D;(r_\theta d\theta)(r_\theta sin\theta d\phi)&#x3D;r_\theta^2sin\theta d\theta d\phi$。</p><blockquote><p>$sin\theta$ 的直观理解是，越靠近极点位置，$r_\phi$ 越小，因此微分面积也越小；越靠近赤道位置，$r_\phi$ 越大，因此微分面积也越大</p></blockquote></blockquote></li></ul><p>$\omega$ 作为单位立体角的方向向量</p><img src="/images/Rendering Blogs/Graphics Basis/Basic Radiometry.assets/image-20210418111221992.png" alt="image-20210418111221992" style="zoom:25%;"><ul><li>Isotropic Point Source(各向同性光源)：球面上各单位立体角辐射强度 (Radiant Intensity) 相同。整个球面的辐射通量&#x2F;功率：$\Phi&#x3D;\int_{S^2}Id\omega&#x3D;4\pi I$，辐射强度 $I&#x3D;\frac{\phi}{4\pi}$。</li></ul><img src="/images/Rendering Blogs/Graphics Basis/Basic Radiometry.assets/image-20210418111805822.png" alt="image-20210418111805822" style="zoom:25%;"><h4 id="6-Radiant-Intensity-辐射强度"><a href="#6-Radiant-Intensity-辐射强度" class="headerlink" title="6. Radiant Intensity(辐射强度)"></a>6. Radiant Intensity(辐射强度)</h4><p>点光源<strong>每立体角</strong>发出的功率<br>$$<br>I(\omega)&#x3D;\frac{d\Phi}{d\omega}<br>$$</p><h4 id="7-Irradiance-辐照度"><a href="#7-Irradiance-辐照度" class="headerlink" title="7. Irradiance(辐照度)"></a>7. Irradiance(辐照度)<a name="7. Irradiance(辐照度)"></a></h4><p>前述flux(辐射通量或功率)是单位时间内通过表面的能量，irradiance则为辐射通量在表面上的平均强度，即单位面积的强度。</p><p>辐照度是每(垂直&#x2F;投影)<strong>单位面积</strong>入射到一个表面上一点的<strong>辐射通量</strong>(功率)，<br>$$<br>E(x)&#x3D;\frac{d\Phi(x)}{dA}<br>$$</p><p>单位时间内光子离开或进入单位面积的通量</p><p>Lambert 余弦定律：表面辐照度与光方向和表面法线夹角的余弦值成正比</p><img src="/images/Rendering Blogs/Graphics Basis/Basic Radiometry.assets/image-20210418113052481.png" alt="image-20210418113052481" style="zoom:25%;"><blockquote><p>这里 irradiance 是单位面积入射到一点的辐射通量，$cos\theta$ 调整的是方向 $l$ 上入射功率的贡献，将方向 $l$ 上的辐射通量投影到接收点的法线方向 $n$ 上。</p></blockquote><p>Irradiance 衰减：$E&#x3D;\frac{\Phi}{4\pi r^2}$ ，$\Phi$ 记录的是单位半径球面在单位时间内所接收的能量的功率。二维示意图如下</p><img src="/images/Rendering Blogs/Graphics Basis/Basic Radiometry.assets/image-20210418113447525.png" alt="image-20210418113447525" style="zoom:25%;"><h4 id="8-Radiance-辐射率"><a href="#8-Radiance-辐射率" class="headerlink" title="8. Radiance(辐射率)"></a>8. Radiance(辐射率)</h4><p>Radiance 用于描述光在环境中的分布的基本场量。辐射率(Radiance)或亮度(luminance) ：是指一个表面在<strong>每单位立体角、每单位投影面积</strong>上所发射(emitted)、反射(reflected)、透射(transmitted)或接收(received)的辐射通量(功率)。</p><p>$$<br>L(p,\omega)&#x3D;\frac{d^2\Phi (p,\omega)}{d\omega dA \cos\theta}<br>$$</p><blockquote><p>$p$ 点所在表面、立体角方向$w$接收到的辐射通量 $\Phi(p,w)$，对立体角、面积的二阶求偏导的辐射率 $L(p,w)$。反过来求辐射通量，这里得到的是表面的整个积分域与立体角的积分域收到的辐射通量。<br>$$<br>\Phi(p,w)&#x3D;\int\int L(p,w)\cdot \cos\theta\space dwdA<br>$$</p></blockquote><p>Light traveling along a Ray                  <img src="/images/Rendering Blogs/Graphics Basis/Basic Radiometry.assets/image-20210418113916011.png" alt="image-20210418113916011" style="zoom: 33%;"></p><blockquote><p>这里是从表面点 $p$ 沿着其某一单位立体角方向 $\omega$ 发出的功率，$cos\theta$ 是将辐射面投影到以 $\omega$ 为法线的平面。</p></blockquote><ul><li>Incident Radiance(入射辐射)：到达表面的<strong>单位立体角</strong>的 irradiance(辐照度)，即 radiance。</li></ul><p>$$<br>L(p,\omega)&#x3D;\frac{dE(p)}{d\omega \cos\theta}<br>$$</p><blockquote><p>$p$ 点处单位面积收到的辐照度 $E(p)$ 是辐射率<strong>对立体角的积分</strong>，即单位面积收到的辐射强度（是不是很像渲染方程，除了没有BRDF）<br>$$<br>E(p) &#x3D; \int L(p,w)\cdot \cos\theta \space dw<br>$$</p></blockquote><p>​                                                                   <img src="/images/Rendering Blogs/Graphics Basis/Basic Radiometry.assets/image-20210418140012081.png" alt="image-20210418140012081" style="zoom: 33%;"></p><blockquote><p>沿着 $\omega$ 方向到达表面 $p$ 点的辐射，$cos\theta$ 将入射方向投影到表面点 $p$ 法线方向</p></blockquote><ul><li>Exiting Radiance(出射辐射)：离开表面的<strong>单位投影面积</strong>的 Radiance Intensity(辐射强度)。如面光源</li></ul><p>$$<br>L(p,\omega)&#x3D;\frac{dI(p,\omega)}{dA\cos\theta}<br>$$</p><blockquote><p> 上式是对面光源的出射辐射率的描述，而辐射强度 $I(p,w)$ 为单位立体角的辐照度，即朝 $w$ 方向发出的辐射强度，为辐射率<strong>对面积的积分</strong><br>$$<br>I(p,w) &#x3D; \int L(p,w)\cos\theta \space dA<br>$$<br>​                                                              </p></blockquote><img src="/images/Rendering Blogs/Graphics Basis/Basic Radiometry.assets/image-20210418141032723.png" alt="image-20210418141032723" style="zoom: 33%;"><p><strong>注意</strong>：Incident Radiance 与 Exiting Radiance 虽然表达式形式有所不同，但代入后最终都可转化为<br>$$<br>\frac{d^2\Phi (p,\omega)}{d\omega dA cos\theta}<br>$$</p><blockquote><p>具有单位立体角限制的 irradiance 等同于 radiance，具有单位投影面积的 Radiance Intensity 等同于 radiance</p></blockquote><h2 id="辐照度-Irradiance-VS-辐射率-Radiance"><a href="#辐照度-Irradiance-VS-辐射率-Radiance" class="headerlink" title="辐照度(Irradiance) VS. 辐射率(Radiance)"></a>辐照度(Irradiance) VS. 辐射率(Radiance)</h2><ul><li>Irradiance：在面积 $dA$ 的总辐射通量</li><li>Radiance：在面积 $dA$ 、方向 $d\omega$ 上的辐射通量</li></ul><p>​$$dE(p,\omega)&#x3D;L_i(p,\omega)cos\theta \space d\omega \ E(p,\omega)&#x3D;\int_{H^2}L_i(p,\omega)cos\theta \space d\omega$$                     <img src="/images/Rendering Blogs/Graphics Basis/Basic Radiometry.assets/image-20210418143001958.png" alt="image-20210418143001958" style="zoom: 33%;"></p>]]></content>
    
    
    <categories>
      
      <category>Rendering Blogs</category>
      
      <category>Graphics</category>
      
      <category>Radiometry</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SlabHash</title>
    <link href="/2023/10/24/Rendering%20Blogs/GPGPU/Coherent%20Memory%20Access%20and%20Synchronization/"/>
    <url>/2023/10/24/Rendering%20Blogs/GPGPU/Coherent%20Memory%20Access%20and%20Synchronization/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Summary"><a href="#1-Summary" class="headerlink" title="1 Summary"></a>1 Summary</h1><p>经常看到glsl的type修饰 <code>coherent</code>，系统整理下有关coherent的理解。</p><h1 id="2-基础概念"><a href="#2-基础概念" class="headerlink" title="2 基础概念"></a>2 基础概念</h1><h2 id="2-1-Coherent-or-Incoherent-Memory-Access-2"><a href="#2-1-Coherent-or-Incoherent-Memory-Access-2" class="headerlink" title="2.1 Coherent or Incoherent Memory Access [2]"></a>2.1 Coherent or Incoherent Memory Access <a href="#%5B2%5D">[2]</a></h2><h3 id="2-1-1-Coherent-内存访问"><a href="#2-1-1-Coherent-内存访问" class="headerlink" title="2.1.1 Coherent 内存访问"></a>2.1.1 Coherent 内存访问</h3><p>以最简单的例子——单处理器系统来说，对于同一内存区域同时只会有一个线程访问。因此，当一个处理元件对某一内存区域写，然后另一处理元件对同一内存区域读时，总能读到更新后的值。这是我们想要的结果，但得到这一正确结果并不只是多线程读写同步。因为，在硬件层有高速缓存-内存机制，处理器的读写往往不直接针对内存，而是针对缓存。缓存中的数据是内存中数据的拷贝或者是写操作得到的更新数据，因此需要确保写操作之后的读操作能够读到新数据，而非旧数据，这就是 <strong>Coherent 内存访问</strong>。单处理器系统的内存操作工作于同一套高速缓存-内存机制中，保证 Coherent 内存访问较容易。</p><h3 id="2-1-2-Incoherent-内存访问"><a href="#2-1-2-Incoherent-内存访问" class="headerlink" title="2.1.2 Incoherent 内存访问"></a>2.1.2 Incoherent 内存访问</h3><p>但对于多处理器系统，每个处理器都有其本地缓存，当多个处理器同时访问同一内存区域时，同一内存区域的数据在这些处理器的缓存中都有一个备份。此时可能存在处理器读到的是本地缓存中的旧数据，而不是其他处理器写操作生成的新数据，即出现 <strong>Incoherent 内存访问</strong>。为了避免这种情况，多处理器系统的设计需要采用存储器一致性协议，粗略地说，当一个处理器对某一内存区域更新时，对该内存区域存在缓存备份的其他处理器也要对其本地缓存的相应位置进行更新。</p><h2 id="2-2-GPU-Architecture"><a href="#2-2-GPU-Architecture" class="headerlink" title="2.2 GPU Architecture"></a>2.2 GPU Architecture</h2><p>GPU 具有非常多的处理器核心，在 Nvidia 中称为 Streaming Multiprocessor(SM)，AMD 称为 Compute Unit(CU)，以下使用 SM。在 SM 内部包含最基本的处理单元 lane，lane 可以近似理解为一个线程。SM 进行调度执行任务时，最小单位并不是 lane，而是 Warp(Nvidia 中的称呼，AMD 称为 wavefront)。一个 Warp 包含一定数量的 lane，在 Nvidia 中是 32，AMD 是 64。不同的架构，一个 SM 中包含的 warp 数量不同，目前的 Nvidia GPU 中一个 SM 包含 4 个 warp，即 128 个 lane(shader core、cuda core等)。GPU 显卡型号不同，GPU 包含的 SM 数量也不同，3080Ti 包含 80 个 SM。</p><p>下面来自 <a href="#%5B4%5D">[4]</a> 的图 Fig-1 为GPU示意图，Fig-2为其中单个SM示意图。</p><p>![image-20231024143243815](&#x2F;images&#x2F;Rendering Blogs&#x2F;GPGPU&#x2F;Coherent Memory Access.assets&#x2F;image-20231024143243815.png)</p><center>Fig-1 GPU 整体的结构图</center><img src="/images/Rendering Blogs/GPGPU/Coherent Memory Access.assets/image-20231024143637826.png" alt="image-20231024143637826" style="zoom: 67%;"><center>Fig-2 SM示意图</center><h3 id="2-2-1-Memory-Model"><a href="#2-2-1-Memory-Model" class="headerlink" title="2.2.1 Memory Model"></a>2.2.1 Memory Model</h3><p>从Fig-1中可以看出，整个GPU共用一个L2 cache，而Fig-2中每个SM都有一个L1 cache。下面Fig-3 是来自 <a href="#%5B3%5D">[3]</a> 的GPU内存的简化模型，即 <code>L1 cache - L2 cache - DRAM</code> 这样的三层结构，</p><img src="/images/Rendering Blogs/GPGPU/Coherent Memory Access and Synchronization.assets/image-20231024163924062.png" alt="image-20231024163924062" style="zoom:50%;"><center>Fig-3 GPU 存储层级结构</center><p>其中：</p><ul><li><p>register：每个 SM 具有256KB 大小的寄存器区。</p></li><li><p>shared memory&#x2F;L1 cache：一个 SM 中的所有线程可以访问该 SM 具有有限大小的 shared memory。shared memory 本质上是一个较小的读写缓存区，GA102 架构中为 128KB，但其中只有一部分可被程序员使用，其他用作缓存或其他用途，例如 48KB 用作 shared memory。</p></li><li><p>L2 cache：通过L2 cache访问DRAM</p></li><li><p>global memory(DRAM)：global memory 即 GPU 显存。如果寄存器存储或者shared memory 的使用大小溢出，则会将其中的数据写入显存中，这一点和 CPU 的高速缓存-内存机制类似。</p></li></ul><p>按照2.1节的概念，正是这样的两层cache的结构引入了内存访问的coherent问题。</p><p><img src="/images/Rendering Blogs/GPGPU/Coherent Memory Access and Synchronization.assets/image-20231024164125968.png" alt="image-20231024164125968" style="zoom: 45%;"><img src="/images/Rendering Blogs/GPGPU/Coherent Memory Access and Synchronization.assets/image-20231024164201758.png" alt="image-20231024164201758" style="zoom:45%;"></p><h3 id="2-2-2-Execution-Model"><a href="#2-2-2-Execution-Model" class="headerlink" title="2.2.2 Execution Model"></a>2.2.2 Execution Model</h3><p>对于GPGPU，用户调度方式是通过cuda或者compute shader发出多个thread group。而GPU收到这些thread group如何调度执行就是execution model。</p><p>在同一个 Warp 中的所有 lane 执行相同的指令，但可以处理不同的数据，这样就构成了现代 GPU 的 SIMD 机制。但一个 Warp 中的所有 lane 并不总是同时处于运行状态，即 active lane；也并不总是同时处于非运行状态，即 inactive lane。例如：</p><ul><li><p>下发的任务组包含的任务数量较少或者不是 warp 大小的整数倍，不足以填满整个 warp 的 lane，那么未分配任务的 lane 则处于 inactive 状态。下发的任务组在 vulkan 中称为  local workgroup(D3D 中的 thread group) 大小。</p></li><li><p>Dynamic Branching 会导致 lane 的执行路径不止一条，即不止一套指令，这一定程度上破坏了 SIMD 机制。例如，代码中包含 if-else 语句，不满足 if 条件的 lane 由于 lockstep 运行方式需要等待其它所有满足 if 条件的 lane 执行 if 部分，等待中的 lane 则处于 inactive 状态。反之，满足 if 条件的 lane 也会等待不满足 if 条件的 lane 执行 else 部分。</p></li></ul><p>接下来，基于 <a href="#%5B3%5D">[3]</a> 关于cuda执行模型的资料(理论上都是一样的)来介绍。cuda中的执行单位有：</p><ul><li><p>thread：对应compute shader中的invocation</p></li><li><p>threads block：对应work group</p><p>运行在一个SM上，因此 threads block 内的线程可以有轻量级地同步与数据交换。</p><ul><li>同一个SM共享一个L2 cache，因此可以仅使用shared memory，要快于buffer、image这类global memory。</li><li>同一个warp线程也可以使用warp内的数据同步（更快）</li></ul><p>当一个threads block被调度到某一个SM上时，就只会在这个SM上执行 (中间可能会有hide latency导致的换入换出)，否则L2 cache就无法保证是同一个。</p></li><li><p>grid：grid大小 (x, y, z) 对应dispatch中的参数，一个grid包含 x*y*z 个threads blocks。</p><p>这些blocks如何被调度由GPU决定，是不可知的，也就是无法知道哪些blocks会在一个SM上执行、哪些在不同SM上执行。因此需要统一视为在不同SM上。 </p><p>不同threads block之间无法同步，数据交换只能通过global memory</p></li></ul><img src="/images/Rendering Blogs/GPGPU/Coherent Memory Access.assets/image-20231024145820900.png" alt="image-20231024145820900" style="zoom:50%;"><h2 id="2-3-Synchronization"><a href="#2-3-Synchronization" class="headerlink" title="2.3 Synchronization"></a>2.3 Synchronization</h2><p>同步主要包含两类：</p><ul><li>对代码指令执行结点的同步。全部执行到同步点时才会开始执行之后的指令，这类同步只能发生在thread block(work group)内。</li><li>对内存访问操作的同步。保证能够读到已经执行的写操作后的数据，避免读到cache中旧的备份。这里的访问操作不是显示调用的指令，而是cache机制中隐含的memory transaction。</li></ul><p>下面基于glsl对这两类同步进行阐述。为了解释内存操作的同步，先看下OpenGL对visibility的描述。</p><h3 id="2-3-1-Visibility-5"><a href="#2-3-1-Visibility-5" class="headerlink" title="2.3.1 Visibility [5]"></a>2.3.1 Visibility <a href="#%5B5%5D">[5]</a></h3><p>在 GPU 的执行过程中，不同处理器同时读写同一内存区域时，也会出现上述 Incoherent 内存访问情况。而 <strong>Visibility</strong> 术语就是指一个 shader invocation 可以安全地读其他 shader invocation 的 Incoherent 写数据，也就是说，不会读取到缓存中旧的备份，或者其他 invocation 写数据对其是可见的。</p><p>避免 incoherent 内存访问，即确保 visibility 性质。这里有两种情况：</p><h4 id="2-3-1-1-Internal-Visibility"><a href="#2-3-1-1-Internal-Visibility" class="headerlink" title="2.3.1.1 Internal Visibility"></a>2.3.1.1 Internal Visibility</h4><p>发生在一个 render command 执行内部，即shader invocations之间。<a href="#%5B6%5D">[6]</a> 中提到shader中的 incoherent访问操作有：</p><ul><li><p>对 image 变量的 imageLoad&#x2F;imageStore</p></li><li><p>对 buffer 变量的读写操作</p></li><li><p><a href="https://www.khronos.org/opengl/wiki/Atomic_Counter">Atomic Counters</a></p></li><li><p>对 compute shader 中的 shared 变量的读写操作。:x:</p><blockquote><p>这一点应该是错的。shared 变量位于shared memory即L1缓存中。根据2.2.1小节内容，L1 cache位于SM内，是独立的且对其它SM不可见，因此不会有多个备份的情况，所以不会是 incoherent。</p><p>后面也有官方资料证实shared变量是隐含的coherent。</p></blockquote></li></ul><h4 id="2-3-1-2-External-Visibility"><a href="#2-3-1-2-External-Visibility" class="headerlink" title="2.3.1.2 External Visibility"></a>2.3.1.2 External Visibility</h4><p>一个 render command 内部的 visibility 是 shader invocation 之间的读写操作。对于 render command 之间的 visibility 使用 barrier 命令进行同步。例如 vulkan 中的 buffer barrier、image layout 等。</p><h3 id="2-3-2-指令同步"><a href="#2-3-2-指令同步" class="headerlink" title="2.3.2 指令同步"></a>2.3.2 指令同步</h3><p>由2.2.2小节中描述的cuda执行模型可知，不同work group之间无法同步，因此这里的同步是work group内的。</p><p>glsl 中函数 <code>barrier()</code>可以确保workgroup(执行在同一处理器) 中的所有 invocation 都执行到 barrier 同步点后，才开始执行之后的代码。其在官方文档 <a href="#%5B7%5D">[7]</a> 8.16节中的描述如下</p><img src="/images/Rendering Blogs/GPGPU/Coherent Memory Access and Synchronization.assets/image-20231024184950016.png" alt="image-20231024184950016" style="zoom:50%;"><p>在 compute shader 中 shared 变量位于 shared memory 中，即位于L1 cache中，同一SM只有一份，因此 shared 变量是隐含的 coherent 访问。barrier同步的是同一workgroup的指令，因此也能做到对shared变量的访问同步。这一点在 <a href="#%5B7%5D">[7]</a> 的 1.1.3 小节也有说明</p><img src="/images/Rendering Blogs/GPGPU/Coherent Memory Access and Synchronization.assets/image-20231024185559050.png" alt="image-20231024185559050" style="zoom:50%;"><p>思考另一点，同一work group的invocation都位于同一SM，那么为什么还需要barrier来同步指令？位于之前的指令不应该先于之后的指令完成吗？</p><p>那是因为，GPU调度单位是warp，对于一个提交的work group，work group被分配好SM后，会先被划分为一个或多个warp，以warp为单位调度执行。一个SM共有4个warp，如果不足以执行完整个work group，那么会需要多次调度执行。因此work group虽然都在同一个SM上，但其中的warp可能不是同时开始或结束的。对于 barrier 同步而言，执行到同步点的warp会停下来，此时SM可以再调度一个warp进来执行。</p><h3 id="2-3-3-Memory-Barrier"><a href="#2-3-3-Memory-Barrier" class="headerlink" title="2.3.3 Memory Barrier"></a>2.3.3 Memory Barrier</h3><p>指令同步无法解决前面说的incoherent内存访问问题，首先是指令同步只能发生在work group内，其次不同work groups可能分布在不同的SM上，仍然会导致incoherent问题。</p><p>复述incoherent问题：写操作发生不代表写数据对其他 invocation 可见，这会导致一个 invocation 的内存读写操作的相对次序对于另一个 invocation 而言是不确定的状态，换句话说，写操作的数据对其他 invocation 可见的次序不确定。例如一个 invocation 中执行两次写操作，而另一个 invocation 可能会先看到第二次写的数据，后看到第一次写的数据。</p><p>memory barrier 则是用来控制读写操作（背后的cache机制），使得其他 invocation 看到写数据的次序与写操作执行的次序一致。先对可能被多个处理器访问到的 image 或 buffer 类型变量进行 <code>coherent</code> 修饰，声明该变量为 coherent 访问机制。该访问机制使得相应的 memoryBarrier 可以控制对被修饰变量的读写操作。调用 memoryBarrier 等函数的 invocation 会等待之前的所有读写操作完成，当该函数返回后，写数据对之后的访问处于可见状态。</p><p>memory barrier有以下几种类型, 来自<a href="#%5B7%5D">[7]</a> 的 8.17节 ：</p><ul><li><code>memoryBarrier</code>：控制所有类型变量的内存访问，render command 内作用于全局。</li><li><code>memoryBarrierAtomicCounter</code>：控制 atomic-counter 变量的访问，render command 内作用于全局。</li><li><code>memoryBarrierBuffer</code>：控制 buffer 变量的内存访问，render command 内作用于全局。</li><li><code>memoryBarrierImage</code>：控制 image 变量的内存访问，render command 内作用于全局。</li><li><code>memoryBarrierShared</code>：控制 shared 变量的内存访问，作用于同一 workgroup。</li><li><code>groupMemoryBarrier</code>：控制所有类型变量的内存访问，作用于同一 workgroup。</li></ul><img src="/images/Rendering Blogs/GPGPU/Coherent Memory Access and Synchronization.assets/image-20231024191716458.png" alt="image-20231024191716458" style="zoom:50%;"><p>官方文档 <a href="#%5B7%5D">[7]</a> 后续有些描述可以更清晰理解这些memory barrier的作用</p><ul><li>作用范围：只有 <code>memoryBarrierShared()</code> 与 <code>groupMemoryBarrier()</code> 只会控制同一work group的memory transaction，其它memory barrier都是作用于render command的所有invocation。<img src="/images/Rendering Blogs/GPGPU/Coherent Memory Access and Synchronization.assets/image-20231024194223239.png" alt="image-20231024194223239" style="zoom:50%;"></li><li>对于执行store的invocation而言，不需要memory barrier来保证其自身的观察到store次序。除非有其它invocation对同一内存位置写入。<img src="/images/Rendering Blogs/GPGPU/Coherent Memory Access and Synchronization.assets/image-20231024194548619.png" alt="image-20231024194548619" style="zoom:50%;"></li></ul><p>一些疑问与猜想：</p><ul><li>对于不同work group不会对同一内存位置读写的情况还需要memory barrier吗？例如多个work group处理一张图片，每个work group负责一个tile。<br>感觉应该不需要，对不同位置操作，没有带来对同一位置多份cache的情况</li><li><code>groupMemoryBarrier()</code>只对同一work group的memory transaction起作用，这似乎没有意义？因为同一work group在同一SM上，具有相同的cache，memory transaction应该不会导致incoherent问题 :question:<ul><li>按照上面第二段的解释而言，如果work group内的每个invocation负责访问不同的内存位置，那么确实不需要该memory barrier。</li><li>如果work group内的invocation可能访问同一内存位置，按照我的推测，应该是缓存机制没办法保证访存(store&#x2F;load)的原子性，而work group的invocation属于并行线程，会导致多线程读写问题。<code>groupMemoryBarrier()</code>可以保证memory同步点之前的memory transaction完成，可以确保写后读的正确性。</li></ul></li></ul><h3 id="2-3-4-Atomic-Memory"><a href="#2-3-4-Atomic-Memory" class="headerlink" title="2.3.4 Atomic Memory"></a>2.3.4 Atomic Memory</h3><p>官方文档 <a href="#%5B7%5D">[7]</a> 8.11 节描述了对 buffer&#x2F;shared 变量存储的atomic操作，</p><img src="/images/Rendering Blogs/GPGPU/Coherent Memory Access and Synchronization.assets/image-20231024203351835.png" alt="image-20231024203351835" style="zoom:50%;"><p>而atomic操作可以满足memory qualification，如下所述。理论上应该是可以保证coherent访问的，那读取操作应该需要使用 <code>atomicAnd(mem, 0xFFFFFFFF)</code></p><img src="/images/Rendering Blogs/GPGPU/Coherent Memory Access and Synchronization.assets/image-20231024203440579.png" alt="image-20231024203440579" style="zoom:50%;"><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a name="[1]">[1]</a> <a href="https://docs.nvidia.com/deeplearning/performance/dl-performance-gpu-background/index.html#gpu-arch">https://docs.nvidia.com/deeplearning/performance/dl-performance-gpu-background/index.html#gpu-arch</a></p><p><a name="[2]">[2]</a> <a href="https://en.wikipedia.org/wiki/Memory_coherence">https://en.wikipedia.org/wiki/Memory_coherence</a></p><p><a name="[3]">[3]</a> <a href="https://www.olcf.ornl.gov/wp-content/uploads/2013/02/GPU_Opt_Fund-CW1.pdf">https://www.olcf.ornl.gov/wp-content/uploads/2013/02/GPU_Opt_Fund-CW1.pdf</a></p><p><a name="[4]">[4]</a> <a href="https://images.nvidia.cn/aem-dam/en-zz/Solutions/geforce/ampere/pdf/NVIDIA-ampere-GA102-GPU-Architecture-Whitepaper-V1.pdf">https://images.nvidia.cn/aem-dam/en-zz/Solutions/geforce/ampere/pdf/NVIDIA-ampere-GA102-GPU-Architecture-Whitepaper-V1.pdf</a></p><p><a name="[5]">[5]</a> <a href="https://www.khronos.org/opengl/wiki/Memory_Model#Ensuring_visibility">https://www.khronos.org/opengl/wiki/Memory_Model#Ensuring_visibility</a></p><p><a name="[6]">[6]</a> <a href="https://www.khronos.org/opengl/wiki/Memory_Model#Incoherent_memory_access">https://www.khronos.org/opengl/wiki/Memory_Model#Incoherent_memory_access</a></p><p><a name="[7]">[7]</a> <a href="https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.60.pdf">https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.60.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>Rendering Blogs</category>
      
      <category>GPGPU</category>
      
      <category>Synchronization</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/10/22/C++/Entity%20Component%20System/"/>
    <url>/2023/10/22/C++/Entity%20Component%20System/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=W3aieHjyNvw">https://www.youtube.com/watch?v=W3aieHjyNvw</a></p><p><a href="https://www.youtube.com/watch?v=kwnb9Clh2Is">https://www.youtube.com/watch?v=kwnb9Clh2Is</a></p><p><a href="https://www.youtube.com/watch?v=f9q8A-9DvPo">https://www.youtube.com/watch?v=f9q8A-9DvPo</a></p><p><a href="https://github.com/CppCon/CppCon2015/blob/master/Tutorials/Implementation%20of%20a%20component-based%20entity%20system%20in%20modern%20C++/Implementation%20of%20a%20component-based%20entity%20system%20in%20modern%20C++%20-%20Vittorio%20Romeo%20-%20CppCon%202015.pdf">Implementation of a component-based entity system in modern C++</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SlabHash</title>
    <link href="/2023/10/20/Rendering%20Blogs/GPGPU/SlabHash/"/>
    <url>/2023/10/20/Rendering%20Blogs/GPGPU/SlabHash/</url>
    
    <content type="html"><![CDATA[<h1 id="1-源码分析"><a href="#1-源码分析" class="headerlink" title="1 源码分析"></a>1 源码分析</h1><p>使用到的warp操作：</p><ul><li><code>unsigned __ballot_sync(unsigned mask, predicate)</code><br>mask中的bit为1 表示对相应id的线程执行warp操作，该线程的predicate非0将返回值对应位置为1</li><li><code>int __ffs (int x)</code><br>  返回最低非0有效位的位置。x为0，则返回0</li><li><code>T __shfl_sync(unsigned mask, T var, int srcLane, int width=warpSize)</code><br>从指定lane拷贝var变量。width控制lane索引，srcLane % width</li></ul><h2 id="1-1-searchKey"><a href="#1-1-searchKey" class="headerlink" title="1.1 searchKey"></a>1.1 searchKey</h2><p>函数声明如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">GpuSlabHashContext&lt;KeyT, ValueT, SlabHashTypeT::ConcurrentMap&gt;::<span class="hljs-built_in">searchKey</span>(<br>    <span class="hljs-type">bool</span>&amp; to_be_searched,<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>&amp; laneId,<br>    <span class="hljs-type">const</span> KeyT&amp; myKey,<br>    ValueT&amp; myValue,<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> bucket_id)<br></code></pre></td></tr></table></figure><p>给一批keys，以32个为一组，对于一个warp内的lane，一个lane( <code>laneId</code> )绑定一个 <code>myKey</code> ，查找完成返回 <code>myValue</code> 。实际查找过程是先组成一个work_queue，对这个work_queue的每一个key，warp进行逐个key查找，直至work_queue完成。函数实现如下：</p><ul><li><p>line 5 组装work_queue：worke_queue为32bit整数，每一位表示对于lane是否完成查找。<br>__ballot_sync 设置work_queue中bit，1表示对应lane需要查找key，0表示已完成查找或不需要</p></li><li><p>line 6~7 设置查找位置。<br>如果work_queue发生了变化，表示上一个lane的查找已经完成，那么处理下一个key，则需要在对应bucket从头开始查找。 <code>SlabHashT::A_INDEX_POINTER</code><br>否则，表示需要继续查找下一个slab。</p></li><li><p>line 8~17 获取当前迭代的查找目标信息以及查找位置的数据</p><ul><li>获取当前warp迭代查找目标信息：lane id，bucket，key<br>__ffs得到work_queue中的当前warp迭代的查找目标 <code>src_lane</code> (由小到大)，减1是因为 __ffs 的返回值0是保留给参数0的，而bit位从1开始，lane id从0开始<br>__shfl_sync从查找目标lane中拷贝其 bucket_id<br>__shfl_sync从查找目标lane中拷贝其要查找的key</li><li>获取warp每个线程对应的查找位置的数据。<br>两种查找位置，一个是bucket，一个是slab，返回的是当前线程的laneId位置处的数据(warp中每个线程负责一个位置)</li></ul></li><li><p>line 18~20 比较查找目标与查找位置的key，相同表示匹配，不同表示不匹配。warp是否已有线程查找到目标key<br>__ballot_sync 得到warp所有线程的比较结果。注意后面 &amp; 操作是用于处理slab中key-value的存放方式。</p><ul><li><code>REGULAR_NODE_KEY_MASK = 0x15555555</code> 意味着key-value是连续存放方式，因此一个warp的线程只有REGULAR_NODE_KEY_MASK 中bit为1处才是取得是key，其他取得是value。</li></ul><p>__ffs 则是获取匹配上的lane id，后面-1为了处理lane id从0开始计数。</p></li><li><p>line 21~30 处理本次warp迭代没有找到目标key。<br>__shfl_sync拷贝warp最后一个lane(31)读取到的数据，slab的存储是next指针</p><ul><li>如果next指针空，表示bucket查找结束，意味着hash table不存在目标key<br>查找目标lane将查找结果返回，并结束其查找任务 <code>to_be_searched = false</code></li><li>next指针不为空，表示需要继续查找bucket的下一个slab</li></ul></li><li><p>line 31~38 处理本次warp迭代找到目标key。<br>__shfl_sync拷贝found_lane+1读取到的数据，即目标key对应的value<br>查找目标lane将查找结果返回，并结束其查找任务 <code>to_be_searched = false</code></p></li></ul><p>可以看出key-value连续存储，而查找过程中，lane是连续读的，因此32个lane只能处理(16-1)个key-value对，最后一个是next指针。因此每个slab的大小是15个key-value对，末尾加上一个next指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint32_t</span> work_queue = <span class="hljs-number">0</span>;<br><span class="hljs-type">uint32_t</span> last_work_queue = work_queue;<br><span class="hljs-type">uint32_t</span> next = SlabHashT::A_INDEX_POINTER;<br> <br><span class="hljs-keyword">while</span> ((work_queue = __ballot_sync(<span class="hljs-number">0xFFFFFFFF</span>, to_be_searched))) &#123;<br>    next = (last_work_queue != work_queue) ? SlabHashT::A_INDEX_POINTER<br>                                           : next;  <span class="hljs-comment">// a successfull insertion in the warp</span><br>    <span class="hljs-type">uint32_t</span> src_lane = __ffs(work_queue) - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">uint32_t</span> src_bucket = __shfl_sync(<span class="hljs-number">0xFFFFFFFF</span>, bucket_id, src_lane, <span class="hljs-number">32</span>);<br>    <span class="hljs-type">uint32_t</span> wanted_key = __shfl_sync(<span class="hljs-number">0xFFFFFFFF</span>,<br>                                      *<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*&gt;(<br>                                          <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(&amp;myKey)),<br>                                      src_lane,<br>                                      <span class="hljs-number">32</span>);<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> src_unit_data = (next == SlabHashT::A_INDEX_POINTER)<br>                                       ? *(<span class="hljs-built_in">getPointerFromBucket</span>(src_bucket, laneId))<br>                                       : *(<span class="hljs-built_in">getPointerFromSlab</span>(next, laneId));<br>    <span class="hljs-type">int</span> found_lane = __ffs(__ballot_sync(<span class="hljs-number">0xFFFFFFFF</span>, src_unit_data == wanted_key) &amp;<br>                           SlabHashT::REGULAR_NODE_KEY_MASK) -<br>                     <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (found_lane &lt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// not found</span><br>        <span class="hljs-type">uint32_t</span> next_ptr = __shfl_sync(<span class="hljs-number">0xFFFFFFFF</span>, src_unit_data, <span class="hljs-number">31</span>, <span class="hljs-number">32</span>);<br>        <span class="hljs-keyword">if</span> (next_ptr == SlabHashT::EMPTY_INDEX_POINTER) &#123;  <span class="hljs-comment">// not found</span><br>            <span class="hljs-keyword">if</span> (laneId == src_lane) &#123;<br>                myValue = <span class="hljs-built_in">static_cast</span>&lt;ValueT&gt;(SEARCH_NOT_FOUND);<br>                to_be_searched = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            next = next_ptr;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// found the key:</span><br>        <span class="hljs-type">uint32_t</span> found_value = __shfl_sync(<span class="hljs-number">0xFFFFFFFF</span>, src_unit_data, found_lane + <span class="hljs-number">1</span>, <span class="hljs-number">32</span>);<br>        <span class="hljs-keyword">if</span> (laneId == src_lane) &#123;<br>            myValue = *<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> ValueT*&gt;(<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(&amp;found_value));<br>            to_be_searched = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    last_work_queue = work_queue;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-insertPair"><a href="#1-2-insertPair" class="headerlink" title="1.2 insertPair"></a>1.2 insertPair</h2><p>查找到empty slot后，将新的key-value放入该位置。该插入方式不会查找被插入key是否已存在。</p><p>函数声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">GpuSlabHashContext&lt;KeyT, ValueT, SlabHashTypeT::ConcurrentMap&gt;::<span class="hljs-built_in">insertPair</span>(<br>    <span class="hljs-type">bool</span>&amp; to_be_inserted,<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>&amp; laneId,<br>    <span class="hljs-type">const</span> KeyT&amp; myKey,<br>    <span class="hljs-type">const</span> ValueT&amp; myValue,<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> bucket_id,<br>    AllocatorContextT&amp; local_allocator_ctx)<br></code></pre></td></tr></table></figure><p>函数实现如下：</p><ul><li><p>line 5~14 与searchKey过程相同。组装work_queue、获取目标查找数据以及查找位置的数据</p></li><li><p>line 17~18 比较warp各线程查找位置是否为空，即比较查找位置数据与EMPTY_KEY</p></li><li><p>line 19~40 当前warp迭代没有找到empty slot<br>__shfl_sync 从warp最后一个lane获取next指针</p><ul><li>line 21~37 如果next指针为空，则申请新的结点</li></ul></li><li><p>line 41~57 当前warp迭代找到empty slot<br>line 42 __ffs得到最小empty slot位置对应的lane <code>dest_lane</code></p><ul><li><p>line 43~57 查找目标lane在 <code>dest_lane</code>的查找位置执行最后的插入操作<br>为了保证插入操作的原子性，key-value 组成64 bit，使用 atomicCAS 原语操作</p><blockquote><p>如果key 64bit，value 32bit，此时超过了原子类型长度，应该怎么做？</p><p>方案1：if (atomicCAS(dest_key, EMPTY_KEY, key) &#x3D;&#x3D; EMPTY_KEY)  dest_value &#x3D; value;</p><p>这样不可行，因为 atomicCAS 成功后，又来了另一个对同一key的update操作，会导致数据错误</p><p>方案2：key 64bit的最高位作为保留位，1表示锁，0表示未锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">lock_key = key || <span class="hljs-number">0x8FFFFFFFFFFFFFFF</span>;<br><span class="hljs-keyword">while</span> (dest_key &amp; <span class="hljs-number">0x7FFFFFFFFFFFFFFF</span> == key) &#123;<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-built_in">atomicCAS</span>(dest_key, key, lock_key)) &#123;<span class="hljs-comment">// lock</span><br>        update value;<br>        <span class="hljs-built_in">atomicCAS</span>(dest_key, lock_key, key);<span class="hljs-comment">// unlock</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>插入成功则终止本迭代的目标插入操作 <code>to_be_inserted = false</code>。否则继续迭代执行</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint32_t</span> work_queue = <span class="hljs-number">0</span>;<br><span class="hljs-type">uint32_t</span> last_work_queue = <span class="hljs-number">0</span>;<br><span class="hljs-type">uint32_t</span> next = SlabHashT::A_INDEX_POINTER;<br><br><span class="hljs-keyword">while</span> ((work_queue = __ballot_sync(<span class="hljs-number">0xFFFFFFFF</span>, to_be_inserted))) &#123;<br>    <span class="hljs-comment">// to know whether it is a base node, or a regular node</span><br>    next = (last_work_queue != work_queue) ? SlabHashT::A_INDEX_POINTER<br>                                           : next;  <span class="hljs-comment">// a successfull insertion in the warp</span><br>    <span class="hljs-type">uint32_t</span> src_lane = __ffs(work_queue) - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">uint32_t</span> src_bucket = __shfl_sync(<span class="hljs-number">0xFFFFFFFF</span>, bucket_id, src_lane, <span class="hljs-number">32</span>);<br><br>    <span class="hljs-type">uint32_t</span> src_unit_data = (next == SlabHashT::A_INDEX_POINTER)<br>                                 ? *(<span class="hljs-built_in">getPointerFromBucket</span>(src_bucket, laneId))<br>                                 : *(<span class="hljs-built_in">getPointerFromSlab</span>(next, laneId));<br>    <span class="hljs-type">uint64_t</span> old_key_value_pair = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">uint32_t</span> isEmpty = (__ballot_sync(<span class="hljs-number">0xFFFFFFFF</span>, src_unit_data == EMPTY_KEY)) &amp;<br>                       SlabHashT::REGULAR_NODE_KEY_MASK;<br>    <span class="hljs-keyword">if</span> (isEmpty == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// no empty slot available:</span><br>      <span class="hljs-type">uint32_t</span> next_ptr = __shfl_sync(<span class="hljs-number">0xFFFFFFFF</span>, src_unit_data, <span class="hljs-number">31</span>, <span class="hljs-number">32</span>);<br>      <span class="hljs-keyword">if</span> (next_ptr == SlabHashT::EMPTY_INDEX_POINTER) &#123;<br>        <span class="hljs-comment">// allocate a new node:</span><br>        <span class="hljs-type">uint32_t</span> new_node_ptr = <span class="hljs-built_in">allocateSlab</span>(local_allocator_ctx, laneId);<br><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> experiment if it&#x27;s better to use lane 0 instead</span><br>        <span class="hljs-keyword">if</span> (laneId == <span class="hljs-number">31</span>) &#123;<br>          <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>* p = (next == SlabHashT::A_INDEX_POINTER)<br>                                  ? <span class="hljs-built_in">getPointerFromBucket</span>(src_bucket, <span class="hljs-number">31</span>)<br>                                  : <span class="hljs-built_in">getPointerFromSlab</span>(next, <span class="hljs-number">31</span>);<br><br>          <span class="hljs-type">uint32_t</span> temp = <span class="hljs-built_in">atomicCAS</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>*)p, SlabHashT::EMPTY_INDEX_POINTER, new_node_ptr);<br>          <span class="hljs-comment">// check whether it was successful, and</span><br>          <span class="hljs-comment">// free the allocated memory otherwise</span><br>          <span class="hljs-keyword">if</span> (temp != SlabHashT::EMPTY_INDEX_POINTER) &#123;<br>            <span class="hljs-built_in">freeSlab</span>(new_node_ptr);<br>          &#125;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>next = next_ptr;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// there is an empty slot available</span><br>      <span class="hljs-type">int</span> dest_lane = __ffs(isEmpty &amp; SlabHashT::REGULAR_NODE_KEY_MASK) - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (laneId == src_lane) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>* p = (next == SlabHashT::A_INDEX_POINTER)<br>                                ? <span class="hljs-built_in">getPointerFromBucket</span>(src_bucket, dest_lane)<br>                                : <span class="hljs-built_in">getPointerFromSlab</span>(next, dest_lane);<br><br>        old_key_value_pair = <span class="hljs-built_in">atomicCAS</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span>*)p,<br>                      EMPTY_PAIR_64,<br>                      ((<span class="hljs-type">uint64_t</span>)(*<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*&gt;(<br>                           <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(&amp;myValue)))<br>                       &lt;&lt; <span class="hljs-number">32</span>) |<br>                          *<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*&gt;(<br>                              <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(&amp;myKey)));<br>        <span class="hljs-keyword">if</span> (old_key_value_pair == EMPTY_PAIR_64)<br>          to_be_inserted = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// succesfful insertion</span><br>      &#125;<br>    &#125;<br>last_work_queue = work_queue;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-insertPairUnique"><a href="#1-3-insertPairUnique" class="headerlink" title="1.3 insertPairUnique"></a>1.3 insertPairUnique</h2><p>查找是否存在目标key，如果不存在插入到empty slot，存在则无操作。</p><p>函数声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">GpuSlabHashContext&lt;KeyT, ValueT, SlabHashTypeT::ConcurrentMap&gt;::<span class="hljs-built_in">insertPairUnique</span>(<br>    <span class="hljs-type">bool</span>&amp; to_be_inserted,<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>&amp; laneId,<br>    <span class="hljs-type">const</span> KeyT&amp; myKey,<br>    <span class="hljs-type">const</span> ValueT&amp; myValue,<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> bucket_id,<br>    AllocatorContextT&amp; local_allocator_ctx)<br></code></pre></td></tr></table></figure><p>函数实现如下：</p><ul><li>line 5~14与searchKey过程相同。组装work_queue，以及获取目标查找数据<br>line 20 获取目标查找key src_key </li><li>line 17<del>18 获取本次warp迭代，哪些lane查找到了empty slot<br>line 21</del>22 获取本次warp迭代，哪个lane查找到了目标key</li><li>line 23~25 存在目标key时，结束查找任务</li><li>line 26~66 不存在目标key时，选择插入到empty slot<ul><li><p>line 27~47 没有empty slot<br>得到next指针</p><ul><li>如果next指针是空，则需要申请新的slab</li><li>如果next指针不为空，则移动到next执行下次warp迭代</li></ul></li><li><p>line 48~64 存在empty slot。<br>最小索引的empty slot作为目标插入位置，dest_lane</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint32_t</span> work_queue = <span class="hljs-number">0</span>;<br><span class="hljs-type">uint32_t</span> last_work_queue = <span class="hljs-number">0</span>;<br><span class="hljs-type">uint32_t</span> next = SlabHashT::A_INDEX_POINTER;<br><span class="hljs-type">bool</span> new_insertion = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> ((work_queue = __ballot_sync(<span class="hljs-number">0xFFFFFFFF</span>, to_be_inserted))) &#123;<br><span class="hljs-comment">// to know whether it is a base node, or a regular node</span><br>next = (last_work_queue != work_queue) ? SlabHashT::A_INDEX_POINTER<br>                                           : next;  <span class="hljs-comment">// a successful insertion in the warp</span><br>    <span class="hljs-type">uint32_t</span> src_lane = __ffs(work_queue) - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">uint32_t</span> src_bucket = __shfl_sync(<span class="hljs-number">0xFFFFFFFF</span>, bucket_id, src_lane, <span class="hljs-number">32</span>);<br><br>    <span class="hljs-type">uint32_t</span> src_unit_data = (next == SlabHashT::A_INDEX_POINTER)<br>                                 ? *(<span class="hljs-built_in">getPointerFromBucket</span>(src_bucket, laneId))<br>                                 : *(<span class="hljs-built_in">getPointerFromSlab</span>(next, laneId));<br>    <span class="hljs-type">uint64_t</span> old_key_value_pair = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">uint32_t</span> isEmpty = (__ballot_sync(<span class="hljs-number">0xFFFFFFFF</span>, src_unit_data == EMPTY_KEY)) &amp;<br>                       SlabHashT::REGULAR_NODE_KEY_MASK;<br><br>    <span class="hljs-type">uint32_t</span> src_key = __shfl_sync(<span class="hljs-number">0xFFFFFFFF</span>, myKey, src_lane, <span class="hljs-number">32</span>);<br>    <span class="hljs-type">uint32_t</span> isExisting = (__ballot_sync(<span class="hljs-number">0xFFFFFFFF</span>, src_unit_data == src_key)) &amp;<br>                          SlabHashT::REGULAR_NODE_KEY_MASK;<br>    <span class="hljs-keyword">if</span> (isExisting) &#123;  <span class="hljs-comment">// key exist in the hash table</span><br>      <span class="hljs-keyword">if</span> (laneId == src_lane)<br>        to_be_inserted = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (isEmpty == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// no empty slot available:</span><br>        <span class="hljs-type">uint32_t</span> next_ptr = __shfl_sync(<span class="hljs-number">0xFFFFFFFF</span>, src_unit_data, <span class="hljs-number">31</span>, <span class="hljs-number">32</span>);<br>        <span class="hljs-keyword">if</span> (next_ptr == SlabHashT::EMPTY_INDEX_POINTER) &#123;<br>          <span class="hljs-comment">// allocate a new node:</span><br>          <span class="hljs-type">uint32_t</span> new_node_ptr = <span class="hljs-built_in">allocateSlab</span>(local_allocator_ctx, laneId);<br><br>          <span class="hljs-keyword">if</span> (laneId == <span class="hljs-number">31</span>) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>* p = (next == SlabHashT::A_INDEX_POINTER)<br>                                    ? <span class="hljs-built_in">getPointerFromBucket</span>(src_bucket, <span class="hljs-number">31</span>)<br>                                    : <span class="hljs-built_in">getPointerFromSlab</span>(next, <span class="hljs-number">31</span>);<br><br>            <span class="hljs-type">uint32_t</span> temp = <span class="hljs-built_in">atomicCAS</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>*)p, SlabHashT::EMPTY_INDEX_POINTER, new_node_ptr);<br>            <span class="hljs-comment">// check whether it was successful, and</span><br>            <span class="hljs-comment">// free the allocated memory otherwise</span><br>            <span class="hljs-keyword">if</span> (temp != SlabHashT::EMPTY_INDEX_POINTER) &#123;<br>              <span class="hljs-built_in">freeSlab</span>(new_node_ptr);<br>            &#125;<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          next = next_ptr;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// there is an empty slot available</span><br>        <span class="hljs-type">int</span> dest_lane = __ffs(isEmpty &amp; SlabHashT::REGULAR_NODE_KEY_MASK) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (laneId == src_lane) &#123;<br>          <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>* p = (next == SlabHashT::A_INDEX_POINTER)<br>                                  ? <span class="hljs-built_in">getPointerFromBucket</span>(src_bucket, dest_lane)<br>                                  : <span class="hljs-built_in">getPointerFromSlab</span>(next, dest_lane);<br><br>          old_key_value_pair = <span class="hljs-built_in">atomicCAS</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span>*)p,<br>                        EMPTY_PAIR_64,<br>                        ((<span class="hljs-type">uint64_t</span>)(*<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*&gt;(<br>                             <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(&amp;myValue))) &lt;&lt; <span class="hljs-number">32</span>) |<br>                            *<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span>*&gt;(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(&amp;myKey)));<br>          <span class="hljs-keyword">if</span> (old_key_value_pair == EMPTY_PAIR_64) &#123;<br>            to_be_inserted = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// successful insertion</span><br>            new_insertion = <span class="hljs-literal">true</span>;<br>          &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>last_work_queue = work_queue;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="[1]">[1]</a> <a href="https://github.com/owensgroup/SlabHash">https://github.com/owensgroup/SlabHash</a></p><p><a name="[2]">[2]</a> S. Ashkiani, M. Farach-Colton, and J. D. Owens, “A dynamic hash table for the gpu,” in 2018 IEEE International Parallel and Distributed Processing Symposium (IPDPS). IEEE, 2018, pp. 419–429.   </p>]]></content>
    
    
    <categories>
      
      <category>Rendering Blogs</category>
      
      <category>GPGPU</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/10/19/Rendering%20Blogs/GPGPU/Non-blocking%20Array-Based%20Stack/"/>
    <url>/2023/10/19/Rendering%20Blogs/GPGPU/Non-blocking%20Array-Based%20Stack/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DACHash A Dynamic, Cache-Aware and Concurrent Hash Table on GPUs</title>
    <link href="/2023/10/15/Paper%20Notes/GPGPU/DACHash%20A%20Dynamic,%20Cache-Aware%20and%20Concurrent%20Hash%20Table%20on%20GPUs/"/>
    <url>/2023/10/15/Paper%20Notes/GPGPU/DACHash%20A%20Dynamic,%20Cache-Aware%20and%20Concurrent%20Hash%20Table%20on%20GPUs/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Summary"><a href="#1-Summary" class="headerlink" title="1 Summary"></a>1 Summary</h1><p>对于GPU的高并发以及SIMT(Single Instruction Multiple Threads)执行模型而言，cache命中率对性能的影响很大。作者提出reorder算法提高对hash table数据访问的局部性，这也是该方向的首次研究与尝试。</p><h1 id="2-Basic-Design-and-Implementation"><a href="#2-Basic-Design-and-Implementation" class="headerlink" title="2 Basic Design and Implementation"></a>2 Basic Design and Implementation</h1><p>本章节介绍了DACHash的基础设计与实现，包括数据结构、hash table的操作与内存管理。</p><h2 id="2-1-Base-Data-Structure-and-Organization"><a href="#2-1-Base-Data-Structure-and-Organization" class="headerlink" title="2.1 Base Data Structure and Organization"></a>2.1 Base Data Structure and Organization</h2><p>hash table的bucket是一个以小型数组为结点(super node)的链表，其中数组的每个元素是key-value对，如下图所示。连接bucket头的super node是预先分配好的，后续super node则是实时动态分配与释放的。</p><img src="/images/Paper Notes/GPGPU/DACHash A Dynamic, Cache-Aware and Concurrent Hash Table on GPUs.assets/image-20231015135803985.png" alt="image-20231015135803985" style="zoom: 67%;"><blockquote><p>这种数组的链表结构对于哈希表而言更像是一种对开放地址与拉链法的折衷，既能方便解决冲突，又能支持GPU-friendly的并行(数组具有高cache命中率)。</p></blockquote><h2 id="2-2-Operations"><a href="#2-2-Operations" class="headerlink" title="2.2 Operations"></a>2.2 Operations</h2><p>作者通过cuda的atomic functions实现了hash table的常见操作</p><h3 id="2-2-1-Search"><a href="#2-2-1-Search" class="headerlink" title="2.2.1 Search"></a>2.2.1 Search</h3><p>search操作用于在hash table中查找给定key，并返回对应的value。如果没有找到key，则返回null。执行过程：</p><ul><li>key经过hash定位到bucket</li><li>从bucket第一个super node逐条查找，直到<ul><li>找到对应key，返回value</li><li>查找到bucket链表末尾，返回null</li></ul></li></ul><h3 id="2-2-2-Insert"><a href="#2-2-2-Insert" class="headerlink" title="2.2.2 Insert"></a>2.2.2 Insert</h3><p>insert操作添加一个key-value对到hash table中。执行过程：</p><ul><li>如果key已经存在于hash table中，那么insert表现为与update相同的操作。</li><li>如果key不存在，查找一个empty slot，并插入新的key-value对，这可能会带来super node的动态申请<ul><li>在bucket的链表中查找一个empty slot，使用 atomicCAS。</li><li>如果查找到链表最后，没有找到empty slot，申请一个新的super node。使用 atomicCAS 链接到bucket链表末尾。<ul><li>可能同时有多个线程尝试链接自己申请的super node到bucket末尾，但只会有一个成功</li><li>失败的线程释放掉申请的super node，在bucket新的尾结点重新尝试插入操作</li></ul></li></ul></li></ul><h3 id="2-2-3-Update"><a href="#2-2-3-Update" class="headerlink" title="2.2.3 Update"></a>2.2.3 Update</h3><p>update操作查找一个key并更新对应值。如果key能找到，那么使用 atmoicExch 更新value。如果key找不到，那么执行insert操作。</p><h3 id="2-2-4-Delete"><a href="#2-2-4-Delete" class="headerlink" title="2.2.4 Delete"></a>2.2.4 Delete</h3><p>delete操作将指定key标记为deleted，与search操作类似，只是没有返回值。执行过程：</p><ul><li>从bucket第一个super node开始遍历，直至<ul><li>找到对应key，标记为deleted</li><li>遍历到bucket链表末尾</li></ul></li></ul><h3 id="2-2-5-Clean"><a href="#2-2-5-Clean" class="headerlink" title="2.2.5 Clean"></a>2.2.5 Clean</h3><p>clean操作紧凑bucket的super node链表，确保只有最后一个super node有empty slot。clean操作在单独的kernel执行(对应compute pass)，所以不会有其它操作的妨碍。clean操作只会在memory stack空的时候执行，会将空super node释放，放回memory stack。</p><h2 id="2-3-Memory-Stack"><a href="#2-3-Memory-Stack" class="headerlink" title="2.3 Memory Stack"></a>2.3 Memory Stack</h2><p>insert、update、delete、clean操作可能需要super node的动态申请与释放。为此，预分配大量super nodes，并放入concurrent stack，如下图所示</p><ul><li>pop：申请一个super node</li><li>push：释放一个super node</li></ul><img src="/images/Paper Notes/GPGPU/DACHash A Dynamic, Cache-Aware and Concurrent Hash Table on GPUs.assets/image-20231015151513845.png" alt="image-20231015151513845" style="zoom: 67%;"><center>Fig 2: 线程t0与t1同时访问concurrent memory stack</center><p>这里作者没有给出实际的算法。自己调研了下GPU上并行栈的算法，基本核心都是解决 ABA problem<a href="#%5B3%5D">[3]</a> ，但本文中的memory stack中没有重复元素，因此可以简单实现。</p><p>contention处理：当多个线程同时竞争同一top指针时，每个线程迭代执行直到操作完成，可以看作一次迭代只会有一个线程完成操作。这里以glsl的原子操作介绍实现：</p><ul><li><p>使用 <code>atomicAdd</code> 得到target_top，即当前线程操作的目标位置。</p><p>多线程同时竞争到同一top指针时，只有当目标位置满足操作要求时，才会完成操作。例如push操作需要目标位置为空，pop操作需要目标位置不为空</p></li><li><p>使用 <code>atomicCompSwap</code> 来循环判断目标位置是否满足条件。</p></li></ul><p>实现如下</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">void</span> push(<span class="hljs-type">uint</span> value)<br>&#123;<br>    <span class="hljs-type">uint</span> target_top = <span class="hljs-built_in">atomicAdd</span>(top, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (target_top &gt;= STACK_SIZE) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// 栈满</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">atomicCompSwap</span>(concurrent_stack[target_top], EMPTY_NODE_INDEX, value) != EMPTY_NODE_INDEX);<br>&#125;<br><br><span class="hljs-type">uint</span> pop()<br>&#123;<br>    <span class="hljs-type">uint</span> target_top = <span class="hljs-built_in">atomicAdd</span>(top, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">if</span> (target_top &gt;= STACK_SIZE) <span class="hljs-keyword">return</span> EMPTY_NODE_INDEX;   <span class="hljs-comment">// 栈空，溢出</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">uint</span> value = <span class="hljs-built_in">atomicAnd</span>(concurrent_stack[target_top], <span class="hljs-number">0xFFFFFFFFFFFFFFFF</span>);<br>        <span class="hljs-keyword">if</span> (value != EMPTY_NODE_INDEX &amp;&amp; <span class="hljs-built_in">atomicCompSwap</span>(concurrent_stack[target_top], value, EMPTY_NODE_INDEX) == value) &#123;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> EMPTY_NODE_INDEX;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-Reorder"><a href="#3-Reorder" class="headerlink" title="3 Reorder"></a>3 Reorder</h1><p>如果一个warp的输入keys被哈希到不同的bucket中，由于bucket之间或之内的super node在内存中是分散的，因此这个warp的线程发出的内存请求很可能位于不同的cache line(uncoalesced)，而不是同一个cache line(coalesced)。也就是说，这个warp具有较差的局部性。</p><p>SlabHash<a href="#%5B2%5D">[2]</a> 提出了wrap内的 work-sharing 策略来提高coalesced memory access。该策略大概是一个warp并行处理一个super node，即一次执行单个key，这样warp的线程只需要一次全局内存访问，后续都只在cache中。但对于链表的遍历过程，该策略可能会重复遍历，带来较差的局部性问题。</p><p>下图描述了一个cache命中率较低的访问示例。假设一个大小为4的warp要处理keys <code>&#123;0, 3, 7, 8&#125;</code>，处理过程如下：</p><ul><li>warp处理key 0，对应bucket 0，并加载了第一个super node。但加载super node同时加载的其它key并未被使用到。处理其它key也会遇到这种情况。</li><li>warp再处理key 3、key 7，遇到了同样的问题。同时，随着bucket 3与bucket 7的super node的加载，key 0的数据很可能从cache中被逐出。</li><li>warp处理key 8，bucket 0的第一个super node再次被加载，降低了cache命中率。</li></ul><p>![image-20231015170725329](&#x2F;images&#x2F;Paper Notes&#x2F;GPGPU&#x2F;DACHash A Dynamic, Cache-Aware and Concurrent Hash Table on GPUs.assets&#x2F;image-20231015170725329.png)</p><p>为了提高链表遍历过程中的cache命中率，作者提出对keys的reorder算法，将相同hash value的keys组织在一起。这一步是将super node的内存区进行划分，通过reorder算法，使得相同hash value的key的super node在物理上也相邻。</p><p>Algorithm1描述了reorder算法的伪代码过程，关键变量有：</p><ul><li>二维数组 buffer <code>ReorderSpace[B][M]</code>，其中 B 为bucket数量，M &#x3D; ceil(N&#x2F;B)，N为 keysList 的大小。<ul><li>行索引定位为 bucket value</li><li>列索引为bucket内存区域的index</li><li>值为key</li></ul></li><li><code>Record[B]</code> 用来追踪每个bucket的最新index</li></ul><p>关键处理有：</p><ul><li><p>line 8：分配一个bucket内存区域的index。相同bucket的key是会被映射到 <code>ReorderSpace</code> 的同一行</p></li><li><p>line 9-11：<code>ReorderSpace</code> 的M其实是认为keys能够在bucket间均匀分布，但这一点很可能不满足。当不均匀发生时，就会出现 index &gt;&#x3D; M 的情况。</p><p>在 index 超出范围时，尝试使用下一个bucket的index，直至满足条件。</p></li><li><p>line 12：最终将key加到 <code>ReorderSpace</code> 中</p></li></ul><img src="/images/Paper Notes/GPGPU/DACHash A Dynamic, Cache-Aware and Concurrent Hash Table on GPUs.assets/image-20231015174307884.png" alt="image-20231015174307884" style="zoom: 60%;"><p>只有在reorder完成后，后续的操作才能被执行，因此这里需要加上同步操作。同时为了加快reorder以及节省内存，也可以选择将相近的hash value组织在一起，例如 line 3 将 B 改为 (B&#x2F;4)。</p><blockquote><p>这个岂不是需要提前得到要处理的 keys，大概是接收到keys后需要先进行reorder，再执行后续的操作。</p></blockquote><h1 id="4-Dynamic-Mapping-Schemes"><a href="#4-Dynamic-Mapping-Schemes" class="headerlink" title="4 Dynamic Mapping Schemes"></a>4 Dynamic Mapping Schemes</h1><p>在以thread group处理一批keys时，有两种 thread-data mapping模式：</p><ul><li><p>one-to-one mapping scheme：每个线程负责一个key，因此warp的32个线程可以独立地处理32个keys中的一个。</p><p>由于32个key很可能hash到不同的bucket，因此这种模式的内存访问是比较分散的。</p><p>由于查找过程是独立的，因此这部分操作很可能有差异，导致一个warp的线程退出时间不同。</p></li><li><p>many-to-one mapping scheme：一个warp的线程共同协作处理32个key，一次处理一个key。</p><p>key的查找过程使用warp的线程并行处理一个super node，访存更连续。</p><p>由于并行处理一个key，过程基本都是一样的，一个warp的线程会汇聚到一个时间点。之后再处理不同的操作。</p></li></ul><p>作者提出按照如下方式动态选择mapping模式<br>$$<br>D &#x3D; \left{<br>\begin{array} {rcl}<br>O \quad \quad if \quad \epsilon &lt; \tau \<br>M \quad \quad otherwise</p><p>\end{array}<br>\right.<br>$$<br>其中，$O$ 是 one-to-one，$M$ 是 many-to-one；$\epsilon$ 是 expected length，即bucket包含的super node数量的平均值；$\tau$ 是调控的阈值。</p><p>下面是两种mapping模式的算法伪代码。可以看出，one-to-one模式下，每个线程都独立处理一个key，每个key的查找过程可能不同、操作可能不同，因此它们的完成时间也可能不同，导致较低的执行效率。many-to-one模式下，将线程划分成 CG_SIZE 大小的tile，一个tile协同处理一个key，tile内可以使用cuda <code>shfl()</code> 与 <code>ballot()</code>原子操作来通信，tile执行的底层指令更可能相同。</p><p><img src="/images/Paper Notes/GPGPU/DACHash A Dynamic, Cache-Aware and Concurrent Hash Table on GPUs.assets/image-20231016134758480.png" alt="image-20231016134758480" style="zoom:50%;"><img src="/images/Paper Notes/GPGPU/DACHash A Dynamic, Cache-Aware and Concurrent Hash Table on GPUs.assets/image-20231016134839642.png" alt="image-20231016134839642" style="zoom:50%;"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a name="[1]">[1]</a> Zhou, H., Troendle, D., Jang, B., 2021. DACHash: A Dynamic, Cache-Aware and Concurrent Hash Table on GPUs, in: 2021 IEEE 33rd International Symposium on Computer Architecture and High Performance Computing (SBAC-PAD). pp. 1–10. <a href="https://doi.org/10.1109/SBAC-PAD53543.2021.00012">https://doi.org/10.1109/SBAC-PAD53543.2021.00012</a></p><p><a name="[2]">[2]</a> S. Ashkiani, M. Farach-Colton, and J. D. Owens, “A dynamic hash table for the gpu,” in 2018 IEEE International Parallel and Distributed Processing Symposium (IPDPS). IEEE, 2018, pp. 419–429  </p><p>[3] <a href="https://en.wikipedia.org/wiki/ABA_problem">https://en.wikipedia.org/wiki/ABA_problem</a></p>]]></content>
    
    
    <categories>
      
      <category>Paper Notes</category>
      
      <category>GPGPU</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Compute Shader 实现 Pyramid Algorithm</title>
    <link href="/2023/09/20/Vulkan%20Basics/Compute%20Shader%20%E5%AE%9E%E7%8E%B0%20Pyramid%20Algorithm/"/>
    <url>/2023/09/20/Vulkan%20Basics/Compute%20Shader%20%E5%AE%9E%E7%8E%B0%20Pyramid%20Algorithm/</url>
    
    <content type="html"><![CDATA[<h1 id="使用-compute-shader-生成-mipmap"><a href="#使用-compute-shader-生成-mipmap" class="headerlink" title="使用 compute shader 生成 mipmap"></a>使用 compute shader 生成 mipmap</h1><p>本文是参考 <a href="https://github.com/nvpro-samples/vk_compute_mipmaps">https://github.com/nvpro-samples/vk_compute_mipmaps</a> 的算法复现。</p><p>将输入层级记为 $L$，将 $L$ 的 2x2 样本区域生成一个样本则得到 $L+1$ 层级。下面介绍从 $L$ 到 $L+M$ 层级的生成算法，$M\in[1,6]$，算法输入为 $L$ 层级的大小为 $2^M\times 2^M$ 的 tiles。</p><h1 id="宽高为-2-的幂次"><a href="#宽高为-2-的幂次" class="headerlink" title="宽高为 2 的幂次"></a>宽高为 2 的幂次</h1><p>首先将输入层级划分为多个大小为 $2^M\times 2^M$ 的 tile，每个 tile 作为 compute shader 中一个 local workgroup 的输入 tile，每个 local workgroup 负责生成其输入 tile 的层级。假设输入层级大小为 $X,Y$，那么一次 dispatch 产生的 local workgroup 数量为 $(X&#x2F;2^M, Y&#x2F;2^M)$，因此使用 workgroup id 作为 tile id，进而得到输入 tile 在输入层级中的起始位置，用以获取输入层级的样本。</p><ul><li><p>假设 workgroup id 为 $(m,n)$，该 workgroup 的输入 tile id 为 $(m,n)$。该输入 tile 在输入层级中的起始位置设为 (xOffset, yOffset)，其计算方式为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">xOffset = m &lt;&lt; M;<br>yOffset = n &lt;&lt; M;<br></code></pre></td></tr></table></figure></li><li><p>为了能够利用到 subgroup 内部数据同步的高效性，将 workgroup 的线程&#x2F;invocation 划分为大小为 16 的子组。这里使用 1D 的 invocation ID，<code>gl_LocalInvocationIndex</code> 来划分组，划分方式为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">teamID = (ID &amp; <span class="hljs-number">0x00F0</span>) &gt;&gt; <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure></li><li><p>想要生成当前层级的样本，则需要确定当前层级样本在上一层级中对应的 $2\times 2$ 区域，即该区域在上一层级中的起始偏移量 (xBlockOffset, yBlockOffset)。该偏移量有三部分组成，当前 workgroup 对应的输入 tile 在输入层级中的起始偏移量 (xOffset, yOffset)、当前 invocation 所属组在输入 tile 中的起始偏移量 (tx, ty)、当前 invocation 在其所属组的起始偏移量 (x, y)。最终有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">xBlockOffset = xOffset + tx + x;<br>yBlockOffset = yOffset + ty + y;<br></code></pre></td></tr></table></figure></li></ul><h2 id="1-Level"><a href="#1-Level" class="headerlink" title="1-Level"></a>1-Level</h2><p>输入层级划分为 $2\times 2$ tiles，每个线程加载一个 $2\times2$ tile 生成一个样本。1 level 算法比较简单，输入层级有多少个 $2\times 2$ tiles 就分发多少个 invocation，即 global group size 与 tile 数量相等。直接使用 <code>gl_GlobalInvocationID</code> 来索引 $L$ 层级的样本。以下为一个 tile 中的 4 个样本的索引</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-built_in">gl_GlobalInvocationID</span>*<span class="hljs-number">4</span>+<span class="hljs-number">0</span>, <span class="hljs-built_in">gl_GlobalInvocationID</span>*<span class="hljs-number">4</span>+<span class="hljs-number">1</span>, <br><span class="hljs-built_in">gl_GlobalInvocationID</span>*<span class="hljs-number">4</span>+<span class="hljs-number">2</span>, <span class="hljs-built_in">gl_GlobalInvocationID</span>*<span class="hljs-number">4</span>+<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>或者按照下述算法形式实现。</p><h2 id="2-Levels"><a href="#2-Levels" class="headerlink" title="2-Levels"></a>2-Levels</h2><p>输入层级划分为 $4\times 4$ tiles，local workgroup size 使用 4。一个输入 tile 可以划分为 4 个 $2\times 2$ blocks，每个 block 对应 $L+1$ 层的一个样本。因此每个 local workgroup 负责一个输入 tile，生成 4 个 $L+1$ 层级样本，4 个 $L+1$ 层级样本又可生成 1 个 $L+2$  层级样本。算法过程如下示意，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">   <span class="hljs-built_in">L</span>(<span class="hljs-number">4</span>x4)            L<span class="hljs-number">+1</span>(<span class="hljs-number">2</span>x2)             L<span class="hljs-number">+2</span><br>+---------+       +-----+-----+       +---------+<br>|         |       |  <span class="hljs-number">0</span>  |  <span class="hljs-number">1</span>  |       |         |<br>|   <span class="hljs-number">4</span>x4   | ===&gt;  +-----+-----+ ====&gt; |    <span class="hljs-number">0</span>    |<br>|         |       |  <span class="hljs-number">2</span>  |  <span class="hljs-number">3</span>  |       |         |<br>+---------+       +-----+-----+       +---------+<br></code></pre></td></tr></table></figure><p>确定 $L+1$ 层每个样本在 $L$ 层对应的 $2\times 2$ block 的起始位置，</p><ul><li><p>输入 tile 在 $L$ 层级的起始位置：$M&#x3D;2$ 代入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">xOffset = m &lt;&lt; M;<br>yOffset = n &lt;&lt; M;<br></code></pre></td></tr></table></figure></li><li><p>local workgroup 内线程的分组 ID：由于 local workgroup size 为 4，因此只有一个分组，teamID 恒为 0，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">teamID = (ID &amp; <span class="hljs-number">0x00F0</span>) &gt;&gt; <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>当前分组在输入 tile 中的偏移量也恒为 tx&#x3D;0,  ty&#x3D;0</p></li><li><p>当前 invocation 在其所属分组的偏移量：<code>gl_LocalInvocationIndex</code> 为当前 invocation 的索引，记为 id。$L+1$ 层的 4 个样本如下，以及对应的组内偏移量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"> L<span class="hljs-number">+1</span> 样本编号       L<span class="hljs-number">+1</span> 样本编号二进制    L<span class="hljs-number">+1</span> 样本的组内起始偏移量<br>+-----+-----+       +-----+-----+       +-----+-----+<br>|  <span class="hljs-number">0</span>  |  <span class="hljs-number">1</span>  |       |  <span class="hljs-number">00</span> |  <span class="hljs-number">01</span> |       |(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)|(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)|<br>+-----+-----+       +-----+-----+       +-----+-----+<br>|  <span class="hljs-number">2</span>  |  <span class="hljs-number">3</span>  |       |  <span class="hljs-number">10</span> |  <span class="hljs-number">11</span> |       |(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)|(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)|<br>+-----+-----+       +-----+-----+       +-----+-----+<br></code></pre></td></tr></table></figure><p>当前 invocation 组内的偏移量的计算方式如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">x = (id &amp; <span class="hljs-number">2</span>);<br>y = (id &amp; <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li><li><p>最终得到 $L+1$ 层样本在 $L$ 层对应的 $2\times 2$ block 的起始偏移量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">xBlockOffset = xOffset + x;<br>yBlockOffset = yOffset + y;<br></code></pre></td></tr></table></figure></li></ul><p>得到 (xBlockOffset, yBlockOffset) 后，则可加载该 2x2 区域的 4 个 $L$ 层样本，即</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">(xBlockOffset<span class="hljs-number">+0</span>, yBlockOffset<span class="hljs-number">+0</span>), (xBlockOffset<span class="hljs-number">+0</span>, yBlockOffset<span class="hljs-number">+1</span>)<br>(xBlockOffset<span class="hljs-number">+1</span>, yBlockOffset<span class="hljs-number">+0</span>), (xBlockOffset<span class="hljs-number">+1</span>, yBlockOffset<span class="hljs-number">+1</span>)<br></code></pre></td></tr></table></figure><p>4 个 $L$ 层样本生成一个 $L+1$ 层样本，这样下来，每个 local workgroup 都得到了 $L+1$ 层级的 4 个样本。$L+1$ 层样本的写入位置为 (xBlockOffset &gt;&gt; 1, yBlockOffset &gt;&gt; 1)。</p><p>由于 local workgroup size 为 4，即 local workgroup 的所有 invocation 执行于同一个 subgroup，因此可利用 subgroup 内部的高效数据同步。每个 local workgroup 的 0 号线程再使用 <code>subgroupShuffleXor</code> 得到 1、2、3 号线程的样本，生成 $L+2$ 层级的一个样本，写入位置为 (xBlockOffset &gt;&gt; 2, yBlockOffset &gt;&gt; 2)。</p><h2 id="3-Levels"><a href="#3-Levels" class="headerlink" title="3-Levels"></a>3-Levels</h2><p>3 levels 通过不同区域分别应用 2 levels 算法。输入层级划分为 $8\times 8$ tiles，local workgroup size 使用 16。将 local workgroup 的 16 个线程分为 4 个 subtiles，每个 subtile 大小为 $2\times 2$，具有 4 个线程，如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">workgroup 内的 subtile，<span class="hljs-string">&quot;|| =&quot;</span> 为 subtile 边界<br>      +---+---++---+---+                              <br>      | <span class="hljs-number">0</span> | <span class="hljs-number">1</span> || <span class="hljs-number">4</span> | <span class="hljs-number">5</span> |                               <br>      +---+---++---+---+                              <br>      | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> || <span class="hljs-number">6</span> | <span class="hljs-number">7</span> |                              <br>      +===+===++===+===+                              <br>      | <span class="hljs-number">8</span> | <span class="hljs-number">9</span> ||<span class="hljs-number">12</span> |<span class="hljs-number">13</span> |                              <br>      +---+---++---+---+                               <br>      |<span class="hljs-number">10</span> |<span class="hljs-number">11</span> ||<span class="hljs-number">14</span> |<span class="hljs-number">15</span> |                               <br>      +---+---++---+---+                               <br></code></pre></td></tr></table></figure><p>local workgroup 的每个 subtile 应用 2 levels 算法来生成 $L+1$、$L+2$ 的样本，在执行完 2 levels 算法后，每个 subtile 得到一个 $L+2$ 层样本。每个 workgroup 共得到 4 个 $L+2$ 层样本，最后生成 1 个 $L+3$ 层样本，过程如下所示，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">     <span class="hljs-built_in">L</span>(<span class="hljs-number">8</span>x8)                  L<span class="hljs-number">+1</span>(<span class="hljs-number">4</span>x4)                  L<span class="hljs-number">+2</span>(<span class="hljs-number">2</span>x2)<br>+---------------+       +---+---++---+---+       +-------++-------+<br>|               |       | <span class="hljs-number">0</span> | <span class="hljs-number">1</span> || <span class="hljs-number">4</span> | <span class="hljs-number">5</span> |       |       ||       |<br>|               |       +---+---++---+---+       |   <span class="hljs-number">0</span>   ||   <span class="hljs-number">4</span>   |<br>|               |       | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> || <span class="hljs-number">6</span> | <span class="hljs-number">7</span> |       |       ||       |<br>|      <span class="hljs-number">8</span>x8      | ====&gt; +===+===++===+===+ ====&gt; +=======++=======+<br>|               |       | <span class="hljs-number">8</span> | <span class="hljs-number">9</span> ||<span class="hljs-number">12</span> |<span class="hljs-number">13</span> |       |       ||       |<br>|               |       +---+---++---+---+       |   <span class="hljs-number">8</span>   ||  <span class="hljs-number">12</span>   |<br>|               |       |<span class="hljs-number">10</span> |<span class="hljs-number">11</span> ||<span class="hljs-number">14</span> |<span class="hljs-number">15</span> |       |       ||       |<br>+---------------+       +---+---++---+---+       +-------++-------+<br></code></pre></td></tr></table></figure><p>首先确定 $L+1$ 层每个样本在 $L$ 层对应的 $2\times 2$ block 的起始位置，</p><ul><li><p>输入 tile 在 $L$ 层级的起始位置：$M&#x3D;3$ 代入 (xOffset, yOffset) 的计算</p></li><li><p>local workgroup 内线程的分组编号：local workgroup size 为 16，只有一个分组，teamID 恒为 0，当前分组在输入 tile 中的偏移量也恒为 tx&#x3D;0,  ty&#x3D;0</p></li><li><p>当前 invocation 在其所属分组的偏移量：<code>gl_LocalInvocationIndex</code> 为当前 invocation 的索引，记为 id。$L+1$ 层的 16 个样本编号以及对应的组内偏移量，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">         L<span class="hljs-number">+1</span> 层编号二进制              L<span class="hljs-number">+1</span> 层编号对应的输入 tile 的偏移量<br>+------+------++------+------+       +------+------++------+------+<br>| <span class="hljs-number">0000</span> | <span class="hljs-number">0001</span> || <span class="hljs-number">0100</span> | <span class="hljs-number">0101</span> |       |(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) |(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) ||(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>) |(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>) |<br>+------+------++------+------+       +------+------++------+------+<br>| <span class="hljs-number">0010</span> | <span class="hljs-number">0011</span> || <span class="hljs-number">0110</span> | <span class="hljs-number">0111</span> |       |(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>) |(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>) ||(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>) |(<span class="hljs-number">2</span>,<span class="hljs-number">6</span>) |<br>+======+======++======+======+       +======+======++======+======+<br>| <span class="hljs-number">1000</span> | <span class="hljs-number">1001</span> || <span class="hljs-number">1100</span> | <span class="hljs-number">1101</span> |       |(<span class="hljs-number">4</span>,<span class="hljs-number">0</span>) |(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>) ||(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>) |(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>) |<br>+------+------++------+------+       +------+------++------+------+<br>| <span class="hljs-number">1010</span> | <span class="hljs-number">1011</span> || <span class="hljs-number">1110</span> | <span class="hljs-number">1111</span> |       |(<span class="hljs-number">6</span>,<span class="hljs-number">0</span>) |(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>) ||(<span class="hljs-number">6</span>,<span class="hljs-number">4</span>) |(<span class="hljs-number">6</span>,<span class="hljs-number">6</span>) |<br>+------+------++------+------+       +------+------++------+------+<br></code></pre></td></tr></table></figure><p>当前 invocation 组内的偏移量的计算方式如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">x = (id &amp; <span class="hljs-number">2</span>) | (id &amp; <span class="hljs-number">8</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>y = (id &amp; <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span> | (id &amp; <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure></li><li><p>最终得到 $L+1$ 层样本在 $L$ 层对应的 $2\times 2$ block 的起始偏移量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">xBlockOffset = xOffset + x;<br>yBlockOffset = yOffset + y;<br></code></pre></td></tr></table></figure></li></ul><p>与 2 levels 算法相似，得到 (xBlockOffset, yBlockOffset) 后，即可得到 $L$ 层级的 4 个样本，从而生成 $L+1$ 层级样本。每个 local workgroup 共生成 16 个 $L+1$ 层级样本，写入位置为 (xBlockOffset &gt;&gt; 1, yBlockOffset &gt;&gt; 1)。</p><p>每个 local workgroup 在同一个 subgroup 内执行，因此利用 subgroup 内部的高效数据同步，每个 subtile 的第一个线程收集其他线程生成的 $L+1$ 层级样本，然后生成一个 $L+2$ 层级样本。每个 subtile 的第一个线程为 <code>id&amp;3 == 0</code>，通过 使用 mask 参数分别为 1、2、3 的<code>subgroupShuffleXor</code> ，得到 subtile 的其他线程生成的 $L+1$ 层级样本，过程如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0</span> (<span class="hljs-number">0000</span>) ^ (<span class="hljs-number">0001</span>, <span class="hljs-number">0010</span>, <span class="hljs-number">0011</span>) = (<span class="hljs-number">0001</span>, <span class="hljs-number">0010</span>, <span class="hljs-number">0011</span>) = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-number">4</span> (<span class="hljs-number">0100</span>) ^ (<span class="hljs-number">0001</span>, <span class="hljs-number">0010</span>, <span class="hljs-number">0011</span>) = (<span class="hljs-number">0101</span>, <span class="hljs-number">0110</span>, <span class="hljs-number">0111</span>) = (<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>)<br><span class="hljs-number">8</span> (<span class="hljs-number">1000</span>) ^ (<span class="hljs-number">0001</span>, <span class="hljs-number">0010</span>, <span class="hljs-number">0011</span>) = (<span class="hljs-number">1001</span>, <span class="hljs-number">1010</span>, <span class="hljs-number">1011</span>) = (<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>)<br><span class="hljs-number">12</span>(<span class="hljs-number">1100</span>) ^ (<span class="hljs-number">0001</span>, <span class="hljs-number">0010</span>, <span class="hljs-number">0011</span>) = (<span class="hljs-number">1101</span>, <span class="hljs-number">1110</span>, <span class="hljs-number">1111</span>) = (<span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>)<br></code></pre></td></tr></table></figure><p>每个 local workgroup 生成 4 个 $L+2$ 层级样本，写入位置为 (xBlockOffset &gt;&gt; 2, yBlockOffset &gt;&gt; 2)。每个 local workgroup 中的第一个线程使用 <code>subgroupShuffleXor</code> 得到 4、8、12 号线程的 $L+2$ 层级样本，生成一个 $L+3$ 层级样本，写入位置为 (xBlockOffset &gt;&gt; 3, yBlockOffset &gt;&gt; 3)。每个 local workgroup 的第一个线程为 <code>id&amp;15 == 0</code>，过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0</span>(<span class="hljs-number">0000</span>) ^ (<span class="hljs-number">0100</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1100</span>) = (<span class="hljs-number">0100</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1100</span>)<br></code></pre></td></tr></table></figure><h2 id="4-5-Levels"><a href="#4-5-Levels" class="headerlink" title="4&#x2F;5-Levels"></a>4&#x2F;5-Levels</h2><p>理论上，上述算法可以继续递归应用得到 4&#x2F;5 levels 算法，例如对于 4 levels 算法，输入层级划分为 $16\times 16$ tiles，local workgroup 大小使用 64，划分为 4 组，每组 16 个线程，分别应用 3 levels 算法，然后 0 号线程使用 shuffle 得到 16、32、48 号线程的样本，最终生成 $L+4$ 的一个样本。但实际上，subgroup 大小有限，例如 NVIDIA 显卡的 subgroup 大小为 32，无法使用 32 及之后的 gl_SubgroupInvocationID，因此不能通过 subgroup 得到 32、48 号线程的样本。对于此，改用 shared memory。</p><h3 id="4-levels"><a href="#4-levels" class="headerlink" title="4-levels"></a>4-levels</h3><p>对于 4 levels 算法，输入层级划分为 $16\times 16$ tiles，local workgroup 大小使用 64，划分为 4 组，每组 16 个线程。local workgroup 中的线程使用 <code>gl_LocalInvocationIndex</code> 分组，0<del>15 为组 0，16</del>31 为组 1，32<del>47 为组 2，48</del>63 为组 3，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">workgroup 内的分组，<span class="hljs-string">&quot;|| =&quot;</span> 为分组边界<br>        每组中间数字为分组编号<br>        +---+---++---+---+<br>        | <span class="hljs-number">0</span> | <span class="hljs-number">4</span> ||<span class="hljs-number">16</span> |<span class="hljs-number">20</span> |<br>        +--<span class="hljs-number">-0</span>---++--<span class="hljs-number">-1</span>---+<br>        | <span class="hljs-number">8</span> |<span class="hljs-number">12</span> ||<span class="hljs-number">24</span> |<span class="hljs-number">28</span> |<br>        +===+===++===+===+<br>        |<span class="hljs-number">32</span> |<span class="hljs-number">36</span> ||<span class="hljs-number">48</span> |<span class="hljs-number">52</span> |<br>        +--<span class="hljs-number">-2</span>---++--<span class="hljs-number">-3</span>---+<br>        |<span class="hljs-number">40</span> |<span class="hljs-number">44</span> ||<span class="hljs-number">56</span> |<span class="hljs-number">60</span> |<br>        +---+---++---+---+<br></code></pre></td></tr></table></figure><p>每组分别执行 3 levels 算法。但每组的第一个线程不仅生成 $L+3$ 的一个样本，还要将该样本写入 shared memory中。然后发出一个 barrier，barrier 之后在 shared memory 中存在 4 组线程分别写入的一个 $L+3$ 层级样本，即 $L+3$ 层级的一个 $2\times 2$ tile。最后 0 号线程使用 shared memory 中的 4 个 $L+3$ 层级样本生成一个 $L+4$ 层级样本。过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">     <span class="hljs-built_in">L</span>(<span class="hljs-number">16</span>x16)               L<span class="hljs-number">+2</span>(<span class="hljs-number">8</span>x8)                       L<span class="hljs-number">+3</span>(<span class="hljs-number">2</span>x2)                   L<span class="hljs-number">+4</span><br>+-------++-------+     +---+---++---+---+             +-------++-------+        +---------------+<br>|       ||       |     | <span class="hljs-number">0</span> | <span class="hljs-number">4</span> ||<span class="hljs-number">16</span> |<span class="hljs-number">20</span> |             |       ||       |        |               |<br>|  <span class="hljs-number">8</span>x8  ||  <span class="hljs-number">8</span>x8  |     +---+---++---+---+             |   <span class="hljs-number">0</span>   ||  <span class="hljs-number">16</span>   |        |               |<br>|       ||       |(L<span class="hljs-number">+1</span>)| <span class="hljs-number">8</span> |<span class="hljs-number">12</span> ||<span class="hljs-number">24</span> |<span class="hljs-number">28</span> |             |       ||       |        |               |<br>+=======++=======+ ==&gt; +===+===++===+===+ =&gt;omitted=&gt; +=======++=======+ ==|==&gt; |      <span class="hljs-number">0</span>        |<br>|       ||       |     |<span class="hljs-number">32</span> |<span class="hljs-number">36</span> ||<span class="hljs-number">48</span> |<span class="hljs-number">52</span> |      |      |       ||       |   |    |               |<br>|  <span class="hljs-number">8</span>x8  ||  <span class="hljs-number">8</span>x8  |     +---+---++---+---+      |      |  <span class="hljs-number">32</span>   ||  <span class="hljs-number">48</span>   |   |    |               |<br>|       ||       |     |<span class="hljs-number">40</span> |<span class="hljs-number">44</span> ||<span class="hljs-number">56</span> |<span class="hljs-number">60</span> |      |      |       ||       |   |    |               |<br>+-------++-------+     +---+---++---+---+      |      +-------++-------+   |    +---------------+<br>                                               |                           |<br>                        <span class="hljs-number">16</span>-thread team handles each <span class="hljs-number">8</span>x8 sub-<span class="hljs-built_in">tile</span>        (barrier)<br></code></pre></td></tr></table></figure><p>首先确定 $L+1$ 层每个样本在 $L$ 层对应的 $2\times 2$ block 的起始位置，</p><ul><li><p>输入 tile 在 $L$ 层级的起始位置：$M&#x3D;4$ 代入 (xOffset, yOffset) 的计算</p></li><li><p>local workgroup 内线程的分组编号：local workgroup size 为 64，分为 4 个组，0<del>15 为组 0，16</del>31 为组 1，32<del>47 为组 2，48</del>63 为组 3。如下所示，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">    L<span class="hljs-number">+1</span> 层编号十六进制        L<span class="hljs-number">+1</span>层编号对应的输入 tile 的偏移量           L<span class="hljs-number">+1</span> 层分组编号<br>+----+----++----+----+     +------+------++------+------+    +-----------++-----------+<br>|<span class="hljs-number">0000</span>|<span class="hljs-number">0004</span>||<span class="hljs-number">0010</span>|<span class="hljs-number">0014</span>|     |(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) |(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>) ||(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>) |(<span class="hljs-number">0</span>,<span class="hljs-number">12</span>)|    |           ||           |<br>+----+----++----+----+     +------+------++------+------+    |     <span class="hljs-number">0</span>     ||     <span class="hljs-number">1</span>     |<br>|<span class="hljs-number">000</span>8|<span class="hljs-number">000</span>C||<span class="hljs-number">001</span>8|<span class="hljs-number">001</span>C|     |(<span class="hljs-number">4</span>,<span class="hljs-number">0</span>) |(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>) ||(<span class="hljs-number">4</span>,<span class="hljs-number">8</span>) |(<span class="hljs-number">4</span>,<span class="hljs-number">12</span>)|    |           ||           |<br>+====+====++====+====+     +======+======++======+======+    +===========++===========+<br>|<span class="hljs-number">0020</span>|<span class="hljs-number">0024</span>||<span class="hljs-number">0030</span>|<span class="hljs-number">0034</span>|     |(<span class="hljs-number">8</span>,<span class="hljs-number">0</span>) |(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>) ||(<span class="hljs-number">8</span>,<span class="hljs-number">8</span>) |(<span class="hljs-number">8</span>,<span class="hljs-number">12</span>)|    |           ||           |<br>+----+----++----+----+     +------+------++------+------+    |     <span class="hljs-number">2</span>     ||     <span class="hljs-number">3</span>     |<br>|<span class="hljs-number">002</span>8|<span class="hljs-number">002</span>C||<span class="hljs-number">003</span>8|<span class="hljs-number">003</span>C|     |(<span class="hljs-number">12</span>,<span class="hljs-number">0</span>)|(<span class="hljs-number">12</span>,<span class="hljs-number">4</span>)||(<span class="hljs-number">12</span>,<span class="hljs-number">8</span>)|(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>|    |           ||           |<br>+----+----++----+----+     +------+------++------+------+    +-----------++-----------+<br></code></pre></td></tr></table></figure><p>invocation 索引为 id，所属分组编号计算方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">teamID = (id &amp; <span class="hljs-number">0x00F0</span>) &gt;&gt; <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>当前分组在输入 tile 中的偏移量为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">tx = (teamID &amp; <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">2</span>;<br>ty = (teamID &amp; <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure></li><li><p>当前 invocation 在其所属分组的偏移量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">x = (id &amp; <span class="hljs-number">2</span>) | (id &amp; <span class="hljs-number">8</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>y = (id &amp; <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span> | (id &amp; <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure></li><li><p>最终得到 $L+1$ 层样本在 $L$ 层对应的 $2\times 2$ block 的起始偏移量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">xBlockOffset = xOffset + tx + x;<br>yBlockOffset = yOffset + ty + y;<br></code></pre></td></tr></table></figure></li></ul><p>得到 (xBlockOffset, yBlockOffset) 后即可在每个分组内分别执行 3-levels 算法。每个分组都会生成一个 $L+3$ 层级样本，即 workgroup 生成了 4 个 $L+3$ 层级样本。在生成最终的 $L+4$ 层样本时，不能再使用 <code>subgroupShuffleXor</code> 来得到其他分组生成的 $L+3$ 层级样本，因为 subgroup size 为 32，其他分组不一定位于同一个 subgroup 内，因此这时需要使用 shared memory。</p><p>每个分组的第一个线程不仅需要生成一个 $L+3$ 层级样本，还需要将该样本写入 shared memory，组内的第一个线程为 <code>(id &amp; 0x00F0)==id</code>，写入位置为 teamID。加一个 barrier 等待 shared memory 的写操作完成。最后，workgroup 的第一个线程负责生成 $L+4$ 层样本。</p><h3 id="5-levels"><a href="#5-levels" class="headerlink" title="5-levels"></a>5-levels</h3><p>对于 5 levels 算法，输入层级划分为 $32\times 32$ tiles，local workgroup 大小使用 256，划分为 16 组，每组 16 个线程。分组如下所示，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"> workgroup的每个分组编号      workgroup内每组的invocation起始编号    <br>+----+----++----+----+       +----+----++----+----+<br>|  <span class="hljs-number">0</span> |  <span class="hljs-number">1</span> ||  <span class="hljs-number">4</span> |  <span class="hljs-number">5</span> |       | <span class="hljs-number">0</span>  | <span class="hljs-number">16</span> || <span class="hljs-number">64</span> | <span class="hljs-number">80</span> |<br>+----+----++----+----+       +----+----++----+----+<br>|  <span class="hljs-number">2</span> |  <span class="hljs-number">3</span> ||  <span class="hljs-number">6</span> |  <span class="hljs-number">7</span> |       | <span class="hljs-number">32</span> | <span class="hljs-number">48</span> || <span class="hljs-number">96</span> | <span class="hljs-number">112</span>|<br>+====+====++====+====+       +====+====++====+====+<br>|  <span class="hljs-number">8</span> |  <span class="hljs-number">9</span> || <span class="hljs-number">12</span> | <span class="hljs-number">13</span> |       |<span class="hljs-number">128</span> | <span class="hljs-number">144</span>||<span class="hljs-number">192</span> | <span class="hljs-number">208</span>| <br>+----+----++----+----+       +----+----++----+----+<br>| <span class="hljs-number">10</span> | <span class="hljs-number">11</span> || <span class="hljs-number">14</span> | <span class="hljs-number">15</span> |       |<span class="hljs-number">160</span> | <span class="hljs-number">176</span>||<span class="hljs-number">224</span> | <span class="hljs-number">240</span>|<br>+----+----++----+----+       +----+----++----+----+ <br></code></pre></td></tr></table></figure><p>与 4 levels 算法相似，每组分别执行 3 levels 算法，并且每组的第一个线程不仅生成 $L+3$ 层级的一个样本，还要写入 shared memory 中。在 barrier 之后，shared memory 中存在 16 组线程分别写入的一个 $L+3$ 层级样本，即 $L+3$ 层级的一个 $4\times 4$ tile。最后使用 4 个线程执行一次 2 levels 算法，最终得到 4 个 $L+4$ 层级样本与 1 个 $L+5$ 层级样本。过程如下所示，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-built_in">L</span>(<span class="hljs-number">32</span>x32)                 L<span class="hljs-number">+3</span> (+ copy in smem)            L<span class="hljs-number">+4</span>(<span class="hljs-number">2</span>x2)                  L<span class="hljs-number">+5</span><br>+---+---++---+---+             +---+---++---+---+        +-------++-------+      +---------------+<br>|<span class="hljs-number">8</span>x8|<span class="hljs-number">8</span>x8||<span class="hljs-number">8</span>x8|<span class="hljs-number">8</span>x8|             |  <span class="hljs-number">0</span>| <span class="hljs-number">16</span>|| <span class="hljs-number">64</span>| <span class="hljs-number">80</span>|        |       ||       |      |               |<br>+---+---++---+---+             +---+---++---+---+        |   <span class="hljs-number">0</span>   ||   <span class="hljs-number">1</span>   |      |               |<br>|<span class="hljs-number">8</span>x8|<span class="hljs-number">8</span>x8||<span class="hljs-number">8</span>x8|<span class="hljs-number">8</span>x8|             | <span class="hljs-number">32</span>| <span class="hljs-number">48</span>|| <span class="hljs-number">96</span>|<span class="hljs-number">112</span>|        |       ||       |      |               |<br>+===+===++===+===+ =&gt;omitted=&gt; +===+===++===+===+ ==|==&gt; +=======++=======+ ===&gt; |       <span class="hljs-number">0</span>       |<br>|<span class="hljs-number">8</span>x8|<span class="hljs-number">8</span>x8||<span class="hljs-number">8</span>x8|<span class="hljs-number">8</span>x8|       |     |<span class="hljs-number">128</span>|<span class="hljs-number">144</span>||<span class="hljs-number">192</span>|<span class="hljs-number">208</span>|   |    |       ||       |      |               |<br>+---+---++---+---+       |     +---+---++---+---+   |    |   <span class="hljs-number">2</span>   ||   <span class="hljs-number">3</span>   |      |               |<br>|<span class="hljs-number">8</span>x8|<span class="hljs-number">8</span>x8||<span class="hljs-number">8</span>x8|<span class="hljs-number">8</span>x8|       |     |<span class="hljs-number">160</span>|<span class="hljs-number">176</span>||<span class="hljs-number">224</span>|<span class="hljs-number">240</span>|   |    |       ||       |      |               | <br>+---+---++---+---+       |     +---+---++---+---+   |    +-------++-------+      +---------------+<br>                         |                          |<br>   <span class="hljs-number">16</span>-thread team handles each <span class="hljs-number">8</span>x8 sub-<span class="hljs-built_in">tile</span>      (barrier)<br></code></pre></td></tr></table></figure><p>首先确定 $L+1$ 层每个样本在 $L$ 层对应的 $2\times 2$ block 的起始位置，</p><ul><li><p>输入 tile 在 $L$ 层级的起始位置：$M&#x3D;5$ 代入 (xOffset, yOffset) 的计算</p></li><li><p>local workgroup 内线程的分组编号：local workgroup size 为 256，分为 16 个组，分组如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">        分组编号                每组的起始编号十六进制            起始编号在输入 tile 中对应的偏移量<br>+----+----++----+----+       +----+----++----+----+        +-------+-------++-------+-------+<br>|  <span class="hljs-number">0</span> |  <span class="hljs-number">1</span> ||  <span class="hljs-number">4</span> |  <span class="hljs-number">5</span> |       |<span class="hljs-number">0000</span>|<span class="hljs-number">0010</span>||<span class="hljs-number">0040</span>|<span class="hljs-number">0050</span>|        | (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) | (<span class="hljs-number">0</span>,<span class="hljs-number">8</span>) ||(<span class="hljs-number">0</span>,<span class="hljs-number">16</span>) | (<span class="hljs-number">0</span>,<span class="hljs-number">24</span>)|<br>+----+----++----+----+       +----+----++----+----+        +-------+-------++-------+-------+<br>|  <span class="hljs-number">2</span> |  <span class="hljs-number">3</span> ||  <span class="hljs-number">6</span> |  <span class="hljs-number">7</span> |       |<span class="hljs-number">0020</span>|<span class="hljs-number">0030</span>||<span class="hljs-number">0060</span>|<span class="hljs-number">0070</span>|        | (<span class="hljs-number">8</span>,<span class="hljs-number">0</span>) | (<span class="hljs-number">8</span>,<span class="hljs-number">8</span>) ||(<span class="hljs-number">8</span>,<span class="hljs-number">16</span>) | (<span class="hljs-number">8</span>,<span class="hljs-number">24</span>)|<br>+====+====++====+====+       +====+====++====+====+        +=======+=======++=======+=======+<br>|  <span class="hljs-number">8</span> |  <span class="hljs-number">9</span> || <span class="hljs-number">12</span> | <span class="hljs-number">13</span> |       |<span class="hljs-number">00</span>80|<span class="hljs-number">00</span>90||<span class="hljs-number">00</span>C0|<span class="hljs-number">00</span>D0|        |(<span class="hljs-number">16</span>,<span class="hljs-number">0</span>) | (<span class="hljs-number">16</span>,<span class="hljs-number">8</span>)||(<span class="hljs-number">16</span>,<span class="hljs-number">16</span>)|(<span class="hljs-number">16</span>,<span class="hljs-number">24</span>)|<br>+----+----++----+----+       +----+----++----+----+        +-------+-------++-------+-------+<br>| <span class="hljs-number">10</span> | <span class="hljs-number">11</span> || <span class="hljs-number">14</span> | <span class="hljs-number">15</span> |       |<span class="hljs-number">00</span>A0|<span class="hljs-number">00</span>B0||<span class="hljs-number">00E0</span>|<span class="hljs-number">00</span>F0|        |(<span class="hljs-number">24</span>,<span class="hljs-number">0</span>) | (<span class="hljs-number">24</span>,<span class="hljs-number">8</span>)||(<span class="hljs-number">24</span>,<span class="hljs-number">16</span>)|(<span class="hljs-number">24</span>,<span class="hljs-number">24</span>)|<br>+----+----++----+----+       +----+----++----+----+        +-------+-------++-------+-------+<br></code></pre></td></tr></table></figure><p>invocation 索引为 id，所属分组编号计算方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">teamID = (id &amp; <span class="hljs-number">0x00F0</span>) &gt;&gt; <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>当前分组在输入 tile 中的偏移量为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">tx = (teamID &amp; <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">2</span> | (teamID &amp; <span class="hljs-number">8</span>) &lt;&lt; <span class="hljs-number">1</span>;<br>ty = (teamID &amp; <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">3</span> | (teamID &amp; <span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure></li><li><p>当前 invocation 在其所属分组的偏移量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">x = (id &amp; <span class="hljs-number">2</span>) | (id &amp; <span class="hljs-number">8</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>y = (id &amp; <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span> | (id &amp; <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure></li><li><p>最终得到 $L+1$ 层样本在 $L$ 层对应的 $2\times 2$ block 的起始偏移量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">xBlockOffset = xOffset + tx + x;<br>yBlockOffset = yOffset + ty + y;<br></code></pre></td></tr></table></figure></li></ul><p>得到 (xBlockOffset, yBlockOffset) 后，与 4-levels 算法类似，在每个分组内分别执行 3-levels 算法。每组生成一个 $L+3$ 层级样本，且组内第一个线程 <code>(id &amp; 0x00F0)==id</code> 负责写入 shared memory 中索引 teamID 的位置。workgroup 共生成 16 个 $L+3$ 层级样本，得到一个 4x4 大小的 shared memory。</p><p>为了能够继续使用 subgroup 特性，使用一个 subgroup 来生成最后两层。假设使用 ID 为 0<del>15 的 invocation，ID 用来索引 shared memory 中的样本。shared memory 中的数组分为四部分，0</del>3、4<del>7、8</del>11、12~15，每个部分包含 4 个 $L+3$ 层级样本。 <code>id == id &amp; 0x000C</code> 的 invocation 负责收集 4 个 $L+3$ 层级样本，生成 1 个 $L+4$ 层级样本。最后 0 号 invocation 通过 <code>subgroupShuffleXor</code> 收集其他 3 个 $L+4$ 层级样本，生成最终的 1 个 L+5 层级样本。</p><h1 id="宽高为非-2-的次幂"><a href="#宽高为非-2-的次幂" class="headerlink" title="宽高为非 2 的次幂"></a>宽高为非 2 的次幂</h1><p>对于图像宽高不是 2 的次幂的情况，$L+1$ 层级的样本在 $L$ 层级对应的 block 可能是 $1\times 1$、$1\times 2$、$2\times 1$、$2\times $2、$2\times 3$、$3\times 2$、$3\times 3$ 等。在划分为 tile 计算之后层级样本时，某些样本会用到多次，如下述 $5 \times 5$ 大小的 mip level 生成 $2\times 2$ 大小的 mip level，其中数字表示对应样本被使用到的次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">+---+---+---+---+---+        +---------+---------+<br>|   |   | <span class="hljs-number">2</span> |   |   |        |         |         |<br>+---+---+---+---+---+        |         |         |<br>|   |   | <span class="hljs-number">2</span> |   |   |        |         |         |<br>+---+---+---+---+---+        |         |         |<br>| <span class="hljs-number">2</span> | <span class="hljs-number">2</span> | <span class="hljs-number">4</span> | <span class="hljs-number">2</span> | <span class="hljs-number">2</span> | =====&gt; +---------+---------+ (each sample generated with <span class="hljs-number">3</span>x3 kernel)<br>+---+---+---+---+---+        |         |         |<br>|   |   | <span class="hljs-number">2</span> |   |   |        |         |         |<br>+---+---+---+---+---+        |         |         |<br>|   |   | <span class="hljs-number">2</span> |   |   |        |         |         |<br>+---+---+---+---+---+        +---------+---------+<br></code></pre></td></tr></table></figure><p>这意味着，无法像前述 2 的次幂的算法那样，每个 workgroup 负责的输入 tile，不会和其他 workgroup 有任何交集。这种由非 2 的次幂引入的多次引用，会导致一些 workgroup 生成下一层级样本时， 也可能使用到其他 workgroup 生成的样本。为了提高并行性，去除不同 workgroup 之间的同步，可以推算出生成 $M$ 层级所需的输入层级的大小范围。在划分 workgroup 时，不同 workgroup 之间的输入 tile 允许有重叠部分。</p>]]></content>
    
    
    <categories>
      
      <category>Vulkan Basics</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Compute Shader 基础</title>
    <link href="/2023/09/20/Vulkan%20Basics/Compute%20Shader%20%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/09/20/Vulkan%20Basics/Compute%20Shader%20%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="1-GPU-中的概念"><a href="#1-GPU-中的概念" class="headerlink" title="1. GPU 中的概念"></a>1. GPU 中的概念</h2><h3 id="1-1-处理器核心的层级概念"><a href="#1-1-处理器核心的层级概念" class="headerlink" title="1.1 处理器核心的层级概念"></a>1.1 处理器核心的层级概念</h3><p>GPU 具有非常多的处理器核心，在 Nvidia 中称为 Streaming Multiprocessor(SM)，AMD 称为 Compute Unit(CU)，以下使用 SM。在 SM 内部包含最基本的处理单元 lane，lane 可以近似理解为一个线程。SM 进行调度执行任务时，最小单位并不是 lane，而是 Warp(Nvidia 中的称呼，AMD 称为 wavefront)。一个 Warp 包含一定数量的 lane，在 Nvidia 中是 32，AMD 是 64。不同的架构，一个 SM 中包含的 warp 数量不同，目前的 Nvidia GPU 中一个 SM 包含 4 个 warp，即 128 个 lane(shader core、cuda core等)。GPU 显卡型号不同，GPU 包含的 SM 数量也不同，3080Ti 包含 80 个 SM。</p><p>在同一个 Warp 中的所有 lane 执行相同的指令，但可以处理不同的数据，这样就构成了现代 GPU 的 SIMD 机制。但一个 Warp 中的所有 lane 并不总是同时处于运行状态，即 active lane；也并不总是同时处于非运行状态，即 inactive lane。例如：</p><ul><li><p>下发的任务组包含的任务数量较少或者不是 warp 大小的整数倍，不足以填满整个 warp 的 lane，那么未分配任务的 lane 则处于 inactive 状态。下发的任务组在 vulkan 中称为  local workgroup(D3D 中的 thread group) 大小。</p></li><li><p>Dynamic Branching 会导致 lane 的执行路径不止一条，即不止一套指令，这一定程度上破坏了 SIMD 机制。例如，代码中包含 if-else 语句，不满足 if 条件的 lane 由于 lockstep 运行方式需要等待其它所有满足 if 条件的 lane 执行 if 部分，等待中的 lane 则处于 inactive 状态。反之，满足 if 条件的 lane 也会等待不满足 if 条件的 lane 执行 else 部分。<br>但 if-else 并不总是导致这种指令分歧，对于非常简单 if-else，GPU 能够使用同一套指令实现，例如如下代码</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">uint</span> d = buff_array[...]; <br><span class="hljs-type">uint</span> c;<br><span class="hljs-keyword">if</span>(d &lt; some_value)&#123;<br>   c = <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>   c = <span class="hljs-number">1</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>可能会被转换为下述伪代码描述的指令，注意 <code>cmp_and_choose</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">register_a</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br><span class="hljs-attr">register_b</span> = <span class="hljs-number">1</span><span class="hljs-comment">; </span><br><span class="hljs-attr">register_d</span> = load_from(buff_ptr_<span class="hljs-literal">off</span>set)<span class="hljs-comment">;</span><br><span class="hljs-attr">register_some_value</span> = ... <span class="hljs-comment">;</span><br><span class="hljs-attr">register_c</span> = cmp_and_choose(register_d, register_some_value, register_a, register_b)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul><p>因此，在执行之前，先将每个 local workgroup 中的线程划分为以 warp 为单位的子组，之后 GPU 以 warp 为单位进行调度执行。</p><h3 id="1-2-存储类型与数据同步"><a href="#1-2-存储类型与数据同步" class="headerlink" title="1.2 存储类型与数据同步"></a>1.2 存储类型与数据同步</h3><p>以上描述的 SM、warp、lane 具有不同类型的存储，下面根据速度由快到慢依次说明，这里的参数数据以 3080Ti (Ampere-GA102架构)为例 <a href="#%5B1%5D">[1]</a></p><ul><li><p>register：每个 SM 具有256KB 大小的寄存器区。</p></li><li><p>shared memory&#x2F;L1 cache：一个 SM 中的所有线程可以访问该 SM 具有有限大小的 shared memory。shared memory 本质上是一个较小的读写缓存区，GA102 架构中为 128KB，但其中只有一部分可被程序员使用，其他用作缓存或其他用途，例如 48KB 用作 shared memory。</p></li><li><p>global memory(VRAM)：global memory 即 GPU 显存。如果寄存器存储或者shared memory 的使用大小溢出，则会将其中的数据写入显存中，这一点和 CPU 的高速缓存-内存机制类似。</p></li></ul><p>这三种类型的存储除了存取速度差距大之外，还有工作机制上的区别：</p><ul><li>首先，一个 SM 的 shared memory 对另一个 SM 上的线程是不可见的，即 shared memory 只用于同一 SM 的线程的数据同步与共享。</li><li>其次，shared memory 与 register 虽然都属于 SM，但只有 shared memory 中的数据可以在 SM 中的 lane 之间共享。register 一般用于暂存指令执行过程的输入输出，lane&#x2F;线程执行中用到的 register 相当于是私有的，对于其他线程是不可见的。因此，一般情况下，同一 SM 中的线程共享数据需要额外花费 register 到缓存(shared memory) 的传输时间，以及占用了带宽。</li><li>最后，对于同一 SM 中正在执行的线程之间，GPU 提供了直接通过寄存器共享数据的机制。缓存与寄存器的存取速度相差很多，因此这会带来更高效的数据同步。各大图形 SDK 也对此实现了相应 API，如后续描述的 vulkan 中的 subgroup 概念。</li></ul><h2 id="2-Vulkan-中的概念"><a href="#2-Vulkan-中的概念" class="headerlink" title="2. Vulkan 中的概念"></a>2. Vulkan 中的概念</h2><p>以上讲述了，一些硬件层面的概念，包括 SM(处理器核心)、Warp(处理器核心中同时执行的线程组)、Lane(相当于线程)。在图形 SDK 中，有相应的软件层面的概念。</p><ul><li><p>invocation：一个下发的并行任务，对应一个线程。</p></li><li><p>local workgroup：在同一 SM 上执行的 invocation 组，面向一个 SM。声明在 compute shader 中，如</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">local_size_x</span> = X, <span class="hljs-keyword">local_size_y</span> = Y, <span class="hljs-keyword">local_size_z</span> = Z) <span class="hljs-keyword">in</span>;<br></code></pre></td></tr></table></figure><p>上述声明表示，当前 compute shader 描述的 invocation 的 local workgroup 大小为 $X\times Y \times  Z$ </p></li><li><p>subgroup：local workgroup 中同时并行执行的 invocation 组，对应一个 Warp。如上述 Warp，subgroup 中的 invocation 同样有 active 和 inactive 两种状态，且具有相同的机制。</p></li><li><p>global workgroup：一次下发并行任务的 API 调用生成的所有 invocation，面向整个 GPU。通过 <code>vkCmdDispatch</code> 指定 local workgroup 的维度与对应维度大小，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vkCmdDispatch</span><span class="hljs-params">(VkCommandBuffer cmdBuf, <span class="hljs-type">uint32_t</span> groupCountX, <span class="hljs-type">uint32_t</span> groupCountY, <span class="hljs-type">uint32_t</span> groupCountZ)</span></span>;<br></code></pre></td></tr></table></figure><p>上述调用表面 global workgroup 中具有 (groupCountX x groupCountY x groupCountZ) 个 local workgroup，因此共有 (groupCountX x groupCountY x groupCountZ) x $X\times Y \times Z$ 个 invocation&#x2F;线程。</p></li></ul><p>Compute shader 的执行过程可以简要描述为：<code>vkCmdDispatch</code> 命令生成了一批 local workgroup，GPU 会将这批 local workgroup 划分到某些 SM 上执行，GPU 上的所有 SM 以并行形式执行。在 local workgroup 执行期间，一般不会离开其执行于的 SM。local workgroup 包含多个 invocation，GPU 的最小调度单位是 Warp，因此一个 local workgroup 会先被划分为一个或多个 subgroup(s)，每个 subgroup 的 invocation 可以并行执行。</p><p>global workgroup 中 local workgroup 的数量可以超过 GPU 中 SM 的数量，因此会有多个 local workgroup 被分配到同一个 SM 上执行。同一 SM 上的 subgroup 会在执行过程中发生切换，例如，在一个 subgroup 等待比较耗时内存访问操作完成时，为了隐藏延迟，会切换执行另一个 subgroup，这种切换也可能会发生在同一 SM 上的不同 local workgroup 的 subgroup 之间。假设 invocation 使用寄存器资源或 shared memory 过多，不足以满足切换的 subgroup，那么会有寄存器数据备份至缓存或 shared memory 备份至显存的操作，这样会带来性能上的影响。同样，local workgroup 的 subgroup 数量也可以超过一个 SM 中的 Warp 数量。</p><h2 id="3-Compute-Shader-中的内置变量"><a href="#3-Compute-Shader-中的内置变量" class="headerlink" title="3. Compute Shader 中的内置变量"></a>3. Compute Shader 中的内置变量</h2><p>Compute Shader 没有 in&#x2F;out 参数，只能使用 SSBO&#x2F;Texture 资源进行读写。对于 Texture，compute shader 只能使用 image 类型，不支持采样且一个 image 类型参数只能使用一个 level。在访问 image 时，只能使用整数索引。</p><p>Compute Shader 经常用于处理高维数据，如贴图。有一些内置变量可以作为高维数据的索引，</p><ul><li><p><code>uvec3 gl_NumWorkGroups</code>：传递给 dispatch 函数的 group 数量，即 (groupCountX, groupCountY, groupCountZ) </p></li><li><p><code>uvec3 gl_WorkGroupID</code>：当前 invocation 所属的 local workgroup 的编号，范围 [0, gl_NumWorkGroups.XYZ)</p></li><li><p><code>uvec3 gl_LocalInvocationID</code>：当前 invocation 在其 local workgroup 内的编号，范围是<br>[0, gl_WorkGroupSize.XYZ)，其中 gl_WorkGroupSize&#x3D;(local_size_x, local_size_y, local_size_z)</p></li><li><p><code>uvec3 gl_GlobalInvocationID</code>：当前 invocation 在 global workgroup 中的编号，等于</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-built_in">gl_WorkGroupID</span> * <span class="hljs-built_in">gl_WorkGroupSize</span> + <span class="hljs-built_in">gl_LocalInvocationID</span><br></code></pre></td></tr></table></figure></li><li><p><code>uint gl_LocalInvocationIndex</code>：相当于 gl_LocalInvocationID 的一维形式，等于</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-built_in">gl_LocalInvocationIndex</span> =<br>          <span class="hljs-built_in">gl_LocalInvocationID</span>.z * <span class="hljs-built_in">gl_WorkGroupSize</span>.x * <span class="hljs-built_in">gl_WorkGroupSize</span>.y +<br>          <span class="hljs-built_in">gl_LocalInvocationID</span>.y * <span class="hljs-built_in">gl_WorkGroupSize</span>.x + <br>          <span class="hljs-built_in">gl_LocalInvocationID</span>.x;<br></code></pre></td></tr></table></figure></li></ul><p>与 subgroup 相关的内置变量：</p><ul><li><code>gl_NumSubgroups</code>：local workgroup 包含的 subgroup 的数量</li><li><code>gl_SubgroupID</code>：当前 subgroup 在 local workgroup 中的编号，范围是 [0, gl_NumSubgroups)</li><li><code>gl_SubgroupSize</code>：subgroup 的大小</li><li><code>gl_SubgroupInvocationID</code>：当前 invocation 在 subgroup 中 ID，范围是 [0, gl_SubgroupSize)</li><li><code>gl_SubgroupEqMask</code>, <code>gl_SubgroupGeMask</code>, <code>gl_SubgroupGtMask</code>, <code>gl_SubgroupLeMask</code>,<br><code>gl_SubgroupLtMask</code>：subgroupBallot 相关</li></ul><p>有关 gl_LocalInvocationID  与 gl_SubgroupInvocationID 的关系，没有找到有文档说明，但我相信应该与<br>gl_GlobalInvocationID、gl_LocalInvocationID之间的关系类似。因为 GPU 的最小调度单位是 subgroup&#x2F;Warp 而不是 invocation&#x2F;线程。在调度之前 local workgroup 就应该已经被划分为 subgroup。此时，subgroup 中的所有 invocation 都对于 GPU 而言是相同的指令序列。subgroup 内的分歧应该发生在实际执行过程中。因此，gl_LocalInvocationID 和 gl_SubgroupInvocationID 之间具有事先确定的关系应该不会对后续调度产生任何影响。但是如果没有确定的关系，那么subgroup 功能的使用将会受到很大的限制。经过在 RTX 3080ti 上测试，gl_LocalInvocationID  与<br> gl_SubgroupInvocationID 有如下数值关系，</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl">gl_SubgroupID * gl_SubgroupSize + gl_SubgroupInvocationID == <span class="hljs-built_in">gl_LocalInvocationIndex</span> <br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-built_in">gl_LocalInvocationIndex</span> % gl_SubgroupSize == gl_SubgroupInvocationID <br></code></pre></td></tr></table></figure><h3 id="内存模型术语"><a href="#内存模型术语" class="headerlink" title="内存模型术语"></a>内存模型术语</h3><h4 id="1-Coherent-or-Incoherent-Memory-Access-2"><a href="#1-Coherent-or-Incoherent-Memory-Access-2" class="headerlink" title="1. Coherent or Incoherent Memory Access [2]"></a>1. Coherent or Incoherent Memory Access <a href="#%5B2%5D">[2]</a></h4><ul><li>Coherent 内存访问</li></ul><p>以最简单的例子——单处理器系统来说，对于同一内存区域同时只会有一个线程访问。因此，当一个处理元件对某一内存区域写，然后另一处理元件对同一内存区域读时，总能读到更新后的值。这是我们想要的结果，但得到这一正确结果并不只是多线程读写同步。因为，在硬件层有高速缓存-内存机制，处理器的读写往往不直接针对内存，而是针对缓存。缓存中的数据是内存中数据的拷贝或者是写操作得到的更新数据，因此需要确保写操作之后的读操作能够读到新数据，而非旧数据，这就是 <strong>Coherent 内存访问</strong>。单处理器系统的内存操作工作于同一套高速缓存-内存机制中，保证 Coherent 内存访问较容易。</p><ul><li>Incoherent 内存访问</li></ul><p>但对于多处理器系统，每个处理器都有其本地缓存，当多个处理器同时访问同一内存区域时，同一内存区域的数据在这些处理器的缓存中都有一个备份。此时可能存在处理器读到的时本地缓存中的旧数据，而不是其他处理器写操作生成的新数据，即出现 <strong>Incoherent 内存访问</strong>。为了避免这种情况，多处理器系统的设计需要采用存储器一致性协议，粗略地说，当一个处理器对某一内存区域更新时，对该内存区域存在缓存备份的其他处理器也要对其本地缓存的相应位置进行更新。</p><h4 id="2-Visibility-3"><a href="#2-Visibility-3" class="headerlink" title="2. Visibility [3]"></a>2. Visibility <a href="#%5B3%5D">[3]</a></h4><p>GPU 的核心数量远高于 CPU，在 GPU 的执行过程中，不同处理器同时读写同一内存区域时，也会出现上述 Incoherent 内存访问情况。而 <strong>Visibility</strong> 术语就是指一个 shader invocation 可以安全地读其他 shader invocation 的 Incoherent 写数据，也就是说，不会读取到缓存中旧的备份，或者其他 invocation 写数据对其是可见的。</p><p>对于多个 shader invocation 同时读写不同的区域，不会出现上述 incoherent 访问情况。此外，对于在同一处理器执行的 shader invocation，不会出现 incoherent 情况，因为使用的是同一套缓存-内存机制，例如 compute shader 中的同一 local workgroup 中的 invocation。特别注意，这里不会出现 incoherent 访问问题，并不是指读写同步问题，读写同步同样需要额外处理。当不同处理器上的 shader invocation 对同一内存区域进行读写时，则会出现 incoherent 内存访问。</p><p><a href="#%5B5%5D">[5]</a> 提到 incoherent 的内存访问操作有：</p><ul><li>对 image 变量的 imageLoad&#x2F;imageStore</li><li>对 buffer 变量的读写操作</li><li><a href="https://www.khronos.org/opengl/wiki/Atomic_Counter">Atomic Counters</a></li><li>对 compute shader 中的 shared 变量的读写操作。这个无法理解，shared 变量存储在缓存中，不应该会有多个备份的情况，为什么还是 incoherent？</li></ul><p>这时需要考虑如何避免 incoherent 内存访问，即确保 visibility 性质。这里有两种情况：</p><h5 id="2-1-Internal-Visibility：一个绘制指令执行内部，一部分写、而另一部分读。"><a href="#2-1-Internal-Visibility：一个绘制指令执行内部，一部分写、而另一部分读。" class="headerlink" title="2.1 Internal Visibility：一个绘制指令执行内部，一部分写、而另一部分读。"></a>2.1 Internal Visibility：一个绘制指令执行内部，一部分写、而另一部分读。</h5><ul><li>读写次序控制、内存控制</li></ul><p>想要使得一个 shader invocation 能够读取另一 shader invocation 写数据，要先保证写操作在读操作之前确实发生，也就是读写同步问题。例如 compute shader 中 <code>barrier</code> 函数，可以确保 local workgroup(执行在同一处理器) 中的所有 invocation 都执行到 barrier 同步点后，才开始执行之后的代码。</p><p>注意 barrier 函数只是对 local workgroup 中的 invocation 的执行过程进行了控制，这种控制只发生在同一个处理器上。对于 shared memory 缓存只会在同一个处理器上共享，因此 barrier 同时也能够做到 shared memory 的读写次序控制。在 compute shader 中 shared 变量即位于 shared memory 中，由于本身就是缓存，不会出现多个备份情况，因此 shared 变量是隐含的 coherent 访问。这一点在 <a href="#%5B6%5D">[6]</a> 的 1.1.2 小节也有说明</p><blockquote><ul><li>Private GLSL issue #24: Clarify that <strong>barrier</strong>() by itself is enough to synchronize both control flow and memory accesses to <strong>shared</strong> variables and tessellation control output variables. For other memory accesses an additional memory barrier is still required.</li></ul></blockquote><ul><li>内存访问控制 <a href="#%5B4%5D">[4]</a></li></ul><p>确保读写次序，相当于确保了在读操作之前，写操作一定已经发生。对于 coherent 内存访问而言，这已经确保了写数据的可见性；但对于 incoherent 内存访问，写操作发生不代表写数据对其他 invocation 可见，这会导致一个 invocation 的内存读写操作的相对次序对于另一个 invocation 而言是不确定的状态，换句话说，写操作的数据对其他 invocation 可见的次序不确定。例如一个 invocation 中执行两次写操作，而另一个 invocation 可能会先看到第二次写的数据，后看到第一次写的数据。</p><p>这时需要使用到 memory barrier 来控制读写操作，使得其他 invocation 看到写数据的次序与写操作执行的次序一致。先对可能被多个处理器访问到的 image 或 buffer 类型变量进行 <code>coherent</code> 修饰，声明该变量为 coherent 访问机制。该访问机制使得相应的 memoryBarrier 可以控制对被修饰变量的读写操作。调用 memoryBarrier 等函数的 invocation 会等待之前的所有读写操作完成，当该函数返回后，写数据对之后的访问处于可见状态。例如一个 invocation 执行两次写操作，每次写操作后都加上一个 memory barrier，那么其他 invocation 就不可能先看到第二次写的数据，而后看到第一次写的数据。memory barrier 有多种类型：</p><ul><li><code>memoryBarrier</code>：控制所有类型变量的内存访问，render command 内作用于全局。</li><li><code>memoryBarrierAtomicCounter</code>：控制 atomic-counter 变量的访问，render command 内作用于全局。</li><li><code>memoryBarrierBuffer</code>：控制 buffer 变量的内存访问，render command 内作用于全局。</li><li><code>memoryBarrierImage</code>：控制 image 变量的内存访问，render command 内作用于全局。</li><li><code>memoryBarrierShared</code>：控制 shared 变量的内存访问，作用于同一 workgroup。</li><li><code>groupMemoryBarrier</code>：控制所有类型变量的内存访问，作用于同一 workgroup。</li></ul><h5 id="2-2-External-Visibility"><a href="#2-2-External-Visibility" class="headerlink" title="2.2 External Visibility"></a>2.2 External Visibility</h5><p>一个 render command 内部的 visibility 是 shader invocation 之间的读写操作。对于 render command 之间的 visibility 使用 barrier 命令进行同步。例如 vulkan 中的 buffer barrier、image layout 等</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a name="[1]">[1]</a> <a href="https://images.nvidia.com/aem-dam/en-zz/Solutions/geforce/ampere/pdf/NVIDIA-ampere-GA102-GPU-Architecture-Whitepaper-V1.pdf">https://images.nvidia.com/aem-dam/en-zz/Solutions/geforce/ampere/pdf/NVIDIA-ampere-GA102-GPU-Architecture-Whitepaper-V1.pdf</a></p><p><a name="[2]">[2]</a> <a href="https://en.wikipedia.org/wiki/Memory_coherence">https://en.wikipedia.org/wiki/Memory_coherence</a></p><p><a name="[3]">[3]</a> <a href="https://www.khronos.org/opengl/wiki/Memory_Model#Ensuring_visibility">https://www.khronos.org/opengl/wiki/Memory_Model#Ensuring_visibility</a></p><p><a name="[4]">[4]</a><a href="https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.60.html#shader-memory-control-functions">https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.60.html#shader-memory-control-functions</a></p><p><a name="[5]">[5]</a> <a href="https://www.khronos.org/opengl/wiki/Memory_Model#Incoherent_memory_access">https://www.khronos.org/opengl/wiki/Memory_Model#Incoherent_memory_access</a></p><p><a name="[6]">[6]</a> <a href="https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.60.html#changes">https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.60.html#changes</a></p>]]></content>
    
    
    <categories>
      
      <category>Vulkan Basics</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Reblur解析</title>
    <link href="/2023/09/20/Rendering%20Blogs/Graphics%20Algorithm/2.%20Reblur%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/09/20/Rendering%20Blogs/Graphics%20Algorithm/2.%20Reblur%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概要"><a href="#1-概要" class="headerlink" title="1 概要"></a>1 概要</h1><h1 id="2-调用逻辑"><a href="#2-调用逻辑" class="headerlink" title="2 调用逻辑"></a>2 调用逻辑</h1><p>文件 Reblur_DiffuseSpecular.hpp，在 nrd::InstanceImpl::Add_ReblurDiffuseSpecular 里创建好所有 render pass</p><p>每个 pass 的名字使用宏 <code>PushPass(&quot;PostFix&quot;)</code> 设置，最后得到 pass name &#x3D; <code>DENOISER_NAME - PostFix</code> </p><p><code>AddDispatch</code> 的第一个参数指定shader文件名，而这个shader文件只是充当一个组织文件，预定义一些宏，控制降噪走的分支， 实际的代码在其 include 的 shader 文件中。对于 REBLUR_DiffuseSpecular 会走 <code>REBLUR_DIFFUSE</code> 与 <code>REBLUR_SPECULAR</code> 两个分支</p><p>reblur 配置 <code>nrd::ReblurSettings m_ReblurSettings</code> ，更新在 <code>InstanceImpl::Update_Reblur</code></p><p>shader参数：</p><ul><li><code>REBLUR_SHARED_CB_DATA</code>在 <code>InstanceImpl::AddSharedConstants_Reblur</code>中更新</li><li>pass参数的更新在 <code>InstanceImpl::Update_Reblur</code></li></ul><h1 id="3-渲染逻辑"><a href="#3-渲染逻辑" class="headerlink" title="3 渲染逻辑"></a>3 渲染逻辑</h1><p>![image-20230820103719276-1694926428932-2](&#x2F;images&#x2F;Rendering Blogs&#x2F;Graphics Algorithm&#x2F;2. Reblur解析.assets&#x2F;image-20230820103719276-1694926428932-2.png)</p><h2 id="3-1-Classify-tiles"><a href="#3-1-Classify-tiles" class="headerlink" title="3.1 Classify tiles"></a>3.1 Classify tiles</h2><p>识别需要降噪的tile</p><h2 id="3-2-Pre-pass"><a href="#3-2-Pre-pass" class="headerlink" title="3.2 Pre-pass"></a>3.2 Pre-pass</h2><p>准备 pre-blur 参数</p><h3 id="3-2-1-depth-based-bilateral-weight"><a href="#3-2-1-depth-based-bilateral-weight" class="headerlink" title="3.2.1 depth-based bilateral weight"></a>3.2.1 depth-based bilateral weight</h3><p><code>float2 wc</code> ：depth-based bilateral weight，使用左右两个像素<code>viewZ0</code>、<code>viewZ1</code>与当前像素的<code>viewZ</code>的相对差异。对相对差异施加一个cut off，限制在[0, cut_off]范围内。当相对差异超过阈值 0.03 时，权重为 0；当相对差异&lt;&#x3D;0时，权重取 1；其余在 0~1 之间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">float2 viewZ01 = float2(viewZ0, viewZ1);<br>float2 x = <span class="hljs-built_in">abs</span>(viewZ01 - viewZ) * rcp(max(<span class="hljs-built_in">abs</span>(viewZ01), <span class="hljs-built_in">abs</span>(viewZ)));<span class="hljs-comment">// 当前像素与左右相邻像素的 viewZ 的相对差异</span><br><span class="hljs-type">float</span> cut_off = <span class="hljs-number">0.03</span>;<br><span class="hljs-comment">// 相当于把 x 限制在 [0, cut_off] 内，&gt;= cut_off 为 0，&lt;= 0 为 1</span><br>wc = saturate((x - cut_off) / (-cut_off)) = saturate(<span class="hljs-number">1</span> - x / cut_off);  <br>wc *= <span class="hljs-number">1.0</span> / max((wc.x + wc.y), <span class="hljs-number">1e-15</span>);<br></code></pre></td></tr></table></figure><h3 id="3-2-2-Checkboard模式处理"><a href="#3-2-2-Checkboard模式处理" class="headerlink" title="3.2.2 Checkboard模式处理"></a>3.2.2 Checkboard模式处理</h3><p>当为 <code>RESOLUTION_HALF</code> 时，checkerboard mode 为 <code>CheckerboardMode::WHITE(2)</code>、diffCheckerboard(1)、specCheckerboard(0)；否则为 OFF(0)，diffCheckerboard(2)、specCheckerboard(2)。当为半屏模式时，经过pre pass可以得到全屏结果。</p><ol><li><code>uint checkerboard</code> ：0&#x2F;1 值，使用像素坐标与帧数得到，相邻像素交错，相邻帧交错</li></ol>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">uint <span class="hljs-title function_">CheckerBoard</span><span class="hljs-params">(uint2 samplePos, uint frameIndex)</span><br>&#123;<br>    uint a = samplePos.x ^ samplePos.y;<br>    <span class="hljs-keyword">return</span> (a ^ frameIndex) &amp; <span class="hljs-number">0x1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p><code>int3 checkerboardPos</code> ：1&#x2F;2 屏幕坐标(横坐标缩减一半)。x、z 取当前像素的左右相邻像素横坐标，y取当前像素坐标，最后横坐标右移一位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">int3 checkerboardPos = pixelPos.xyx + int3(<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>checkerboardPos.xz &gt;&gt;= <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li><li><p>checkboard 模式处理，如文件 <em>NRDSettings.h</em> 描述，当为半屏的 checkboard 模式时，noisy input在左半部分。<code>hasData</code>表示当前像素是否有有效数据，使用交错处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(gDiffCheckerboard<span class="hljs-comment">/*\gSpecCheckerboard*/</span> != <span class="hljs-number">2</span>)&#123;<span class="hljs-comment">// 半屏的交错模式</span><br>    hasData = checkerboard == gDiffCheckerboard<span class="hljs-comment">/*\gSpecCheckerboard*/</span>;  <span class="hljs-comment">// checkerboard 交错得到有效/无效数据</span><br>    pos.x &gt;&gt;= <span class="hljs-number">1</span>;  <span class="hljs-comment">// 1/2 屏幕</span><br>&#125;<br>REBLUR_TYPE diff = gIn_Diff[pos]; <span class="hljs-comment">/*REBLUR_TYPE spec = gIn_Spec[pos];*/</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-2-3-准备当前像素的数据"><a href="#3-2-3-准备当前像素的数据" class="headerlink" title="3.2.3 准备当前像素的数据"></a>3.2.3 准备当前像素的数据</h3><p><code>N</code>(世界空间法线)、<code>Nv</code>(view space下的法线)、roughness、<code>Vv</code> (View space 下的view vector)、<code>Xv</code> (像素在view space下的position)</p><p><code>float4 rotator</code> ：每帧生成的向量，用于 Poisson 采样。<code>REBLUR_PRE_BLUR_ROTATOR_MODE</code> 取 <code>NRD_FRAME</code> ，这里 rotator 取的是 CPU 传来的。</p><h3 id="3-2-4-执行-Pre-blur"><a href="#3-2-4-执行-Pre-blur" class="headerlink" title="3.2.4 执行 Pre-blur"></a>3.2.4 执行 Pre-blur</h3><p>diffuse 与 specular 有各自的 spatial filter，参考下一章节。</p><h2 id="3-3-Temporal-accumulation"><a href="#3-3-Temporal-accumulation" class="headerlink" title="3.3 Temporal accumulation"></a>3.3 Temporal accumulation</h2><h3 id="3-3-1-Preload与数据准备"><a href="#3-3-1-Preload与数据准备" class="headerlink" title="3.3.1 Preload与数据准备"></a>3.3.1 Preload与数据准备</h3><ol><li><p>预加载 tile <code>(GROUP_X+BORDER*2) x (GROUP_Y+BORDER*2)</code> 的数据，减少后续重复访问 texture</p><ul><li>normal roughness 数据加载到 <code>s_Normal_Roughness[GROUP_X+BORDER*2][GROUP_Y+BORDER*2]</code> 中</li></ul></li><li><p>在当前像素的 (BORDER * 2) x (BORDER * 2) 区域计算<code>Navg</code> (averaged normal) 与<code>hitDistForTracking</code> (取最小)。</p><blockquote><p>注意：<code>threadPos+BORDER</code> 对应了当前像素在 s_Normal_MinHitDist 中的位置，因此循环中跳过了 (i&#x3D;&#x3D; BORDER &amp;&amp; j &#x3D;&#x3D; BORDER)  </p><p>但是，Navg 的计算只包含了以当前像素为右下角的四个像素，而 hitDistForTracking 则遍历了以当前像素为中心的 3x3 区域。不懂这个设计</p></blockquote></li><li><p>准备当前像素的数据<br><code>float3 N</code>(世界空间法线)，<code>float materialID</code>，<code>Xv</code>(view space坐标)， <code>X</code>(相机无平移变换时的世界空间坐标)，<code>roughness</code></p></li></ol><h3 id="3-3-2-变换"><a href="#3-3-2-变换" class="headerlink" title="3.3.2 变换"></a>3.3.2 变换</h3><p>Temporal 处理时需要进行world、view、clip以及到上一帧的变换，比较特殊的一点，本阶段使用的变换将camera的平移都取消掉了。</p><p>常规的变换对应了 <code>CommonSettings</code> 中的 <code>viewToClipMatrix</code>(\Prev)、<code>worldToViewMatrix</code>(\Prev)等一系列矩阵，而传给shader的变换实际是 <code>InstanceImpl</code> 里的 <code>m_ViewToClip</code>(\Prev\Inv)、<code>m_WorldToView</code>(\Prev)、<code>m_ViewToWorld</code>(\Prev)、<code>m_WorldToClip</code>(\Prev\Inv)。将view space的平移整体取消，即 world 与 view 之间的变换的平移。而 world 到上一帧view 以及 view 到上一帧world 之间的变换采用相机的运动矢量，即相对偏移。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">m_ViewToWorld.<span class="hljs-built_in">SetTranslation</span>(ml::float3::<span class="hljs-built_in">Zero</span>());<br>ml::float3 translationDelta = cameraPositionPrev - cameraPosition;<span class="hljs-comment">// 指向上一帧的相机偏移</span><br>m_ViewToWorldPrev.<span class="hljs-built_in">SetTranslation</span>(translationDelta);<br></code></pre></td></tr></table></figure><p>上面一系列做法相当于永远将当前帧相机至于世界原点位置，因此 view 到 world 的变换只需要执行旋转变换。为了便于理解，后续描述也直接忽略相机平移。例如 <code>Xv</code> 是像素在view space下的坐标，而下面应用从view 到 world旋转得到的 <code>X</code> 称为像素的世界空间坐标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">float3 X = STL::Geometry::<span class="hljs-built_in">RotateVector</span>(gViewToWorld, Xv);<br></code></pre></td></tr></table></figure><p><strong>因此，通过变换到三位空间得到的点，既是三维空间坐标，又是点到相机的向量。</strong></p><h3 id="3-3-3-计算视差"><a href="#3-3-3-计算视差" class="headerlink" title="3.3.3 计算视差"></a>3.3.3 计算视差</h3><p>视差（parallax）是指比较两个观察方向（世界空间）的差距大小。观察方向是相机到着色点的方向，因此视差是针对某一着色点而言的。只有当相机发生了位置变化，才会产生视差。在相同的相机运动下，不同着色点具有不同的视差。因此计算视差要固定着色点，如下图所示，相机运动向量 $\vec{c}$，运动前后的观察方向 $\vec{v},\vec{v}<em>{prev}$，可以得到视差度量定义<br>$$<br>parallax &#x3D; \tan\big(\arccos(\vec{v} \cdot \vec{v}</em>{prev})\big)<br>$$<br><img src="/images/Rendering Blogs/Graphics Algorithm/2. Reblur解析.assets/image-20230821185416474.png" alt="image-20230821185416474" style="zoom: 50%;"></p><ul><li><p><code>Xprev</code>上一帧位置：处理animation带来的运动，计算着色点在上一帧的世界空间坐标<br>  <code>gIn_Mv</code>应该是物体animation带来的motion vector（mv可能是世界空间下、也可能是uv空间下），测试例子里都是 0；<br>  <code>gMvScale</code> 取值 C++ 的 motionVectorScale，gIsWorldSpaceMotionEnabled &#x3D; 0。</p></li><li><p>世界空间下 (gIsWorldSpaceMotionEnabled ! &#x3D; 0)：Xpre +&#x3D; mv 得到上一帧的位置</p><p>motionVectorScale &#x3D; (1.0, 1.0, 0.0)</p></li><li><p>uv空间下：mv.xy 为 uv 的运动，uv.z 为深度的运动，(此时为 25D) motionVectorScale &#x3D; (1.0&#x2F;width, 1.0&#x2F;height, 1.0) </p><p>因此在上一帧的像素uv： <code>smbPixelUv = pixelUv + mv.xy</code> 与深度 (viewZ + mv.z) </p><p>变换得到上一帧的世界坐标：<code>Xprev = RotateVectorInverse(...) + gCameraDelta</code>。RotateVectorInverse 只处理了<strong>相机旋转</strong>（应该是旋转矩阵的逆等于转置，避免求逆）。gCameraDelta 是指向上一帧的运动向量，而这里的变换都是以当前帧相机为世界原点，因此加上 gCameraDelta  最终得到上一帧的世界空间坐标。</p><blockquote><p>注意：Xprev 是着色点在上一帧的世界坐标，因此如果着色点没有动画，那么 Xprev 与着色点在当前帧的世界坐标应该一样</p></blockquote></li><li><p><code>smbParallaxInPixels</code>与上一帧之间的视差（像素为单位的距离）</p><p>ComputeParallaxInPixels(Xprev - gCameraDelta, pixelUv, gWorldToClip, gRectSize )</p><ul><li><p><code>gCameraDelta</code> 即相机在世界空间指向上一帧的运动向量 prev - current。</p><p>Xprev - gCameraDelta &#x3D; Xprev + (-gCameraDelta)：相当于保持相机位置不同，向着色点施加上一帧指向当前帧的相机平移运动</p><p>再执行 <code>gWorldToClip</code> 变换得到当前相机下的 <code>uv</code>。</p></li><li><p>像素在上一帧的世界坐标 Xprev 施加了相机运动并变换到当前帧的uv，此时与 pixelUv 处于同一相机下，如上图右侧。因此可以计算二者之间的像素距离</p></li></ul></li></ul><h3 id="3-3-4-历史数据重投影"><a href="#3-3-4-历史数据重投影" class="headerlink" title="3.3.4 历史数据重投影"></a>3.3.4 历史数据重投影</h3><p>时序累积是将当前帧与历史帧结合得到更稳定的结果。需要将当前帧重投影到上一帧，从历史数据中得到可靠的对应，并以一定权重将当前帧更新到历史帧中。为此，需要考虑：</p><ul><li>disocclusion tracking：当前帧像素是否发生去遮挡，即新出现的像素。</li><li>accumulate speed：当前帧像素与历史帧像素结合的权重。</li></ul><p>reblur的重投影结合了 surface motion based 与 virtual motion based(仅用于specular) 两种方法，下面先介绍surface motion</p><h4 id="3-3-4-1-Surface-motion-based-reprojection"><a href="#3-3-4-1-Surface-motion-based-reprojection" class="headerlink" title="3.3.4.1 Surface motion based reprojection"></a>3.3.4.1 Surface motion based reprojection</h4><p>（1）Disocclusion Tracking</p><p>前面已经通过重投影或者motion vector找到当前帧像素<code>pixelUv</code>对应上一帧像素<code>smbPixelUv </code>，通过比较当前帧与上一帧之间view z的差异是否超过阈值，如果超过则表示像素不匹配。此外，这个过程是基于Catmull-Rom filter与bilinear filter进行的，对于匹配的历史信息使用filter结果与当前帧进行混合。</p><ol><li><p>smbDisocclusionThreshold 计算</p><ul><li><p>输入 <code>gDisocclusionThreshold</code>，其在 C++ 上的数值计算如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> disocclusionThresholdBonus = (<span class="hljs-number">1.0f</span> + m_JitterDelta) / <span class="hljs-built_in">float</span>(rectH);<br><span class="hljs-type">float</span> disocclusionThreshold = m_CommonSettings.disocclusionThreshold + disocclusionThresholdBonus;<span class="hljs-comment">// 0.01 + 抖动值</span><br></code></pre></td></tr></table></figure><p>m_JitterDelta 是相邻两帧camera jitter的差值，camera jitter则是每帧的halton抖动值 [-0.5,0.5]</p></li><li><p>先乘上 frustumSize 得到 disocclusionThresholdMulFrustumSize，基于<code>NoV</code>与视差调整阈值，视差越大，阈值越低</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> smbDisocclusionThreshold = disocclusionThresholdMulFrustumSize / <span class="hljs-built_in">lerp</span>(<span class="hljs-number">0.05</span> + <span class="hljs-number">0.95</span> * NoV, <span class="hljs-number">1.0</span>, <span class="hljs-built_in">saturate</span>(smbParallaxInPixels/<span class="hljs-number">30.0</span>));<br></code></pre></td></tr></table></figure></li><li><p>是否正面朝向。通过上一帧与当前帧的法线夹角判断。因为当前帧肯定是正面朝向，如果法线夹角不超过一定值则视上一帧也是正面朝向。</p><ul><li><p>夹角cos阈值 <code>frontFacing</code>：<code>lerp(cos(DegToRad(135.0)), cos(DegToRad(91.0)), saturate(2*smbParallaxInPixels-1))</code></p></li><li><p>法线夹角采用当前帧&#x2F;上一帧像素的bilinear区域法线均值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">smbDisocclusionThreshold *= <span class="hljs-built_in">float</span>(<span class="hljs-built_in">dot</span>(prevNavg, Navg) &gt; frontFacing);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>上一帧uv的bilinear区域是否在屏幕内。若不在，则 smbDisocclusionThreshold 最终为负，那么之后的occlusion判断都不通过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">smbDisocclusionThreshold *= <span class="hljs-built_in">IsInScreenBilinear</span>(smbBilinearFilter.origin, gRectSizePrev);<br>smbDisocclusionThreshold -= NRD_EPS;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在Catmull-Rom filter区域与bilinear filter区域进行occlusion判断，并生成occlusion weight。当catmull-rom区域不匹配时，则降为使用occlusion weight的bilinear区域。Catmull-Rom区域为4x4，中间2x2对应了bilinear区域，定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">      Gather      =&gt; CatRom12    =&gt; Bilinear</span><br><span class="hljs-comment">    0x 0y 1x 1y       0y 1x</span><br><span class="hljs-comment">    0z 0w 1z 1w    0z 0w 1z 1w       0w 1z</span><br><span class="hljs-comment">    2x 2y 3x 3y    2x 2y 3x 3y       2y 3x</span><br><span class="hljs-comment">    2z 2w 3z 3w       2w 3z</span><br><span class="hljs-comment">     CatRom12     =&gt; Bilinear</span><br><span class="hljs-comment">       0x 1x</span><br><span class="hljs-comment">    0y 0z 1y 1z       0z 1y</span><br><span class="hljs-comment">    2x 2y 3x 3y       2y 3x</span><br><span class="hljs-comment">       2z 3z</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CatmullRom</span></span><br><span class="hljs-class">&#123;</span><br>    float2 origin;<br>    float2 weights[<span class="hljs-number">4</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>通过GatherRed提取上一帧像素smbPixelUv的<code>smbCatromFilter</code>区域的view z数据。<code>smbCatromGatherUv</code>为gather 0x的左上角，而 GatherRed 采样得到的是 bilinear 区域的4个像素，顺序如下</p><img src="/images/Rendering Blogs/Graphics Algorithm/2. Reblur解析.assets/image-20230829165239433.png" alt="image-20230829165239433" style="zoom: 67%;"><p>通过 GatherRed 的以下偏移量取wzxy，正好对应上面 Gather 区域（注意首数字 0123 表明了屏幕坐标轴方向），有</p><ul><li><p>(1, 1): smbViewZ0 &#x3D; (0x, 0y, 0z, 0w)。取yzw，prevViewZ0 &#x3D; (0y, 0z, 0w)</p></li><li><p>(3, 1): smbViewZ1 &#x3D; (1x, 1y, 1z, 1w)。取xzw，prevViewZ1 &#x3D; (1x, 1z, 1w)</p></li><li><p>(1, 3): smbViewZ2 &#x3D; (2x, 2y, 2z, 2w)。取xyw，prevViewZ2 &#x3D; (2x, 2y, 2w)</p></li><li><p>(3, 3): smbViewZ3 &#x3D; (3x, 3y, 3z, 3w)。取xyz， prevViewZ3 &#x3D; (3x, 3y, 3z)</p></li></ul></li><li><p>比较view z的差异判断Catmull-Rom区域的occlusion，并生成其中bilinear区域的occlusion weights，以及bilinear区域的可信度(用于之后的累积速度)。</p><p><code>Xprev</code>变换到上一帧的view space得到<code>Xvprev.z</code>(注意：这是当前帧像素 PixelUv 的着色点在上一帧坐标空间下的坐标)。如果差异绝对值超过 smbDisocclusionThreshold，则认为像素不匹配，取0；否则取1。最后可得到 smbOcclusion0、smbOcclusion1、smbOcclusion2、smbOcclusion3。</p><ul><li><p>计算bilinear区域的<code>smbOcclusionWeights</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">float4 smbOcclusionWeights = GetBilinearCustomWeights(smbBilinearFilter, float4(smbOcclusion0.z, smbOcclusion1.y, smbOcclusion2.y, smbOcclusion3.x))<br></code></pre></td></tr></table></figure></li><li><p>Catmull-Rom区域是否匹配，只有匹配时后续才会对历史信息进行 Catmull-Rom filter。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> smbAllowCatRom = dot(smbOcclusion0 + smbOcclusion1 + smbOcclusion2 + smbOcclusion3, <span class="hljs-number">1.0</span>) &gt; <span class="hljs-number">11.5</span><br></code></pre></td></tr></table></figure></li><li><p>bilinear区域的可信度<code>smbFootprintQuality</code>：对 occlusion 进行 smbBilinearFilter 再开方得到，用以之后调整累积速度（越大越倾向于历史信息）。应对视角变化，对于可信度进行调整。例如相机斜对着表面(NoVPrev&lt;1)变为正对着(NoV&#x3D;1)，那么历史信息相对当前帧可信度下降</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> sizeQuality = (NoVprev + <span class="hljs-number">1e-3</span>) / (NoV + <span class="hljs-number">1e-3</span>);<br>sizeQuality *= sizeQuality;<br>sizeQuality = lerp(<span class="hljs-number">0.1</span>, <span class="hljs-number">1.0</span>, saturate(sizeQuality));<br>smbFootprintQuality *= sizeQuality;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>处理材质变化，如果材质ID不匹配，那么视为像素不匹配</p><p>上一帧像素的bilinear区域得到的prevMaterialIDs，与当前像素materialID比较，得到 <code>float4 materialCmps</code>(相同为1，不同为0)，bilinear区域的occlusion乘上 materialCmps 后再计算上述occlusion值，得到</p><p>smbOcclusionWeightsWithMaterialID、smbAllowCatRomWithMaterialID、smbFootprintQualityWithMaterialID</p></li><li><p>上一帧像素 smbPixelUv 的 bilinear 区域 <code>smbBilinearFilter</code></p><p>使用 linear 采样法线得到上一帧 <code>prevNavg</code>，再转到当前帧世界坐标（gWorldPrevToWorld，本例为单位阵）</p><p>收集 smbBilinearFilter 区域4个像素的 diffAccumSpeeds、specAccumSpeeds、prevMaterialIDs。</p></li></ol><h2 id="3-3-History-fix"><a href="#3-3-History-fix" class="headerlink" title="3.3 History fix"></a>3.3 History fix</h2><h3 id="3-3-1-Preload与数据准备-1"><a href="#3-3-1-Preload与数据准备-1" class="headerlink" title="3.3.1 Preload与数据准备"></a>3.3.1 Preload与数据准备</h3><p>与 temporal accumulation 阶段相同，将tile (GROUP_X + BORDER * 2) x (GROUP_Y + BORDER * 2) 加载到 <code>float2 s_FrameNum[BUFFER_Y][BUFFER_X]</code> 中，即累积的帧数(x为diffuse、y为specular)。本阶段的 BORDER 为 2。</p><p>提取当前像素数据：<code>N</code>(世界空间法线)、<code>roughness</code>、<code>Xv</code>(view space坐标)、<code>Nv</code>(view space法线)</p><h3 id="3-3-2-平滑累积帧数"><a href="#3-3-2-平滑累积帧数" class="headerlink" title="3.3.2 平滑累积帧数"></a>3.3.2 平滑累积帧数</h3><p>从 preload 数据中获取当前像素的累积帧数 <code>float2 frameNumUnclamped</code>，当前像素在 preload 数据中的位置 <code>int2 smemPos = threadPos + BORDER;</code></p><p>再使用 <code>gHistoryFixFrameNum</code> 进行归一化得到 <code>normFrameNum</code>。</p><p>在当前像素的 (BORDER * 2 + 1) X (BORDER * 2 + 1) 区域，对归一化累积帧数超过当前像素的样本取平均，得到 <code>normFrameNum</code>。 权重为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">float2 w = step(c, s);<span class="hljs-comment">// c 是当前像素归一化后的累计帧数，s是当前样本归一化后的累积帧数</span><br></code></pre></td></tr></table></figure><p>最终得到 </p><ul><li><p>float2 scale &#x3D; saturate(1.0 - normFrameNum);</p><p>gHistoryFixFrameNum 作为累积帧数阈值，scale相当于累积帧数不足的比例，history fix会对scale超出一定阈值执行。</p></li><li><p>float2 frameNum &#x3D; normFrameNum * gHistoryFixFrameNum;</p></li></ul><h1 id="4-Diffuse-Denoise-Pipeline"><a href="#4-Diffuse-Denoise-Pipeline" class="headerlink" title="4 Diffuse Denoise Pipeline"></a>4 Diffuse Denoise Pipeline</h1><img src="/images/Rendering Blogs/Graphics Algorithm/2. Reblur解析.assets/image-20230820112644427.png" alt="image-20230820112644427" style="zoom:67%;"><h1 id="5-Specular-Denoise-Pipeline"><a href="#5-Specular-Denoise-Pipeline" class="headerlink" title="5 Specular Denoise Pipeline"></a>5 Specular Denoise Pipeline</h1><img src="/images/Rendering Blogs/Graphics Algorithm/2. Reblur解析.assets/image-20230820112723742.png" alt="image-20230820112723742" style="zoom:67%;"><h2 id="5-1-Pre-blur"><a href="#5-1-Pre-blur" class="headerlink" title="5.1 Pre blur"></a>5.1 Pre blur</h2><p>准备好参数后，执行 <a href="#6">6 Specular Spatial Filter</a> </p><h3 id="5-1-1-默认参数与数据准备"><a href="#5-1-1-默认参数与数据准备" class="headerlink" title="5.1.1 默认参数与数据准备"></a>5.1.1 默认参数与数据准备</h3><ol><li>宏定义的默认参数<br><code>REBLUR_SPATIAL_MODE == REBLUR_PRE_BLUR</code><br><code>REBLUR_PRE_BLUR_NON_LINEAR_ACCUM_SPEED</code> 1&#x2F;9<br><code>REBLUR_PRE_BLUR_FRACTION_SCALE</code> 2.0</li><li>CPU传入的可调参数<br>gSpecPrepassBlurRadius 默认 50.0<br>lobeAngleFraction 默认 0.15<br>roughnessFraction 默认 0.15<br>resolutionScale 默认 (1.0, 1.0)<br>gPlaneDistSensitivity 默认 0.005<br>gMinRectDimMulUnproject : <code>(float)ml::Min(rectW, rectH) * unproject</code> </li><li>数据准备<ul><li>当前像素为checkboard选中的采样点时，权重和初始化 sum &#x3D; 1, 获取反射数据 spec</li><li>否则，sum &#x3D; 0，spec &#x3D; float4(0)。因此反射距离为0，表示没有反射光线</li></ul></li></ol><h3 id="5-1-2-blur策略"><a href="#5-1-2-blur策略" class="headerlink" title="5.1.2 blur策略"></a>5.1.2 blur策略</h3><ol><li><p>blur平面的选择：这里选用世界空间的blur平面，与 Reflected GGX-D 垂直，可以更多保留特征<br><img src="/images/Rendering Blogs/Graphics Algorithm/2. Reblur解析.assets/image-20230820113124323.png" alt="image-20230820113124323" style="zoom:80%;"> <img src="/images/Rendering Blogs/Graphics Algorithm/2. Reblur解析.assets/image-20230820113146073.png" alt="image-20230820113146073" style="zoom: 60%;"></p></li><li><p>blur半径的选择：由下图可以看出，反射物体离着色点越近，特征越明显，越远越模糊；此外越粗糙，specular lobe夹角越大，反射也会越模糊。因此反射距离越远、着色点越粗糙，对应越大的blur半径。</p><p>也就是说，specular lobe与反射物体形成的锥形底面的直径越大，对应的blur半径越大。<br><img src="/images/Rendering Blogs/Graphics Algorithm/2. Reblur解析.assets/image-20230820113322228.png" alt="image-20230820113322228" style="zoom: 55%;"><img src="/images/Rendering Blogs/Graphics Algorithm/2. Reblur解析.assets/image-20230820113351881.png" alt="image-20230820113351881" style="zoom:45%;"></p></li></ol><h3 id="5-1-3-blur-radius计算"><a href="#5-1-3-blur-radius计算" class="headerlink" title="5.1.3 blur radius计算"></a>5.1.3 blur radius计算</h3><ol><li><p><code>float hitDist</code> ：基于roughess与viewZ 进行一定缩放，roughness 越小 scale 越大。scale 定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> _REBLUR_GetHitDistanceNormalization(<span class="hljs-type">float</span> viewZ, float4 hitDistParams, <span class="hljs-type">float</span> roughness = <span class="hljs-number">1.0</span>)<br>&#123;<br><span class="hljs-keyword">return</span> (hitDistParams.x + <span class="hljs-built_in">abs</span>(viewZ) * hitDistParams.y) <br>        * <span class="hljs-built_in">lerp</span>(<span class="hljs-number">1.0</span>, hitDistParams.z, <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">exp2</span>(hitDistParams.w * roughness * roughness)));<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 gHitDistParams 定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HitDistanceParameters</span><br>&#123;<br>    <span class="hljs-type">float</span> A = <span class="hljs-number">3.0f</span>; <span class="hljs-comment">// 来自 hitDistScale * meterToUnitsMultiplier，默认为 3.0 * 1.0。大概是米到单位值的变换</span><br>    <span class="hljs-type">float</span> B = <span class="hljs-number">0.1f</span>; <span class="hljs-comment">// (&gt; 0) - viewZ based linear scale (1 m - 10 cm, 10 m - 1 m, 100 m - 10 m)</span><br>    <span class="hljs-type">float</span> C = <span class="hljs-number">20.0f</span>; <span class="hljs-comment">// (&gt;= 1) - roughness based scale, use values &gt; 1 to get bigger hit distance for low roughness</span><br>    <span class="hljs-type">float</span> D = <span class="hljs-number">-25.0f</span>; <span class="hljs-comment">// (&lt;= 0) - absolute value should be big enough to collapse &quot;exp2(D * roughness ^ 2)&quot; to &quot;~0&quot; for roughness = 1</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>在 TraceOpaque 中，会针对reblur 的 hist dist 执行 normalize，变换到 [0, 1] 范围。和上面 scale hit dist 是反向操作，因此相当于是抵消了 :confused: :exclamation:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">normHitDist = <span class="hljs-built_in">REBLUR_FrontEnd_GetNormHitDist</span>(accumulatedHitDist, viewZ, gHitDistParams, isDiffusePath ? <span class="hljs-number">1.0</span> : desc.materialProps.roughness);<br></code></pre></td></tr></table></figure></li><li><p>会将无交点的反射距离，由 NRD_INF 变为 0</p></li></ul></li><li><p><code>lobeRadius</code> ：反射lobe形成的锥形底面的半径</p><ul><li><p>Specular lobe的主方向 <code>float4 Dv</code>：(GGX Dominant Direction, lerp factor) 见附录<br> <code>NoD</code> ：法线与 Dv 的夹角余弦</p></li><li><p>计算lobe夹角正切 <code>float lobeTanHalfAngle</code> ：根据roughness估算specular lobe的半角正切 <a href="#%5B1%5D">[1]</a>(page 72)</p></li><li><p>估算lobe半径大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> lobeRadius = hitDist * NoD * lobeTanHalfAngle;    <span class="hljs-comment">// 没看出有什么精确的几何变换，更像是一个近似模型</span><br></code></pre></td></tr></table></figure><p>对于一个标准圆锥，底部半径正好为 hitDist * lobeTanHalfAngle，这对应的是观察角度与法线夹角为 0 的情况。当观察角度与法线夹角逐渐增大时，如下图所示</p><img src="/images/Rendering Blogs/Graphics Algorithm/2. Reblur解析.assets/image-20241022155550629.png" alt="image-20241022155550629" style="zoom:50%;"><p>NoD 逐渐增大，近似的 lobe 半径逐渐减小。</p></li></ul></li><li><p><code>minBlurRadius</code>: lobeRadius 从世界空间转换到屏幕空间得到。pre blur 的 filter 半径不会超过该值</p><p>转换为像素单位： 世界空间半径 &#x2F; 一个像素对应的世界空间大小。像素对应的世界空间大小，与像素的深度有关，即投影到 viewZ 处的截面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">minBlurRadius = lobeRaidus / <span class="hljs-built_in">PixelRadiusToWorld</span>(gUnproject, gOrthoMode, <span class="hljs-number">1.0</span>, viewZ + hitDist * Dv.w);<br><span class="hljs-comment">// 将屏幕空间以像素为单位的半径投影回视锥体 viewZ 处的截面上的几何半径</span><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">PixelRadiusToWorld</span><span class="hljs-params">(<span class="hljs-type">float</span> unproject, <span class="hljs-type">float</span> orthoMode, <span class="hljs-type">float</span> pixelRadius, <span class="hljs-type">float</span> viewZ)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> pixelRadius * unproject * <span class="hljs-built_in">lerp</span>(viewZ, <span class="hljs-number">1.0</span>, <span class="hljs-built_in">abs</span>(orthoMode)); &#125;<br></code></pre></td></tr></table></figure><ul><li><p>gUnproject：1.0f &#x2F; (0.5f * rectH * project[1]); project[1] 计算的是<br> $$<br> \frac{1}{\tan\alpha_1}<br> $$<br> <img src="/images/Rendering Blogs/Graphics Algorithm/2. Reblur解析.assets/image-20230917160953598.png" alt="image-20230917160953598" style="zoom:50%;"><img src="/images/Rendering Blogs/Graphics Algorithm/2. Reblur解析.assets/image-20230917161201304.png" alt="image-20230917161201304" style="zoom:50%;"></p><p> 如上图所示，视锥体在 viewZ 处的截面高度为 $2 * \text{viewZ} * \tan\alpha_1$，该<strong>截面高度与屏幕高度</strong>的比值为<br> $$<br> \begin{align}<br> &amp; 2 * \text{viewZ} * \tan\alpha_1 * \frac{1}{\text{rectH}} &#x3D; 2 * \text{viewZ} * \frac{1}{\text{project[1]}} * \frac{1}{\text{rectH}} \<br> &amp; &#x3D; \text{viewZ} * \frac{1}{\text{project[1]} * 0.5 * \text{rectH}} \<br> &amp; &#x3D; \text{viewZ} * \text{gUnproject}<br> \end{align}<br> $$<br> 因此屏幕空间像素乘上以上比值，可以投影回viewZ处，得到几何半径。</p></li></ul></li><li><p><code>blurRadius</code> ：使用一个 hitDistFactor 与 specular magic curve 缩放输入radius参数。不理解原理 :question: :confused:</p><ul><li><p><code>float hitDistFactor = hitDist * NoD / frustumSize</code> 并 clamp 到 0~1</p><ul><li><p><code>float frustumSize</code>：<strong>视锥体在 viewZ 处截面的高度</strong>  :confused: ​</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GetFrustumSize</span><span class="hljs-params">(<span class="hljs-type">float</span> minRectDimMulUnproject, <span class="hljs-type">float</span> orthoMode, <span class="hljs-type">float</span> viewZ)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> minRectDimMulUnproject * <span class="hljs-built_in">lerp</span>(viewZ, <span class="hljs-number">1.0</span>, <span class="hljs-built_in">abs</span>(orthoMode)); &#125;<br></code></pre></td></tr></table></figure><p> gMinRectDimMulUnproject : <code>(float)ml::Min(rectW, rectH) * unproject</code></p><p> 因此 frustum size 计算为<br> $$<br> \min(\text{rectW},\text{rectH}) * \text{viewZ} * \text{unproject}<br> $$</p><p> 前述已经讲过 viewZ * unproject 为视锥体在 viewZ 处的截面高度与屏幕高度的比值，因此 frustumSize 描述的是 viewZ 处截面的高度（宽高较小者）</p></li></ul></li><li><p>基于 roughness 与 hitDistFactor 对预设blur radius进行缩放</p><p> 将roughness输入到specular magic curve中，得到 smc。该曲线如下图所示，roughness越大，系数越大，对应更大的blur半径</p> <img src="/images/Rendering Blogs/Graphics Algorithm/2. Reblur解析.assets/image-20231123161625155.png" alt="image-20231123161625155" style="zoom: 50%;"> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">blurRadius = gSpecPrepassBlurRadius * hitDistFactor * smc;<br></code></pre></td></tr></table></figure><ul><li><p>hitDistFactor &#x3D; hitDist * NoD &#x2F; frustumSize: </p><p>如前述，frustumSize 表示 viewZ 处截面的高度，即处于世界空间。hitDist&#x2F;frustumSize 用于适应不同尺度的场景，作为缩放。NoD 则是越 grazing，半径越小。这与 lobeRadius 表现一致</p></li></ul></li><li><p><code>blurRadius = min(blurRadius, minBlurRadius);</code></p></li></ul></li></ol><h3 id="5-1-4-采样"><a href="#5-1-4-采样" class="headerlink" title="5.1.4 采样"></a>5.1.4 采样</h3><p>确定好filter半径后，开始在像素的 filter 区域进行采样。采样过程需要记录 <code>float minHitDist = hitDist == 0.0 ? NRD_INF : hitDist;</code>，5.1.1 小节提到 hitDist &#x3D;&#x3D; 0 表示无反射光线情况:heavy_exclamation_mark:，此时 blur radius 也正好对应 0。</p><p>在确定好一个采样点后，由于是checkboard模式，需要将采样点偏移到所属checkboard采样位置，即具有反射光线的位置：</p><ul><li><p>样本权重计算：与 <a href="#6">6</a> 中的权重设计一致，但 pre blur 还会有额外处理</p><ul><li><p>hs：采样点的 scaled hit distance</p></li><li><p>d：采样点到着色点的距离</p></li><li><p>调整权重 w</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> t = hs / (d + hitDist); <span class="hljs-comment">// hisDist 为着色点的 scaled hit distance</span><br>w *= <span class="hljs-built_in">lerp</span>(<span class="hljs-built_in">saturate</span>(t), <span class="hljs-number">1.0</span>, <span class="hljs-built_in">LinearStep</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">1.0</span>, roughness)); <span class="hljs-comment">// LinearStep(a, b, x) = saturate((x-a)/(b-a))</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>minHitDist：记录最小 scaled hit distance，但引入了随机</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> geometryWeight = w * <span class="hljs-built_in">saturate</span>(hs / d);<br><span class="hljs-keyword">if</span>(Rng::Hash::<span class="hljs-built_in">GetFloat</span>() &lt; geometryWeight) minHitDist = <span class="hljs-built_in">min</span>(minHitDist, hs);<br></code></pre></td></tr></table></figure></li></ul><p>输出结果：</p><ul><li><p><code>Spec_HitDistForTracking</code> ：记录采样区域的最小反射距离（scaled）<code>minHitDist == NRD_INF ? 0.0 : minHitDist;</code></p></li><li><p>specular 执行加权平均，对于权重为 0 的情况，使用相邻像素进行基于深度的bilateral加权平均</p></li></ul><h2 id="5-2-Temporal-Accumulation"><a href="#5-2-Temporal-Accumulation" class="headerlink" title="5.2 Temporal Accumulation"></a>5.2 Temporal Accumulation</h2><h3 id="5-2-1-Preload-与数据准备"><a href="#5-2-1-Preload-与数据准备" class="headerlink" title="5.2.1 Preload 与数据准备"></a>5.2.1 Preload 与数据准备</h3><ol><li><p>预加载 tile <code>(GROUP_X+BORDER*2) x (GROUP_Y+BORDER*2)</code> 的数据，</p><ul><li><p>normal roughness 数据加载到 <code>s_Normal_Roughness[GROUP_X+BORDER*2][GROUP_Y+BORDER*2]</code> 中</p></li><li><p>HitDistForTracking 加载到 <code>s_HitDistForTracking[GROUP_X+BORDER*2][GROUP_Y+BORDER*2]</code></p></li></ul></li><li><p>访问预加载数据，遍历当前像素的 <code>(BORDER*2) x (BORDER*2)</code>区域，(i, j) &#x3D;&#x3D; (BORDER, BORDER) 表示当前像素数据</p><ul><li><p><code>Navg</code>：法线平均</p></li><li><p><code>hitDistForTracking</code> ：最短反射路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> h = s_HitDistForTracking[pos.y][pos.x];<br>hitDistForTracking = <span class="hljs-built_in">min</span>(hitDistForTracking, h == <span class="hljs-number">0.0</span> ? NRD_INF : h);<br></code></pre></td></tr></table></figure></li><li><p><code>roughnessM1</code>、<code>roughnessM2</code> 这里使用 (roughness * roughness) 的一阶矩、二阶矩</p></li><li><p>这里只遍历了 (i &lt; 2 &amp;&amp; j &lt; 2) 部分，相当于像素左上角区域，有点奇怪 :confused:  :question:</p></li></ul></li><li><p>当前像素数据：view space 坐标<code>Xv</code>，世界坐标 <code>X</code>，法线 <code>N</code>，<code>roughness</code></p><ul><li><code>roughnessModified</code>：基于 Navg 对 roughness 进行修改</li><li><code>roughnessSigma</code>：roughness 标准差</li><li><code>histDistForTracking</code> 再次更新到<code>gOut_Spec_HitDistForTracking</code></li></ul></li></ol><h3 id="5-2-2-估算沿运动方向的-curvature"><a href="#5-2-2-估算沿运动方向的-curvature" class="headerlink" title="5.2.2 估算沿运动方向的 curvature"></a>5.2.2 估算沿运动方向的 curvature</h3><h4 id="5-2-2-1-着色点的运动方向"><a href="#5-2-2-1-着色点的运动方向" class="headerlink" title="5.2.2.1 着色点的运动方向"></a>5.2.2.1 着色点的运动方向</h4><p>将相机的运动转为着色点的运动 Xprev - gCameraDelta(将上一帧的着色点施加上一帧相机到当前帧的运动)，再变换到当前帧 screen uv空间，得到运动后的着色点的 <code>motionUv</code>。因此，uv空间的运动方向 <code>cameraMotion2d</code> 计算如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cameraMotion2d = normalize((motionUV-pixelUV) * gRectSize) * gInvRectSize;<span class="hljs-comment">// 转为像素单位标准化，再转为uv单位</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：这里的 cameraMotion2d 不只是相机的运动矢量，如果着色点具有动画，由于 Xprev 是动画前的世界坐标，因此还有动画带来的运动</p></blockquote><p>接下来选择两个运动方向上的视差点，基于这两点以及着色点的法线、位置以及观察方向来计算曲率：</p><ul><li><p>在运动方向上走一个单位得到一个低 parallax 点</p><p><code>float2 uv = pixelUv + cameraMotion2d * 0.99;</code></p></li><li><p>在运动方向上走前述计算的视差距离个单位</p><p><code>float2 uvHigh = pixelUv + cameraMotion2d * smbParallaxInPixels;</code></p></li></ul><h4 id="5-2-2-2-Low-parallax"><a href="#5-2-2-2-Low-parallax" class="headerlink" title="5.2.2.2 Low parallax"></a>5.2.2.2 Low parallax</h4><p>像素的bilinear区域以及描述定义如下</p><img src="/images/Rendering Blogs/Graphics Algorithm/2. Reblur解析.assets/image-20230822111025809.png" alt="image-20230822111025809" style="zoom: 67%;"><p><code>Bilinear f</code>的定义与计算如下，origin 是 bilinear 2x2 区域起始坐标(像素单位)，weights是距 origin 像素中心的偏移量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Bilinear</span></span><br><span class="hljs-class">&#123;</span><br>    float2 origin;<span class="hljs-comment">// Bilinar 2x2 区域起点</span><br>    float2 weights;<span class="hljs-comment">// 插值权重</span><br>&#125;;<br>Bilinear <span class="hljs-title function_">GetBilinearFilter</span><span class="hljs-params">(float2 uv, float2 texSize)</span> &#123;<br>float2 t = uv * texSize - <span class="hljs-number">0.5</span>;<br>    Bilinear result;<br>    result.origin = <span class="hljs-built_in">floor</span>(t);<br>    result.weights = t - result.origin;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>当前像素的bilinear区域考虑了小的视差，所位于的bilinear区域大多在Preload的数据 <code>s_Normal_MinHitDist</code> 中。存储位置计算如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// threadPos+BORDER为当前像素在tile数据中的位置，int2(f.origin)-pixelPos为bilinear区域相对于当前像素的偏移量</span><br>int2 pos = threadPos + BORDER + int2(f.origin) - pixelPos;<br>pos = clamp(pos, <span class="hljs-number">0</span>, int2(BUFFER_X, BUFFER_Y) - <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure></li><li><p>Bilinear filter后的法线 <code>n</code>，2x2区域的4个像素的法线为 n00 (pos + (0, 0))、n10 (pos + (1, 0))、n01 (pos + (0, 1))、n11 (pos + (1, 1))<br>bilinear计算如下，两个水平方向的插值，再加上一个垂直方向的插值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">lerp(lerp(s00, s10, f.weights.x), lerp(s01, s11, f.weights.x), f.weights.y);<br></code></pre></td></tr></table></figure></li></ol><h4 id="5-2-2-3-High-parallax"><a href="#5-2-2-3-High-parallax" class="headerlink" title="5.2.2.3 High parallax"></a>5.2.2.3 High parallax</h4><p>与 low parallax 计算normal不同的是 uvHigh 的视差较大，因此其bilinear区域大多不在preload tile数据内，从贴图中采样并执行 bilinear filter，得到 <code>nHigh</code>。</p><p>同时bilinear filter uvHigh 的 view space深度得到<code>zHigh</code>。计算 zHigh 与当前着色点 viewZ 之间的相对误差</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> zError = <span class="hljs-built_in">abs</span>(zHigh - viewZ) * rcp(max(zHigh, viewZ));<br></code></pre></td></tr></table></figure><p>如果相对误差 <code>zError</code> &lt; 0.1，则选择high parallax的 uvHigh 与 nHigh；否则，选择 low parallax 的 uv 与 n。</p><h4 id="5-2-2-4-计算-curvature"><a href="#5-2-2-4-计算-curvature" class="headerlink" title="5.2.2.4 计算 curvature"></a>5.2.2.4 计算 curvature</h4><p>使用当前像素的 <code>X</code>(世界坐标)、<code>N</code>(法线)、<code>Navg</code> 以及所选parallax 点的 <code>v</code>(世界空间观察方向)、<code>n</code>(世界空间法线)计算这两点曲率 :question:</p><h3 id="5-2-5-累积速度更新"><a href="#5-2-5-累积速度更新" class="headerlink" title="5.2.5 累积速度更新"></a>5.2.5 累积速度更新</h3><p>本例中 gSpecMaterialMask &#x3D; 0，因此 <code>specOcclusionWeights</code> 采用前面计算的不带材质比较的 smbOcclusionWeights；<code>specHistoryConfidence</code> 采用 smbFootprintQuality，即<code>smbPixelUv</code>的bilinear区域的可信度。</p><p>历史帧<code>smbPixelUv</code>的bilinear区域的累积速度 specAccumSpeeds，使用specOcclusionWeights得到加权平均<code>specAccumSpeed</code>。根据bilinear区域的可信度调整历史信息的累积帧数：如果 confidence &#x3D; 1，累积帧数不变；如果confidence &lt; 1，累积帧数减小，则混合权重更倾向于当前帧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// specAccumSpeed *= ((specAccumSpeed * confidence + 1) / (1 + specAccumSpeed));</span><br>specAccumSpeed *= lerp(specHistoryConfidence, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> / ( <span class="hljs-number">1.0</span> + specAccumSpeed));<span class="hljs-comment">// +1 避免除 0 </span><br>specAccumSpeed = min(specAccumSpeed, gMaxAccumulatedFrameNum);<span class="hljs-comment">// fast history下 gMaxAccumulatedFrameNum = 5，否则 30</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：累积速度在保存时除以最大累积帧数<code>REBLUR_MAX_ACCUM_FRAME_NUM</code>(63)，在提取时再乘上最大累积帧数。因此计算过程中，表示的是历史帧信息的累积帧数</p></blockquote><h3 id="5-2-6-Virtual-motion-based-reprojection"><a href="#5-2-6-Virtual-motion-based-reprojection" class="headerlink" title="5.2.6 Virtual motion based reprojection"></a>5.2.6 Virtual motion based reprojection</h3><img src="/images/Rendering Blogs/Graphics Algorithm/2. Reblur解析.assets/image-20230903135344354.png" alt="image-20230903135344354" style="zoom:50%;"><p>对于反射的重投影，反射的世界具有自己的运动，例如反射点具有动画，而着色点与相机是静止的，这时着色点的反射也发生了运动。而反射点的运动常常使用虚拟反射点来追踪，如上图所示的镜面反射的虚拟反射点可以通过在着色点处，沿着相机到着色点的方向延长反射距离得到，计算如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">float3 Xvirtual = X - V * hitDist;<br>float2 pixelUvVirtualPrev = GetScreenUv(gWorldToClipPrev, Xvirtual);<br></code></pre></td></tr></table></figure><p>但这种方法只对镜面反射有效，而实际的glossy反射，虚拟反射点会更加接近表面。</p><ol><li><p>计算虚拟反射点<code>Xvirtual</code></p><ul><li><p>对preload阶段得到的当前像素2x2区域最小反射距离进行一定scale <code>hitDistForTracking *= hitDistScale</code></p></li><li><p>计算着色点处的GGX Dominant Direction <code>float4 D</code>，D.w 是 n 到 r(镜面反射方向) 的插值，roughness增大会导致specular lobe主方向偏向法线。</p></li><li><p>虚拟反射点计算如下:question:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> <span class="hljs-title function_">ApplyThinLensEquation</span><span class="hljs-params">( <span class="hljs-type">float</span> NoV, <span class="hljs-type">float</span> hitDist, <span class="hljs-type">float</span> curvature )</span><br>&#123; <span class="hljs-comment">// https://www.geeksforgeeks.org/sign-convention-for-spherical-mirrors/</span><br>    <span class="hljs-type">float</span> hitDistFocused = hitDist / (<span class="hljs-number">2.0</span> * curvature * hitDist * NoV + <span class="hljs-number">1.0</span>);<br>    <span class="hljs-keyword">return</span> hitDistFocused;<br>&#125;<br>float3 <span class="hljs-title function_">GetXvirtual</span><span class="hljs-params">(<span class="hljs-type">float</span> NoV, <span class="hljs-type">float</span> hitDist, <span class="hljs-type">float</span> curvature, float3 X, float3 Xprev, float3 V, <span class="hljs-type">float</span> dominantFactor)</span><br>&#123;<br>    <span class="hljs-type">float</span> hitDistFocused = ApplyThinLensEquation(NoV, hitDist, curvature);<br>    <span class="hljs-type">float</span> closenessToSurface = saturate(<span class="hljs-built_in">abs</span>(hitDistFocused) / (hitDist + NRD_EPS));<br><br>    <span class="hljs-keyword">return</span> lerp(Xprev, X, closenessToSurface * dominantFactor) - V * hitDistFocused * dominantFactor;<br>&#125;<br></code></pre></td></tr></table></figure><p>Xvritual 变换到上一帧screen uv空间，得到 <code>vmbPixelUv</code></p></li><li><p>使用虚拟反射点与着色点在上一帧的像素距离 <code>vmbPixelsTraveled</code> 表达virtual motion</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">float2 vmbDelta = vmbPixelUv - smbPixelUv;<br><span class="hljs-type">float</span> vmbPixelsTraveled = length(vmbDelta * gRectSize);<br></code></pre></td></tr></table></figure></li><li><p>根据virtual motion对curvature进行调整，再重新计算上述虚拟反射点相关变量，例如 Xvirtual、vmbPixelUv、vmbDelta、vmbPixelsTraveled。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> curvatureCorrection = <span class="hljs-type">float</span>(vmbPixelsTraveled &lt; <span class="hljs-number">3.0</span> * smbParallaxInPixels + gInvRectSize.x);<br>curvature *= curvatureCorrection;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>occlusion判断：虚拟反射点在上一帧的vmbPixelUv，对应bilinear区域<code>vmbBilinearFilter</code> ，计算该区域的occlusion。</p><ul><li><p>获取上一帧数据：</p><ul><li><code>vmbViewZs</code>：vmbBilinearFilter区域的view z</li><li><code>vmbVv</code>：vmbPixelUv像素取view z &#x3D; 1得到的view space坐标，指向vmbPixelUv像素并且z&#x3D;1的view space下的向量</li><li><code>Nvprev</code>：当前帧像素的 <code>Navg</code>转到上一帧view space</li></ul></li><li><p>使用到着色点平面的距离的差异来评估occlusion</p><ul><li><p>上一帧bilinear区域到着色点平面的距离计算如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">float4 NoX = (Nvprev.x * vmbVv.x + Nvprev.y * vmbVv.y) * (gOrthoMode == <span class="hljs-number">0</span> ? vmbViewZs : gOrthoMode) + Nvprev.z * vmbVv.z * vmbViewZs;<br><span class="hljs-comment">// gOrthoMode = 0</span><br>NoX = vmbViewZs * dot(Nvprev, vmbVv);<br></code></pre></td></tr></table></figure><p>由于 vmbVv 是 vmbPixelUv像素在 view z &#x3D; 1 的点，通过变换可以得到 vmbViewZs * vmbVv 则是bilinear区域的四个点（这里忽略了像素点的不同）。因此NoX计算的是bilinear区域4个点到着色点平面法线的距离（这里的平面方程常数项为0）</p></li><li><p>着色点在上一帧的平面方程常数项：<code>float NoXreal = dot(Navg, X - gCameraDelta);</code></p><p>由于 Navg 位于世界空间，因此到上一帧世界空间不需要变换</p><p>X - gCameraDelta：着色点世界坐标变换到上一帧的世界空间。</p><ul><li><p>注意，正常情况下是不需要此变换的，因为世界空间是绝对的，但由于前面所述，这里的变换都取消掉了当前帧的相机平移，也就是以当前帧相机为原点。</p></li><li><p>简单推导：gCameraDelta是指向上一帧的相机运动向量，X是当前帧着色点的世界坐标，又是(着色点-&gt;相机)的向量。因此 X-gCameraDelta为(上一帧相机-&gt;着色点)的向量。</p></li><li><p>dot(Navg, x-gCameraDelta) &#x3D; ||Navg|| * ||x-gCameraDelta|| * cos &#x3D; ||x-gCameraDelta|| * cos</p><p>相当于将 Navg与X转到上一帧的view space 下，再求平面方程常数项。保持与 NoX 的坐标空间一致。</p></li></ul></li><li><p><code>float4 vmbPlaneDist = abs(NoX-NoXreal)</code>：计算的是虚拟反射点在上一帧对应的bilinear区域到着色点平面的距离。</p></li></ul></li><li><p><code>float4 vmbOcclusion = step(vmbPlaneDist, disocclusionThresholdMulFrustumSize);</code></p><p>之后就和surface motion计算类似</p><ul><li><p><code>float4 vmbOcclusionWeights</code>：bilinear权重施加vmbOcclusion 得到</p></li><li><p>是否可以使用 catrom filter：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> vmbAllowCatRom = dot( vmbOcclusion, <span class="hljs-number">1.0</span> ) &gt; <span class="hljs-number">3.5</span> &amp;&amp; REBLUR_USE_CATROM_FOR_VIRTUAL_MOTION_IN_TA;<br>vmbAllowCatRom = vmbAllowCatRom &amp;&amp; specAllowCatRom;<br></code></pre></td></tr></table></figure></li><li><p>bilinear可信度 <code>vmbFootprintQuality</code>： 对 vmbOcclusion  执行 bilinear filter 再开方得到</p></li></ul></li></ul></li></ol><h4 id="5-2-6-1-累积速度更新"><a href="#5-2-6-1-累积速度更新" class="headerlink" title="5.2.6.1 累积速度更新"></a>5.2.6.1 累积速度更新</h4><p>使用 vmbBilinearGatherUv 获取上一帧 vmbBilinearFilter 区域的累积速度，使用vmbOcclusionWeights加权平均得到 <code>vmbSpecAccumSpeed</code>，再使用 vmbBilinearFilter  区域的可信度调整累积速度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// vmbSpecAccumSpeed *= ((vmbSpecAccumSpeed * confidence + 1) / (1 + vmbSpecAccumSpeed));</span><br>vmbSpecAccumSpeed *= lerp(vmbFootprintQuality, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> / (<span class="hljs-number">1.0</span> + vmbSpecAccumSpeed));<br></code></pre></td></tr></table></figure><p>与surface motion不同的是，最大帧数进行了如下限制，本例中 <code>gResponsiveAccumulationRoughnessThreshold=0</code>，因此无作用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> <span class="hljs-title function_">GetResponsiveAccumulationAmount</span><span class="hljs-params">(<span class="hljs-type">float</span> roughness)</span><br>&#123;<span class="hljs-comment">// 当 roughness 大于阈值时为0，roughness越小，返回值越大。但 gResponsiveAccumulationRoughnessThreshold 为 0，返回值恒为0</span><br>    <span class="hljs-type">float</span> amount = <span class="hljs-number">1.0</span> - (roughness + NRD_EPS) / (gResponsiveAccumulationRoughnessThreshold + NRD_EPS);<br>    <span class="hljs-keyword">return</span> STL::Math::SmoothStep01(amount);<br>&#125;<br><span class="hljs-type">float</span> responsiveAccumulationAmount = GetResponsiveAccumulationAmount(roughness);<br>responsiveAccumulationAmount = lerp(<span class="hljs-number">1.0</span>, GetSpecMagicCurve(roughness), responsiveAccumulationAmount);<br><br><span class="hljs-type">float</span> vmbMaxFrameNum = gMaxAccumulatedFrameNum * responsiveAccumulationAmount;<br>vmbSpecAccumSpeed = min(vmbSpecAccumSpeed, vmbMaxFrameNum);<br></code></pre></td></tr></table></figure><h4 id="5-2-6-2-Surface-与-Virtual-之间的混合权重"><a href="#5-2-6-2-Surface-与-Virtual-之间的混合权重" class="headerlink" title="5.2.6.2 Surface 与 Virtual 之间的混合权重"></a>5.2.6.2 Surface 与 Virtual 之间的混合权重</h4><p><code>virtualHistoryAmount</code>，用于混合 virtual-motion based 与 surface-motion based重投影。 </p><ul><li><p>初始为 GGX-D 的 lerpFactor</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> virtualHistoryAmount = IsInScreen(vmbPixelUv) * D.w;<br></code></pre></td></tr></table></figure></li><li><p>virtual motion的bilinear区域可信度 <code>vmbFootprintQuality</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">virtualHistoryAmount *= saturate(vmbFootprintQuality / <span class="hljs-number">0.5</span>);<br></code></pre></td></tr></table></figure></li><li><p>normal：根据着色点法线 <code>N</code>与虚拟反射点法线<code>vmbN</code>、virtual motion走过的弧度 <code>angle</code> 得到 <code>virtualHistoryNormalBasedConfidence</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">virtualHistoryAmount *= lerp(<span class="hljs-number">1.0</span> - saturate(vmbPixelsTraveled), <span class="hljs-number">1.0</span>, virtualHistoryNormalBasedConfidence)<br></code></pre></td></tr></table></figure></li><li><p>back-facing: 虚拟反射点法线 vmbN 与着色点的平均法线 Navg。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">virtualHistoryAmount *= <span class="hljs-type">float</span>(dot(vmbN, Navg) &gt; <span class="hljs-number">0.0</span>)<br></code></pre></td></tr></table></figure></li><li><p>roughness: <code>virtualHistoryRoughnessBasedConfidence</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">virtualHistoryAmount *= lerp(<span class="hljs-number">1.0</span> - saturate(vmbPixelsTraveled), <span class="hljs-number">1.0</span>, virtualHistoryRoughnessBasedConfidence)<br></code></pre></td></tr></table></figure></li><li><p>在virtual motion方向上的少量像素累积roughness权重 <code>wr</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">virtualHistoryAmount *= <span class="hljs-number">0.1</span> + wr * <span class="hljs-number">0.9</span>;<br>virtualHistoryRoughnessBasedConfidence *= wr;<br></code></pre></td></tr></table></figure></li></ul><h3 id="5-2-7-混合"><a href="#5-2-7-混合" class="headerlink" title="5.2.7 混合"></a>5.2.7 混合</h3><h4 id="5-2-7-1-历史数据filter"><a href="#5-2-7-1-历史数据filter" class="headerlink" title="5.2.7.1 历史数据filter"></a>5.2.7.1 历史数据filter</h4><p>当 <code>specAllowCatRom == true</code>时，使用 catrom filter；否则使用 specOcclusionWeights 进行bilinear filter，得到着色点在上一帧的specular历史filter结果 <code>smbSpecHistory, smbSpecFastHistory</code>。</p><p>同理，当 <code>vmbAllowCatRom == true</code>时，使用 catrom filter；否则使用 vmbOcclusionWeights 进行bilinear filter，得到虚拟反射点在上一帧的 specular 历史filter结果<code>vmbSpecHistory, vmbSpecFastHistory</code></p><p>SpecHistory 是 float4(radiance, dist)，SpecFastHistory 是 float2(luma, hitDistForTrackingPrev)</p><h4 id="5-2-7-2-virtual-history-confidence"><a href="#5-2-7-2-virtual-history-confidence" class="headerlink" title="5.2.7.2 virtual history confidence"></a>5.2.7.2 virtual history confidence</h4><p>用于历史radiance clamp，以及控制累积速度</p><ul><li><p>virtual parallax difference：使用 SpecFastHistory 的 hitDist 得到虚拟反射点 <code>XvirtualPrev</code>，变换到上一帧的sreen uv空间得到 <code>vmbPixelUvPrev</code>。得到与 vmbPixelUv的像素距离 <code>deltaParallaxInPixels</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// lobeRadiusInPixels 着色点处反射lobe半径</span><br><span class="hljs-type">float</span> virtualHistoryConfidence = STL::Math::SmoothStep(lobeRadiusInPixels + <span class="hljs-number">0.25</span>, <span class="hljs-number">0.0</span>, deltaParallaxInPixels);<br></code></pre></td></tr></table></figure></li><li><p>在virtual motion方向上的少量像素累积roughness权重 <code>wr</code>、normal权重 <code>w1</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">virtualHistoryConfidence *= isInScreen ? w1 : <span class="hljs-number">1.0</span>;<br></code></pre></td></tr></table></figure></li></ul><h4 id="5-2-7-3-累积速度与混合权重更新"><a href="#5-2-7-3-累积速度与混合权重更新" class="headerlink" title="5.2.7.3 累积速度与混合权重更新"></a>5.2.7.3 累积速度与混合权重更新</h4><p><code>vmbSpecAccumSpeed *= virtualHistoryConfidence;</code></p><p>surface motion based：<code>smbSpecAccumSpeed</code></p><p>由 virtualHistoryAmount 混合得到最终的 <code>specAccumSpeed</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">virtualHistoryAmount *= <span class="hljs-built_in">saturate</span>(vmbSpecAccumSpeed / (smbSpecAccumSpeed + NRD_EPS)); <span class="hljs-comment">// gNonReferenceAccumulation = 1</span><br>specAccumSpeed = <span class="hljs-built_in">lerp</span>(smbSpecAccumSpeed, vmbSpecAccumSpeed, virtualHistoryAmount);<br></code></pre></td></tr></table></figure><h4 id="5-2-7-4-Specular-混合"><a href="#5-2-7-4-Specular-混合" class="headerlink" title="5.2.7.4 Specular 混合"></a>5.2.7.4 Specular 混合</h4><ul><li><p>混合速度选用 <code>float specNonLinearAccumSpeed = 1.0 / (1.0 + specAccumSpeed);</code></p><p>当checkboard模式下，当前无有效数据时，<code>specNonLinearAccumSpeed *= lerp(1.0 - gCheckerboardResolveAccumSpeed, 1.0, specNonLinearAccumSpeed);</code></p></li><li><p>混合surface motion 与 virtual motion的历史specular：<code>specHistory = lerp(smbSpecHistory, vmbSpecHistory, virtualHistoryAmount);</code></p></li><li><p>混合历史specular与当前specular 得到最终累积结果 <code>specResult</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">specResult = MixHistoryAndCurrent(specHistory, spec, specNonLinearAccumSpeed, roughnessModified);<br>float4 <span class="hljs-title function_">MixHistoryAndCurrent</span><span class="hljs-params">(float4 history, float4 current, <span class="hljs-type">float</span> f, <span class="hljs-type">float</span> roughness = <span class="hljs-number">1.0</span>)</span><br>&#123;<br>    float4 r;<br>    r.xyz = lerp(history.xyz, current.xyz, f);<br>    r.w = lerp(history.w, current.w, max(f, GetMinAllowedLimitForHitDistNonLinearAccumSpeed(roughness)));<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>specular混合结果的 hit dist 与 lum矫正（Anti-firefly suppressor）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// REBLUR_FIREFLY_SUPPRESSOR_RADIUS_SCALE 0.1, gBlurRadius 15</span><br><span class="hljs-type">float</span> specAntifireflyFactor = specAccumSpeed * gBlurRadius * REBLUR_FIREFLY_SUPPRESSOR_RADIUS_SCALE * smc;<br>specAntifireflyFactor /= <span class="hljs-number">1.0</span> + specAntifireflyFactor;<br></code></pre></td></tr></table></figure><p>virtual motion 与 surface motion 的混合结果 与 最终时序累积结果之间的混合</p></li><li><p>fast history混合</p></li><li><p>计算误差 GetColorErrorForAdaptiveRadiusScale，之后blur基于此调整blur radius</p></li></ul><h2 id="5-3-History-Fix"><a href="#5-3-History-Fix" class="headerlink" title="5.3 History Fix"></a>5.3 History Fix</h2><h3 id="5-3-1-Preload"><a href="#5-3-1-Preload" class="headerlink" title="5.3.1 Preload"></a>5.3.1 Preload</h3><p>从 fast history 加载 lum 到 <code>float s_SpecLuma[BUFFER_Y][BUFFER_X]</code></p><h3 id="5-3-2-History-Reconstruction"><a href="#5-3-2-History-Reconstruction" class="headerlink" title="5.3.2 History Reconstruction"></a>5.3.2 History Reconstruction</h3><p>当累积帧数相对于 <code>gHistoryFixFrameNum</code> 小于 (1-REBLUR_HISTORY_FIX_THRESHOLD_1) 比例时 (0.111)，执行 history reconstruction。</p><ol><li><p>采样步长 <code>scale.y</code>（像素单位）：与前面计算相同，得到specular lobe的 <code>lobeRadius</code>(世界空间)，再转到屏幕空间得到 <code>minBlurRadius</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// gHistoryFixStrideBetweenSamples = 14.0，frameNum 是 gHistoryFixFrameNum 范围内的平滑帧数</span><br>scale.y = min(gHistoryFixStrideBetweenSamples / (<span class="hljs-number">2.0</span> + frameNum.y), minBlurRadius / <span class="hljs-number">2.0</span>);<br></code></pre></td></tr></table></figure></li><li><p>权重参数：normal、geometry、roughness 与之前计算相同</p></li><li><p>在 [-2, 2] x [-2, 2] 区域进行加权平均specular得到 <code>spec</code>，</p><ul><li>每个样本为 <code>float2 uv = pixelUv + float2(i, j) * gInvRectSize * scale.y;</code></li><li>使用权重参数计算每个样本的权重</li></ul></li><li><p>在以当前像素为中心的 (BORDER * 2 + 1) x (BORDER * 2 + 1) 区域计算 luma 一阶矩<code>specM1</code>、二阶矩<code>specM2</code>。</p><p>每个样本的luma数据都在shared data <code>s_SpecLuma</code> 中</p></li><li><p>如果开启了 antiFirefly ，则在 [-4, 4] x [-4, 4] 区域计算 luma 的一阶矩 m1、二阶矩 m2，限制filter结果spec的luma <code>specLuma</code> </p><p><code>clamp(specLuma, m1-sigma, m1+sigma)</code>，sigma为标准差</p></li><li><p>使用 specM1、specM2以及当前像素的lum specCenter 对 specLuma 进行 clamp 得到 <code>specLumaClamped</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> specMin = min(specM1 - specSigma, specCenter);<br><span class="hljs-type">float</span> specMax = max(specM1 + specSigma, specCenter);<br><span class="hljs-type">float</span> specLumaClamped = clamp(specLuma, specMin, specMax);<br></code></pre></td></tr></table></figure></li><li><p>specLumaClamped 到 specLuma 之间的插值得到最终的 specLuma，插值权重由累积帧数决定</p></li></ol>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">specLuma = lerp(specLumaClamped, specLuma, <br>                <span class="hljs-number">1.0</span> / (<span class="hljs-number">1.0</span> + <span class="hljs-type">float</span>(gMaxFastAccumulatedFrameNum &lt; gMaxAccumulatedFrameNum) * frameNumUnclamped.y));<br></code></pre></td></tr></table></figure><p>   对filter结果ChangeLuma得到最终输出 <code>spec = ChangeLuma(spec, specLuma);</code></p><h2 id="5-4-Blur"><a href="#5-4-Blur" class="headerlink" title="5.4 Blur"></a>5.4 Blur</h2><h3 id="5-4-1-blur-radius计算"><a href="#5-4-1-blur-radius计算" class="headerlink" title="5.4.1 blur radius计算"></a>5.4.1 blur radius计算</h3><p>输入参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">gBlurRadius = <span class="hljs-number">15.0f</span>;<br></code></pre></td></tr></table></figure><p>根据时序累积信息speed(累积帧数)与error来计算blur radius。</p><ul><li><p>基于accum speed的boost参数：观察角度越grazing、累积帧数越少，boost越大</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> boost = <span class="hljs-number">1.0</span> - <span class="hljs-built_in">GetFadeBasedOnAccumulatedFrames</span>(accumSpeed);<br>boost *= (<span class="hljs-number">1.0</span> - <span class="hljs-built_in">pow5</span>(NoV)) * smc;<br><span class="hljs-comment">// (accumSpeed - historyFixFrameNum * 2/3) / (historyFixFrameNum * 2/3)</span><br><span class="hljs-comment">// 累积帧数超过 2/3 的 history fix frame时，boost逐渐降低，blur radius也会降低</span><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GetFadeBasedOnAccumulatedFrames</span><span class="hljs-params">(<span class="hljs-type">float</span> accumSpeed)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> a = gHistoryFixFrameNum * <span class="hljs-number">2.0</span> / <span class="hljs-number">3.0</span> + <span class="hljs-number">1e-6</span>;<br>    <span class="hljs-type">float</span> b = gHistoryFixFrameNum * <span class="hljs-number">4.0</span> / <span class="hljs-number">3.0</span> + <span class="hljs-number">2e-6</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">saturate</span>((accumSpeed - a) / (b - a));<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>hitDistFactor自适应调整：累积帧数越少，hitDistFactor越趋向于1</p><ul><li><p>根据error的调整：<code>hitDistFactor = lerp(hitDistFactor, 1.0, error)</code></p></li><li><p>根据roughness的调整：<code>float relaxedHitDistFactor = lerp(1.0, hitDistFactor, roughness);</code></p></li><li><p>根据speed混合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> specNonLinearAccumSpeed = <span class="hljs-number">1.0</span> / (<span class="hljs-number">1.0</span> + (<span class="hljs-number">1.0</span> - boost) * accumSpeed);<br>hitDistFactor = <span class="hljs-built_in">lerp</span>(hitDistFactor, relaxedHitDistFactor, specNonLinearAccumSpeed);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>计算 blurRadius：</p><ul><li><p>boost调控额外增加的radius</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> blurRadius = gBlurRadius * (<span class="hljs-number">1.0</span> + <span class="hljs-number">2.0</span> * boost) / <span class="hljs-number">3.0</span>;<br></code></pre></td></tr></table></figure></li><li><p>进行缩放：<code>blurRadius *= hitDistFactor * smc;</code></p></li><li><p><code>blurRadius = min(blurRadius, minBlurRadius);</code></p></li><li><p>额外处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Blur radius - addition to avoid underblurring</span><br>blurRadius += smc;<br><span class="hljs-comment">// radiusScale = 1</span><br>blurRadius *= radiusScale * <span class="hljs-built_in">float</span>(gBlurRadius != <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="6-Specular-Spatial-Filter"><a href="#6-Specular-Spatial-Filter" class="headerlink" title="6 Specular Spatial Filter "></a>6 Specular Spatial Filter <a name="6"></a></h1><h2 id="6-1-权重参数计算"><a href="#6-1-权重参数计算" class="headerlink" title="6.1 权重参数计算"></a>6.1 权重参数计算</h2><p>一些使用到的默认参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> specNonLinearAccumSpeed = REBLUR_PRE_BLUR_NON_LINEAR_ACCUM_SPEED = <span class="hljs-number">1</span>/<span class="hljs-number">9</span>;<br>gPlaneDistSensitivity = <span class="hljs-number">0.005</span>;<span class="hljs-comment">// 用于调整几何权重影响，越大表示增大几何权重</span><br>gLobeAngleFraction = <span class="hljs-number">0.15</span>;<span class="hljs-comment">// 用于调整法线权重影响，越大表示增大法线权重</span><br>gRoughnessFraction = <span class="hljs-number">0.15</span>;<span class="hljs-comment">// 用于调整粗糙度权重影响，越大表示增大粗糙度权重</span><br>fractionScale = REBLUR_PRE_BLUR_FRACTION_SCALE = <span class="hljs-number">2.0</span>;<br></code></pre></td></tr></table></figure><p>这里的各种权重设计都是基于平常见到的权重之上，再增加一个调控参数设计。对于每项权重，实现上先计算好其所需参数，再最后计算得到权重，这样实现更能够利用MAD指令。最后每项权重都会乘上各自的调控参数，权重具体形式为 <em>调控参数(a) X 平面距离(\法线夹角\粗糙度差异)</em>，细节可查看 <a href="#6.3.2">6.3.2</a> 小节。</p><h3 id="6-1-1-基于平面距离"><a href="#6-1-1-基于平面距离" class="headerlink" title="6.1.1 基于平面距离"></a>6.1.1 基于平面距离</h3><p><code>float2 geometryWeightParams</code> ：用于计算基于平面距离的权重</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">float2 <span class="hljs-title">GetGeometryWeightParams</span><span class="hljs-params">(<span class="hljs-type">float</span> planeDistSensitivity, <span class="hljs-type">float</span> frustumSize, float3 Xv, float3 Nv, </span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-type">float</span> nonLinearAccumSpeed)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> relaxation = <span class="hljs-built_in">lerp</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.25</span>, nonLinearAccumSpeed);<br>    <span class="hljs-type">float</span> a = relaxation / (planeDistSensitivity * frustumSize);<br>    <span class="hljs-type">float</span> b = -<span class="hljs-built_in">dot</span>(Nv, Xv) * a;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">float2</span>(a, b);<br>&#125;<br></code></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>a_g &amp;&#x3D; \frac{lerp(1.0, \space 0.25,\space 1&#x2F;9)}{g_{sensitivity} * frustumSize}\<br>g_{params} &amp;&#x3D; \begin{pmatrix}a_g, &amp; -a_g \cdot (N_v \cdot X_v)\end{pmatrix}<br>\end{align}<br>\tag{1}\label{geometry-weight-params}<br>$$</p><h3 id="6-1-2-基于法线夹角"><a href="#6-1-2-基于法线夹角" class="headerlink" title="6.1.2 基于法线夹角"></a>6.1.2 基于法线夹角</h3><p><code>float normalWeightParams</code> ：用于计算基于法线夹角的权重。</p><p>从下式可以看出，这里的设计从specular对法线朝向的敏感度出发，specular lobe angle越小，权重对法线夹角越敏感。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> lobeAngleFractionScale = gLobeAngleFraction * fractionScale;<span class="hljs-comment">// fraction 参数</span><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GetNormalWeightParams</span><span class="hljs-params">(<span class="hljs-type">float</span> nonLinearAccumSpeed, <span class="hljs-type">float</span> fraction, <span class="hljs-type">float</span> roughness = <span class="hljs-number">1.0</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> angle = STL::ImportanceSampling::<span class="hljs-built_in">GetSpecularLobeHalfAngle</span>(roughness);<br>    angle *= <span class="hljs-built_in">lerp</span>(<span class="hljs-built_in">saturate</span>(fraction), <span class="hljs-number">1.0</span>, nonLinearAccumSpeed); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> use as &quot;percentOfVolume&quot; instead?</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / <span class="hljs-built_in">max</span>(angle, REBLUR_NORMAL_ULP);<span class="hljs-comment">// REBLUR_NORMAL_ULP (2.0 / 255.0)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>a_n &amp;&#x3D; 1.0 &#x2F; \Big( halfAngle * lerp(g_{lobeAngleF} * 2.0,\space 1.0,\space 1&#x2F;9) \Big)\<br>n_{params} &amp;&#x3D; a_n<br>\end{align}<br>\tag{2}\label{normal-weight-params}<br>$$</p><h3 id="6-1-3-基于反射距离差异"><a href="#6-1-3-基于反射距离差异" class="headerlink" title="6.1.3 基于反射距离差异"></a>6.1.3 基于反射距离差异</h3><p><code>float2 hitDistanceWeightParams</code> ：基于反射距离差异的权重</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">float2 <span class="hljs-title function_">GetHitDistanceWeightParams</span><span class="hljs-params">(<span class="hljs-type">float</span> hitDist, <span class="hljs-type">float</span> nonLinearAccumSpeed, <span class="hljs-type">float</span> roughness = <span class="hljs-number">1.0</span>)</span><br>&#123;<br>    <span class="hljs-comment">// IMPORTANT: since this weight is exponential, 3% can lead to leaks from bright objects in reflections.</span><br>    <span class="hljs-comment">// Even 1% is not enough in some cases, but using a lower value makes things even more fragile</span><br>    <span class="hljs-type">float</span> smc = GetSpecMagicCurve2(roughness);<br>    <span class="hljs-type">float</span> norm = lerp(NRD_EPS, <span class="hljs-number">1.0</span>, min(nonLinearAccumSpeed, smc));<span class="hljs-comment">// NRD_EPS 1e-6</span><br>    <span class="hljs-type">float</span> a = <span class="hljs-number">1.0</span> / norm;<br>    <span class="hljs-type">float</span> b = hitDist * a;<br>    <span class="hljs-keyword">return</span> float2(a, -b);<br>&#125;<br></code></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>a_h &amp;&#x3D; 1.0 &#x2F; \Big( lerp(1\times 10^{-6}, \space 1.0, \space \min(1&#x2F;9, smc) \Big)\<br>h_{params} &amp;&#x3D; \begin{pmatrix} a_h, &amp; -a_h\cdot hitDist \end{pmatrix}<br>\end{align}<br>\tag{3}\label{hit-weight-params}<br>$$</p><p>根据 $\eqref{hit-weight}$ 可知，超参 $a_h$ 越大，基于反射距离的权重越小</p><h3 id="6-1-4-基于roughness差异"><a href="#6-1-4-基于roughness差异" class="headerlink" title="6.1.4 基于roughness差异"></a>6.1.4 基于roughness差异</h3><p><code>float2 roughnessWeightParams</code> ：用于计算基于roughness差异的计算</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> roughnessFractionScale = gRoughnessFraction * fractionScale;<span class="hljs-comment">// fraction 参数</span><br>float2 <span class="hljs-title function_">GetRoughnessWeightParams</span><span class="hljs-params">(<span class="hljs-type">float</span> roughness, <span class="hljs-type">float</span> fraction)</span><br>&#123;<br>    <span class="hljs-type">float</span> a = rcp(lerp(<span class="hljs-number">0.01</span>, <span class="hljs-number">1.0</span>, saturate(roughness * fraction)));<br>    <span class="hljs-type">float</span> b = roughness * a;<br>    <span class="hljs-keyword">return</span> float2(a, -b);<br>&#125;<br></code></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>a_r &amp;&#x3D; 1.0 &#x2F; \Big(lerp(0.01, \space 1.0,\space roughness * g_{roughness} * 2.0)\Big)\<br>r_{params} &amp;&#x3D; \begin{pmatrix} a_r, &amp; -a_r \cdot roughness \end{pmatrix}<br>\end{align}  \tag{4}\label{roughness-weight-params}<br>$$</p><h2 id="6-2-Sampling-Space"><a href="#6-2-Sampling-Space" class="headerlink" title="6.2 Sampling Space"></a>6.2 Sampling Space</h2><ol><li><p>TB坐标系轴</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">float2x3 TvBv = GetKernelBasis(Dv.xyz, Nv, NoD, roughness, specNonLinearAccumSpeed);<br></code></pre></td></tr></table></figure></li><li><p>blurRadius 转为世界空间下的 worldRadius，对TB进行缩放 <code>TvBv[0] *= worldRadius; TvBv[1] *= worldRadius;</code></p></li></ol><h2 id="6-3-Poisson-Sampling"><a href="#6-3-Poisson-Sampling" class="headerlink" title="6.3 Poisson Sampling"></a>6.3 Poisson Sampling</h2><h3 id="6-3-1-采样样本"><a href="#6-3-1-采样样本" class="headerlink" title="6.3.1 采样样本"></a>6.3.1 采样样本</h3><ol><li><p>当前样本的 uv 偏移量：泊松样本生成二维向量，再乘上 blurRadius * texelSize</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">float2 uv = pixelUv + STL::Geometry::RotateVector( rotator, offset.xy ) * gInvScreenSize * blurRadius;<br></code></pre></td></tr></table></figure><p><code>offset</code>：(x, y) 是单位圆盘内的点坐标，z 是点距圆心的距离</p></li><li><p>如果是checkboard模式（gSpecCheckerboard !&#x3D; 2），当前采样样本是否有有效数据，如果没有则向左或向右偏移一个，表示取相邻像素数据</p></li><li><p>采样当前样本的 viewZ 与 spec，以及得到当前样本在view space的坐标 Xvs</p></li></ol><h3 id="6-3-2-样本权重"><a href="#6-3-2-样本权重" class="headerlink" title="6.3.2 样本权重 "></a>6.3.2 样本权重 <a name="6.3.2"></a></h3><p>计算当前样本的权重，为下面几项的乘积</p><ul><li><p>比较当前样本与像素的材质ID，材质ID不同，返回权重 0，相同返回 1。</p></li><li><p>gaussian权重：当前样本在单位泊松盘中距圆心的距离 offset.z，代入权重<code>exp(-0.66 * r * r)</code></p></li><li><p>使用计算好的权重参数计算 combinded weight：包括基于平面距离的权重、基于法线夹角的权重、基于粗糙度差异的权重，三项乘积</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> <span class="hljs-title function_">GetCombinedWeight</span><span class="hljs-params">(</span><br><span class="hljs-params">    float2 geometryWeightParams, float3 Nv, float3 Xvs,</span><br><span class="hljs-params">    <span class="hljs-type">float</span> normalWeightParams, float3 N, float4 Ns,<span class="hljs-comment">// Ns = (sample normal, sample roughness), N 当前像素的世界空间法线</span></span><br><span class="hljs-params">    float2 roughnessWeightParams = <span class="hljs-number">0</span></span><br><span class="hljs-params">)</span> &#123;<br>    float3 a = float3(geometryWeightParams.x, normalWeightParams, roughnessWeightParams.x);<br>    float3 b = float3(geometryWeightParams.y, <span class="hljs-number">0.0</span>, roughnessWeightParams.y);<br><br>    float3 t;<br>    t.x = dot(Nv, Xvs);<br>    t.y = STL::Math::AcosApprox(saturate(dot(N, Ns.xyz)));<br>    t.z = Ns.w;<br><br>    float3 w = _ComputeWeight(t, a, b);<br>    <span class="hljs-keyword">return</span> w.x * w.y * w.z;<br>&#125;<br><span class="hljs-comment">// _ComputeWeight</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _ComputeNonExponentialWeight(x, px, py) \</span><br><span class="hljs-meta">    STL::Math::SmoothStep(0.999, 0.001, abs((x) * (px) + (py)))</span><br></code></pre></td></tr></table></figure><p>根据 $\eqref{geometry-weight-params}$、$\eqref{normal-weight-params}$、$\eqref{roughness-weight-params}$ 可简化上述代码<br>$$<br>\begin{align}<br>a &amp;&#x3D; \begin{pmatrix} a_g, &amp; a_n, &amp; a_r \end{pmatrix} \<br>b &amp;&#x3D; \begin{pmatrix} -a_g \cdot (N_v \cdot X_v), &amp; 0, &amp; -a_r\cdot roughness \end{pmatrix} \<br>t &amp;&#x3D; \begin{pmatrix} N_v \cdot X_{vs}, &amp; \arccos(N\cdot N_s), &amp; r_s\end{pmatrix} \<br>X &#x3D; t * a + b &amp;&#x3D; \begin{pmatrix} a_g \cdot (N_v \cdot X_{vs} - N_v\cdot X_v), &amp;a_n \cdot \arccos(N\cdot N_s), &amp;a_r\cdot (r_s - roughness)\end{pmatrix}<br>\end{align} \tag{5} \label{combined-weight}<br>$$<br>STL::Math::SmoothStep 的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _SmoothStep01(x) (x * x * (3.0 - 2.0 * x))<span class="hljs-comment">// 相比y=x，在0，1两端更平缓</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _LinearStep(a, b, x) saturate((x - a) / (b - a))</span><br>float3 <span class="hljs-title function_">SmoothStep01</span><span class="hljs-params">(float3 x)</span> &#123; <span class="hljs-keyword">return</span> _SmoothStep01(saturate(x)); &#125;<br>float3 <span class="hljs-title function_">SmoothStep</span><span class="hljs-params">(float3 a, float3 b, float3 x)</span> &#123; x = _LinearStep(a, b, x); <span class="hljs-keyword">return</span> _SmoothStep01(x); &#125;<br></code></pre></td></tr></table></figure><p>$$<br>\begin{align}<br>x &amp;&#x3D; saturate\left(\frac{x-a}{b-a}\right) \<br>w &amp;&#x3D;_SmoothStep01(x) &#x3D; x^2 \cdot (3 - 2x)<br>\end{align}<br>$$</p><p>_LinearStep 中 a&lt;b，则得到的是反比关系。因此 $X$ 由 0.001 ~ 0.999 递增，w 由 1 到 0递减。当 $X&lt;&#x3D;0.001$ 时，w &#x3D; 1；当 $X &gt;&#x3D; 0.999$ 时，w &#x3D; 0</p><p>_SmoothStep01 得到的是在0，1两端更平缓的效果，图像如下所示</p><img src="/images/Rendering Blogs/Graphics Algorithm/2. Reblur解析.assets/image-20230820201305538.png" alt="image-20230820201305538" style="zoom: 50%;"><p>$\eqref{combined-weight}$ 式计算的每项权重的意义：</p><ul><li><p>$a_g \cdot (N_v \cdot X_{vs} - N_v\cdot X_v)$ ：小括号里是样本到当前像素平面的距离，基于平面距离的几何权重，距离越小对应权重越大</p></li><li><p>$a_n \cdot \arccos(N\cdot N_s)$：样本法线与当前像素法线的夹角，夹角越小对应权重越大</p></li><li><p>$a_r\cdot (r_s - roughness)$：样本粗糙度与当前像素粗糙度的差值（后面有取绝对值），差值越小对应权重越大</p></li></ul><p>因此这些权重的设计都是基于平常所见到的设计，但在此之上还有复杂超参设计，即 $a_g,a_n,a_r$</p></li><li><p>基于反射距离的权重：使用一个最小权重到1.0之间的插值，<code>lerp(minHitDistWeight, 1.0, ...)</code></p><ul><li><p>最小权重：<code>float minHitDistWeight</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> minHitDistWeight = REBLUR_HIT_DIST_MIN_WEIGHT * fractionScale;<span class="hljs-comment">// REBLUR_HIT_DIST_MIN_WEIGHT 0.1</span><br></code></pre></td></tr></table></figure></li><li><p>基于反射距离差异的权重作为插值权重</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _ComputeExponentialWeight(x, px, py) \</span><br><span class="hljs-meta">    ExpApprox(-NRD_EXP_WEIGHT_DEFAULT_SCALE * abs((x) * (px) + (py)))<span class="hljs-comment">// NRD_EXP_WEIGHT_DEFAULT_SCALE 3.0</span></span><br><span class="hljs-type">float</span> <span class="hljs-title function_">GetHitDistanceWeight</span><span class="hljs-params">(float2 params, <span class="hljs-type">float</span> hitDist)</span><span class="hljs-comment">// 样本的反射距离</span><br>&#123;<br>    <span class="hljs-keyword">return</span> _ComputeExponentialWeight(hitDist, params.x, params.y);<br>&#125;<br></code></pre></td></tr></table></figure><p>代入 $\eqref{hit-weight-params}$ 定义的 params，有<br>$$<br>\exp\Big(-3 \cdot abs(s_{hitDist} \cdot a_h - a_h \cdot hitDist)\Big) &#x3D; \exp\Big(-3 \cdot abs\big(a_h\cdot (s_{hitDist}-hitDist)\big)\Big) \tag{6} \label{hit-weight}<br>$$</p></li></ul></li><li><p>处理样本距反射物距离影响，距离越近，反射越shaper。但为什么roughness越大，权重越大:question::confused:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> d = length(Xvs - Xv); <span class="hljs-comment">// 当前样本到像素的距离</span><br><span class="hljs-type">float</span> h = ExtractHitDist(s) * hitDistScale; <span class="hljs-comment">// roughness weight will handle the rest，当前样本的反射距离</span><br><span class="hljs-type">float</span> t = h / (hitDist + d);<span class="hljs-comment">// hitDist 为当前像素的反射距离</span><br>w *= lerp(saturate(t), <span class="hljs-number">1.0</span>, STL::Math::LinearStep(<span class="hljs-number">0.5</span>, <span class="hljs-number">1.0</span>, roughness));<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-3-3-样本speular的加权平均"><a href="#6-3-3-样本speular的加权平均" class="headerlink" title="6.3.3 样本speular的加权平均"></a>6.3.3 样本speular的加权平均</h3><p>如果checkboard模式最终带来无效数据，则使用当前像素的左右相邻像素、进行bilateral filter</p><h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><h2 id="1-GGX-Dominant-Direction"><a href="#1-GGX-Dominant-Direction" class="headerlink" title="1 GGX Dominant Direction"></a>1 GGX Dominant Direction</h2><p>Off-Specular 现象：通常都认为 BRDF lobe 是以镜面反射方向为中心，但由于光源方向与 shadow-masking 项，在 roughness 增大时，BRDF lobe 会朝着法线方向偏移，称为 Off-specular peak。如下图所示  <a href="#%5B1%5D">[1]</a>(page 69)</p><img src="/images/Rendering Blogs/Graphics Algorithm/2. Reblur解析.assets/image-20230820113637853.png" alt="image-20230820113637853" style="zoom: 80%;"><p>为了模拟这种变化，引入一个参数 lerpFactor 来得到法线到镜面反射方向之间的dominant direction，即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">lerp(N, R, lerpFactor);<br></code></pre></td></tr></table></figure><p>这个 lerpFactor 使用 roughness、NoV来建模。在reblur的实现中， <code>float4 GetSpecularDominantDirection</code> 返回 (dominant direction, lerpFactor)</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a name="[1]">[1]</a> <a href="https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf">https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf</a>  </p>]]></content>
    
    
    <categories>
      
      <category>Rendering Blogs</category>
      
      <category>Graphics Alogrithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Screen Space Ray Reflection</title>
    <link href="/2023/09/20/Rendering%20Blogs/Graphics%20Algorithm/1.%20Hierarchy%20Ray%20March/"/>
    <url>/2023/09/20/Rendering%20Blogs/Graphics%20Algorithm/1.%20Hierarchy%20Ray%20March/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Summary"><a href="#1-Summary" class="headerlink" title="1 Summary"></a>1 Summary</h1><p>本文介绍屏幕空间反射中最重要的一步——基于 hierarchy depth buffer(HZB) 的 ray march算法，主要参考了 <a href="#%5B1%5D">[1]</a> 中的实现。</p><p>ray march算法的目的是为了根据屏幕空间深度得到光线在屏幕上的交点，相比于世界空间的光追，这是一种开销很低但仅局限于屏幕空间的做法，也就是若光线交于相机看不到的表面，那么屏幕空间ray march则无法得到求交结果。而 hierarchy depth buffer 则提供了四叉树的加速结构，每一级mipmap都取上一级四个深度中的closest depth。假如光线在 closest depth 的表面之上（距相机更近），那么表示光线不会与更精细层级相交，因此可以快速行进离开不会相交的区域。</p><h1 id="2-hierarchy-depth-buffer"><a href="#2-hierarchy-depth-buffer" class="headerlink" title="2 hierarchy depth buffer"></a>2 hierarchy depth buffer</h1><p>hierarchy depth buffer(HZB) 是构建depth buffer的mipmap形式，但与API接口提供的mipmap构建方式（取均值）不同，hierarchy ray march需要每一层级取前一层级四个深度中的closest depth，具体取最小或最大由depth实现决定。本文采用 $[0,1]$ 的depth，越大距相机越远，因此取最小深度。</p><h1 id="3-Construct-Ray"><a href="#3-Construct-Ray" class="headerlink" title="3 Construct Ray"></a>3 Construct Ray</h1><p>对于屏幕空间，往往已知着色点像素坐标 <code>fragCoord</code>，以及基于需要采样的光线方向 <code>rayDir</code> （位于世界&#x2F;相机空间，本文采样相机空间）。ray march 过程在屏幕空间进行，同时为了方便在不同mip层级行进，需要得到screen uv space(即 $[0,1]\times [0,1]\times [0,1]$)下的光线起点，以及屏幕空间的光线方向。</p><p>构建光线：</p><ul><li>光线起点<code>origin</code>：着色点<code>(fragCoord, depth)</code> 变换到 view space 得到 <code>viewRayPos</code>，变换到 screen uv space 得到光线起点 <code>origin</code></li><li>光线方向<code>direction</code>：view space下沿光线方向行进一个单位得到 <code>nextRayPos = viewRayPos + rayDir</code>，变换到 screen uv space 得到 <code>nextRayScreenPos</code>。光线在屏幕空间的单位方向为 <code>direction = nextRayScreenPos - origin</code>，注意不需要normalize，因为这并不是三维空间的方向。</li></ul><h1 id="4-Ray-March"><a href="#4-Ray-March" class="headerlink" title="4 Ray March"></a>4 Ray March</h1><p>给定光线起点 <code>origin</code> 与光线方向 <code>direction</code>，都位于 screen uv space。在光线行进过程中，会反复执行一下步骤：</p><ul><li>先行进 linear step，即在当前层级行进一个像素。</li><li>执行基于深度的求交判断，有：<ul><li><p>如果光线从当前像素在表面上（更靠近相机）掠过，表示无交点，那么去更高层级（表示更大步长）。</p></li><li><p>如果光线与当前像素相交，表示可能相交，那么去更低层级（表示更小步长）</p></li></ul></li></ul><h2 id="4-1-Linear-March"><a href="#4-1-Linear-March" class="headerlink" title="4.1 Linear March"></a>4.1 Linear March</h2><p>行进一个步长是希望沿着光线方向行进到下一个像素，同时下个像素内执行一个偏移，如图 <a href="#Fig-1">Fig-1</a> 所示。</p><p><a name="Fig-1"></a></p><img src="/images/Rendering Blogs/Graphics Algorithm/1. Hierarchy Ray March.assets/image-20230812143337171.png" alt="image-20230812143337171" style="zoom: 45%;"><center>Fig-1 一次Linear March的示意图</center><p>行进步长 <code>marchStep</code> 可设置为</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec2</span> marchStep = <span class="hljs-built_in">mix</span>(<span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>), <span class="hljs-type">vec2</span>(<span class="hljs-number">1.0</span>), <span class="hljs-built_in">greaterThanEqual</span>(direction.xy, <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>)));<br></code></pre></td></tr></table></figure><p>像素内部偏移量 <code>uvOffset</code> 以像素大小为单位，可设置为</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec2</span> uvOffset = <span class="hljs-number">0.005</span> * <span class="hljs-built_in">exp2</span>(baseLevel) * (<span class="hljs-number">1.0</span> / screenResolution);<span class="hljs-comment">// baseLevel 表示 ray march 执行的最低层级</span><br>uvOffset = <span class="hljs-built_in">mix</span>(-uvOffset, uvOffset, <span class="hljs-built_in">greaterThanEqual</span>(direction.xy, <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>)));<br></code></pre></td></tr></table></figure><p>假设当前光线位置 <code>currentRayCoord</code> 以及当前层级分辨率 <code>currentMipResolution</code>，linear march的执行如下</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec2</span> LinearMarch(<span class="hljs-type">vec2</span> currentRayCoord, <span class="hljs-type">vec2</span> currentMipResolutionInv)<span class="hljs-comment">// currentMipResolutionInv 为倒数</span><br>&#123;<br>    <span class="hljs-type">vec2</span> newRayCoord = <span class="hljs-built_in">floor</span>(currentRayCoord) + marchStep;<br>newRayUV = newRayCoord * currentMipResolutionInv + uvOffset;<br>    <span class="hljs-keyword">return</span> newRayUV;<br>&#125;<br></code></pre></td></tr></table></figure><p>在进行求交之前，光线需要先行进一步，避免与自身所在像素自相交，行进到下一个像素的boundary plane处，有</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">void</span> InitRay(<span class="hljs-type">vec3</span> origin, <span class="hljs-type">vec3</span> direction, <span class="hljs-type">vec3</span> directionInv, <span class="hljs-type">vec2</span> currentRayCoord, <br><span class="hljs-type">vec2</span> currentMipResolutionInv，<span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> position, <span class="hljs-keyword">out</span> <span class="hljs-type">float</span> t)<br>&#123;<br>    <span class="hljs-type">vec2</span> xyPlane = LinearMarch(currentRayCoord, currentMipResolutionInv);<br>    <span class="hljs-comment">// o + d * t = p&#x27; =&gt; t = (p&#x27; - o) * (1 / d)</span><br>    <span class="hljs-type">vec2</span> tXy = xyPlane * directionInv.xy - origin.xy * directionInv.xy;<br>    t = <span class="hljs-built_in">min</span>(tXy.x, tXy.y);<br>    position = origin + t * direction;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-Intersection"><a href="#4-2-Intersection" class="headerlink" title="4.2 Intersection"></a>4.2 Intersection</h2><p>每次迭代都需要进行判断是否与将要行进到的像素有交点，以此来决定下一步应该如何执行。如何判断光线与将要行进像素是否相交？</p><p>假设光线当前位置为 positton，将要行进位置为 new position，如图 <a href="#Fig-1">Fig-1</a> 所示。new position 处的 (x, y, surfaceZ) (surfaceZ为该处像素的深度) 形成了一个bounding box的一半，即相邻的三个面组成的boundary，可以看到 <a href="#Fig-1">Fig-1</a> 中，俯视近平面所展示的 x&#x2F;y plane 形成的黄色 boundary plane。从侧面看近平面如图 <a href="#Fig-2">Fig-2</a> 所示，相机位于上方，两条黄色 boundary line交点处即为 new position。</p><p><a name="Fig-2"></a></p><img src="/images/Rendering Blogs/Graphics Algorithm/1. Hierarchy Ray March.assets/image-20230812194326749.png" alt="image-20230812194326749" style="zoom: 45%;"><center>Fig-2 从侧面看近平面</center><p>对于一个像素而言，其内部深度都是相同的，光线是否会与即将行进的像素相交，通过查看两个端点 position与new position即可：</p><ul><li>光线当前位置 position 与表面的关系有：position.z &lt; surfaceZ，光线在表面之上；否则，光线在表面之下，可能与像素相交</li><li>求光线与new position形成的boundary plane (x, y, surfaceZ)的最近交点。如果最近交点不在z plane上 (即没有与z plane相交)，则表示光线可以从new position上方 (&lt;newPosition.z) 掠过</li></ul><p>因此，对于光线当前位置 position 的两种情况而言：</p><ul><li>position.z &lt; surfaceZ：光线在表面之上，不会与position所在像素相交。再来检查与new position的情况<ul><li>a. 光线与new position的 z plane 相交，表示光线与下一个像素相交</li><li>b. 否则，即与new position的 x&#x2F;y plane 相交，表示光线与下一个像素也不相交</li></ul></li><li>c. 否则，光线在表面之下，与position所在像素相交</li></ul><p>为了能够使用 hierarchy depth buffer 加快速度，应该有：</p><ul><li><p>如果本次迭代的行进有可能相交，则去更细粒度层级，即使用更小行进步长。例如：</p><ul><li>上述情况 a，光线可以行进到new position的 z plane 交点位置；</li><li>上述情况 c，光线位置不变，等待更细粒度层级测试</li></ul></li><li><p>如果不会相交，则去更粗粒度层级，即使用更大行进步长。例如：</p><ul><li>上述情况 b，光线可以行进到new position的 x&#x2F;y plane 的交点位置。</li></ul></li></ul><p>上述迭代一直进行到没有更细粒度层级可用时，表示已找到可能交点；否则，达到迭代次数上限后，表示无法找到交点。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// surfaceZ: depth at currentRayCoord.xy</span><br><span class="hljs-type">bool</span> AdvanceRay(<span class="hljs-type">vec3</span> origin, <span class="hljs-type">vec3</span> direction, <span class="hljs-type">vec2</span> currentRayCoord, <span class="hljs-type">float</span> surfaceZ. <span class="hljs-type">vec2</span> currentMipResolutionInv, <br><span class="hljs-keyword">inout</span> <span class="hljs-type">vec3</span> position, <span class="hljs-keyword">inout</span> <span class="hljs-type">float</span> t)<br>&#123;<br>    <span class="hljs-comment">// new position 处的 boundary plane</span><br><span class="hljs-type">vec2</span> xyPlane = LinearMarch(currentRayCoord, currentMipResolutionInv);<br><span class="hljs-type">vec3</span> boundaryPlane = <span class="hljs-type">vec3</span>(xyPlane, surfaceZ);<br><span class="hljs-comment">// o + d * t = p&#x27; =&gt; t = (p&#x27; - o) * (1 / d)</span><br><span class="hljs-type">vec3</span> tXyz = boundaryPlane * directionInv - origin * directionInv;<br>    <span class="hljs-comment">// Special case: Prevent using z plane when shooting out of the depth buffer.</span><br>    tXyz.z = direction.z &gt; <span class="hljs-number">0</span> ? tXyz.z : SSR_FLOAT_MAX;<br><span class="hljs-type">float</span> tMin = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(tXyz.x, tXyz.y), tXyz.z);<br><span class="hljs-type">bool</span> isAboveSurface = position.z &lt; surfaceZ;<br><span class="hljs-type">bool</span> skipTile = tMin != tXyz.z &amp;&amp; isAboveSurface;<span class="hljs-comment">// 是否为情况 b</span><br>t = isAboveSurface ? tMin : t;<br>position = origin + t * direction;<br>    <span class="hljs-keyword">return</span> skipTile;<br>&#125;<br></code></pre></td></tr></table></figure><p>每次迭代后，调整层级</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">bool</span> skipTile = AdvanceRay(...);<br>currentLevel += skipTile ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>currentMipResolution *= skipTile ? <span class="hljs-number">0.5</span> : <span class="hljs-number">2.0</span>;<br>currentMipResolutionInv *= skipTile ? <span class="hljs-number">2.0</span> : <span class="hljs-number">0.5</span>;<br></code></pre></td></tr></table></figure><h3 id="4-2-1-特殊情况-confused-question"><a href="#4-2-1-特殊情况-confused-question" class="headerlink" title="4.2.1 特殊情况 :confused: :question:"></a>4.2.1 特殊情况 :confused: :question:</h3><p>上面描述都是以光线方向背离相机为例，当光线方向朝向相机时，需要特殊注意：</p><ul><li>position.z &gt;&#x3D; surfaceZ：与前述过程没有不同</li><li>position.z &lt; surfaceZ：此时不能使用 z plane 的交点，因为得到的</li></ul><h3 id="4-2-2-线性查找"><a href="#4-2-2-线性查找" class="headerlink" title="4.2.2 线性查找"></a>4.2.2 线性查找</h3><p>前面讲到，迭代到没有更细粒度层级时，表示找到交点，退出迭代。但如果是超出最大层级时呢？一种做法是，可以看作无法找到交点，但如果想要查找更充分，此时可以降为在最大层级线性查找过程，迭代后层级调整实现修改如下</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">bool</span> skipTile = AdvanceRay(...);<span class="hljs-comment">// 返回当前行进tile内是否可能存在交点, true 表示不存在，直接跳出tile，否则继续tile内的精细层</span><br><span class="hljs-type">int</span> prevLevel = currentLevel;<br>currentLevel += skipTile ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>currentLevel = <span class="hljs-built_in">min</span>(currentLevel, LevelCount - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (currentLevel != prevLevel) &#123;<span class="hljs-comment">// 只有层级发生改变时</span><br>    currentMipResolution *= skipTile ? <span class="hljs-number">0.5</span> : <span class="hljs-number">2.0</span>;<br>currentMipResolutionInv *= skipTile ? <span class="hljs-number">2.0</span> : <span class="hljs-number">0.5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-3-交点是否有效"><a href="#4-2-3-交点是否有效" class="headerlink" title="4.2.3 交点是否有效"></a>4.2.3 交点是否有效</h3><p>前述讲的求交测试都是基于深度信息进行的，如果光线走到了像素背后，则表示相交。但实际上，像素占据了表面一定面积，而该小部分表面并非与近平面平行或者并非是平坦的，因此所在表面存在一定厚度，有可能光线从表面背后穿过去，只有在像素厚度范围内的光线，才算是相交。因此，在得到交点后，还需要进行验证是否有效。</p><p>提取交点 <code>position</code> 处的深度值 <code>surfaceZ</code>，分别将 <code>position.z</code>与<code>surfaceZ</code> 变换到线性空间（相机&#x2F;世界空间），得到 <code>rayDepth</code> 与 <code>hitDepth</code>，有</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">bool</span> TestThickness(<span class="hljs-type">float</span> rayZ, <span class="hljs-type">float</span> hitZ)<br>&#123;<br>    <span class="hljs-type">float</span> rayDepth = Linearize(rayZ);<br>    <span class="hljs-type">float</span> hitDepth = Linearize(hitZ);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(rayDepth - hitDepth) &lt; (relativeThickness * <span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>(hitDepth), <span class="hljs-number">1e-5</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-Put-All-Together"><a href="#4-3-Put-All-Together" class="headerlink" title="4.3 Put All Together"></a>4.3 Put All Together</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec3</span> HierarchyRayMarch(<span class="hljs-type">vec3</span> origin, <span class="hljs-type">vec3</span> direction, <span class="hljs-type">int</span> maxIteration, <br><span class="hljs-type">float</span> relativeThickness, <span class="hljs-keyword">out</span> <span class="hljs-type">bool</span> isValidHit)<br>&#123;<br>    <span class="hljs-comment">// 一些参数初始化</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-type">vec3</span> directionInv = <span class="hljs-number">1.0</span> / direction;<br>    <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> baseLevel = <span class="hljs-number">0</span>;     <span class="hljs-comment">// 0 means full resolution depth</span><br>    <span class="hljs-type">int</span> currentLevel = baseLevel;<br>    <span class="hljs-type">vec2</span> currentMipResolution = GetMipResolution(screenResolution, currentLevel);<br>    <span class="hljs-type">vec2</span> currentMipResolutionInv = <span class="hljs-number">1.0</span> / currentMipResolution;<br>    <span class="hljs-comment">// 设置 Linear March 步长</span><br>    <span class="hljs-type">vec2</span> marchStep = <span class="hljs-built_in">mix</span>(<span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>), <span class="hljs-type">vec2</span>(<span class="hljs-number">1.0</span>), <span class="hljs-built_in">greaterThanEqual</span>(direction.xy, <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>)));<br>    <span class="hljs-type">vec2</span> uvOffset = <span class="hljs-number">0.005</span> * <span class="hljs-built_in">exp2</span>(baseLevel) * (<span class="hljs-number">1.0</span> / screenResolution);<span class="hljs-comment">// baseLevel 表示 ray march 执行的最低层级</span><br>uvOffset = <span class="hljs-built_in">mix</span>(-uvOffset, uvOffset, <span class="hljs-built_in">greaterThanEqual</span>(direction.xy, <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>)));<br>    <span class="hljs-type">vec3</span> position;<br>    <span class="hljs-type">float</span> t;<br>    <span class="hljs-comment">// 光线先行进一个单位，避免与自身像素相交</span><br>    InitRay(origin, direction, currentMipResolution * origin.xy, currentMipResolutionInv, position, t);<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; maxIteration &amp;&amp; currentLevel &gt;= baseLevel &amp;&amp; InsideScreen(position.xy)) &#123;<br>        <span class="hljs-type">vec2</span> currentRayCoord = currentMipResolution * position.xy;<br>        <span class="hljs-type">float</span> surfaceZ = <span class="hljs-built_in">texelFetch</span>(hiDepthTexArray[currentLevel], <span class="hljs-type">ivec2</span>(currentRayCoord), <span class="hljs-number">0</span>).r;<br>        <span class="hljs-type">bool</span> skipTile = AdvanceRay(origin, direction, currentRayCoord, surfaceZ, <br>  currentMipResolutionInv, position, t);<br><span class="hljs-type">int</span> prevLevel = currentLevel;<br>currentLevel += skipTile ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>currentLevel = <span class="hljs-built_in">min</span>(currentLevel, LevelCount - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (currentLevel != prevLevel) &#123;<span class="hljs-comment">// 只有层级发生改变时</span><br>    currentMipResolution *= skipTile ? <span class="hljs-number">0.5</span> : <span class="hljs-number">2.0</span>;<br>currentMipResolutionInv *= skipTile ? <span class="hljs-number">2.0</span> : <span class="hljs-number">0.5</span>;<br>&#125;<br>        ++i;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 验证交点是否有效</span><br>    isValidHit = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (currentLevel &lt; baseLevel &amp;&amp; InsideScreen(position.xy)) &#123;<br>        <span class="hljs-type">vec2</span> currentRayCoord = screenResolution * position.xy;<br>        <span class="hljs-type">float</span> hitZ = <span class="hljs-built_in">texelFetch</span>(hiDepthTexArray[<span class="hljs-number">0</span>], <span class="hljs-type">ivec2</span>(currentRayCoord), <span class="hljs-number">0</span>).r;<br>        isValidHit = TestThickness(position.z, hitZ);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> position;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-Reflection"><a href="#5-Reflection" class="headerlink" title="5 Reflection"></a>5 Reflection</h1><p>最后简要介绍下屏幕空间反射的反射部分。屏幕空间反射希望得到金属材质的着色点的反射信息，首先需要在着色点处根据材质信息，重要性采样得到反射光线的方向。以着色点为起点、反射光线的方向组成的光线，在屏幕空间执行ray march，找到的交点即为反射点。接下来，SSR直接将上一帧反射点的颜色（不包含反射）作为反射点向着色点发出的radiance。注意：这是一种简单的近似，并非PBR过程，因为屏幕上的颜色实际上应该是屏幕像素向相机发出的radiance，这里直接近似作为其向着色点的radiance。 </p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a name="[1]">[1]</a> <a href="https://github.com/GPUOpen-Effects/FidelityFX-SSSR">https://github.com/GPUOpen-Effects/FidelityFX-SSSR</a></p>]]></content>
    
    
    <categories>
      
      <category>Rendering Blogs</category>
      
      <category>Graphics Alogrithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scene Graph and Draw Call Grouping Strategy</title>
    <link href="/2023/09/20/Render%20Engine/Scene%20Graph%20and%20Draw%20Call%20Grouping%20Strategy/"/>
    <url>/2023/09/20/Render%20Engine/Scene%20Graph%20and%20Draw%20Call%20Grouping%20Strategy/</url>
    
    <content type="html"><![CDATA[<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>本文介绍了表示场景的 Scene Graph ，以及场景加载过程。基于 Scene Graph 组织 draw call 的策略。</p><h1 id="Scene-Graph"><a href="#Scene-Graph" class="headerlink" title="Scene Graph"></a>Scene Graph</h1><p>Scene Graph 表示场景中物体的层级结构，是场景物体的组织形式。在本渲染器中，Scene Graph 主要由表示层级结构的基类<code>UltraNode</code>与组织场景物体的基类<code>SceneObject</code>组成。</p><h2 id="1-场景层级结构"><a href="#1-场景层级结构" class="headerlink" title="1. 场景层级结构"></a>1. 场景层级结构</h2><p><code>UltraNode</code>的子类<code>SceneNode</code>构建场景中的树形层级结构中的节点。除了表示层级结构，节点主要功能之一是支持变换，其管理的变换信息（旋转、平移、缩放）有：</p><ul><li>相对于父节点坐标系的局部变换，对应成员有<code>mRelativePos</code>、<code>mRelativeRot</code>、<code>mRelativeScale</code></li><li>相对于根节点坐标系的世界变换，对应成员有<code>mStackToRootPos</code>、<code>mStackToRootRot</code>、<code>mStackToRootScale</code> 以及将旋转、平移、缩放组合一起的变换矩阵<code>mStackToRootTransform</code></li></ul><p><strong>变换的更新逻辑</strong>：节点提供变换接口，如 translate、rotate、scale 等，这些接口都提供参数来表示此次变换相对于哪个坐标系，最后都会改变局部变换信息。下面以 rotate 为例说明，假设旋转参数 rot，相对坐标系为 relative：</p><ul><li><p>relative 是局部坐标系：mRelativeRot 是从 local 到 parent 的四元数旋转，因此先在 local space 应用 rot，有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">mRelativeRot *= rot<br></code></pre></td></tr></table></figure></li><li><p>relative 是父节点坐标系：因此先应用 mRelativeRot (local 到 parent)，有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">mRelativeRot = rot * mRelativeRot;<br></code></pre></td></tr></table></figure></li><li><p>relative 是世界坐标系：因此先应用 local 到 world 的变换，再应用 rot，再 world 到 local 的变换，有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">mRelativeRot = mRelativeRot * glm::<span class="hljs-built_in">inverse</span>(localToWorldRot) * rot * localToWorldRot;<br></code></pre></td></tr></table></figure></li></ul><p><strong>世界变换</strong>相关成员的更新在其对应 GetXxx 函数中，如果检测到局部变换发生变化或者父节点局部变换发生变化时进行重新计算。</p><h2 id="2-场景物体的组织"><a href="#2-场景物体的组织" class="headerlink" title="2. 场景物体的组织"></a>2. 场景物体的组织</h2><p><code>SceneObject</code> 的子类组织场景中的物体，如 mesh、光源、相机等。<code>SceneObject</code> 需要将物体 attach 到场景的节点中才会被渲染。目前实现的有组织 mesh 数据的 <code>MeshEntity</code>，表示投影相机的 <code>FrustumObject</code>。</p><p><strong>MeshEntity</strong>：该类构建一个模型数据，由继承自 <code>RenderableInterface</code> 的 <code>PrimitiveEntity</code> 基本单元组成，表示使用一种材质的子 mesh。在场景加载过程中划分成 PrimitiveEntity，在渲染时通过 SceneManager 收集。</p><p><strong>FrustumObject</strong>：相机的父类，一共有 Orthogonal 和 Perspective 两种相机。其包含了投影变换的信息，而相机的旋转、平移、缩放等信息由其 attach 到的场景节点表示，注意相机的 view transform 表示从世界到相机空间的变换，而其 attach 到的节点的世界变换为从 local 到世界的变换，local 即相机空间，因此求逆得到 view transform。相机实现了两种操作方式，ORBIT 与 FPS，在 <code>CameraMovement</code> 类中：</p><ul><li><p>ORBIT：以目标为中心，根据鼠标操作进行旋转，旋转限制 lock-y，即左右旋转时永远绕世界坐标系 y 轴，旋转过程如下，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> dist = <span class="hljs-built_in">GetDistToTarget</span>();<span class="hljs-comment">// 相机离目标距离</span><br><span class="hljs-comment">// 将相机放置目标位置</span><br>mCamera-&gt;<span class="hljs-built_in">GetParentNode</span>()-&gt;<span class="hljs-built_in">SetRelativePosition</span>(mTargetCenter + mOffset);<br><span class="hljs-comment">// 相对于世界坐标系 y 轴旋转</span><br>mCamera-&gt;<span class="hljs-built_in">GetParentNode</span>()-&gt;<span class="hljs-built_in">Yaw</span>(mouseMotion.x * rotSpeed.x, TransformSpace::TRANS_WORLD);<span class="hljs-comment">// y</span><br><span class="hljs-comment">// 相对于局部坐标系 x 轴旋转</span><br>mCamera-&gt;<span class="hljs-built_in">GetParentNode</span>()-&gt;<span class="hljs-built_in">Pitch</span>(mouseMotion.y * rotSpeed.y, TransformSpace::TRANS_LOCAL);<span class="hljs-comment">// x</span><br><span class="hljs-comment">// 平移保持与目标的距离</span><br>mCamera-&gt;<span class="hljs-built_in">GetParentNode</span>()-&gt;<span class="hljs-built_in">Translate</span>(<span class="hljs-built_in">Vector3f</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>) * dist, <br>                           TransformSpace::TRANS_LOCAL);<br></code></pre></td></tr></table></figure></li><li><p>FPS：第一人称视角的运动方式，旋转限制 lock-y</p></li></ul><h2 id="3-场景加载"><a href="#3-场景加载" class="headerlink" title="3. 场景加载"></a>3. 场景加载</h2><p>场景加载由 <code>AssetLoader</code> 的子类完成，基于第三方库 gltf_loader 或 assimp 实现加载接口。场景节点按照层级结构进行创建，并加载其变换信息。节点下的 mesh 数据根据材质种类创建为不同的 <code>PrimitiveEntity</code>，材质的加载包括材质参数的加载以及贴图资源的加载，压缩贴图 DDS 使用 gli 库，其他贴图使用 FreeImage。</p><p>由于还没做好场景 UI 界面，因此临时实现将场景层级信息输出到文件进行查看。打开宏 <code>IS_LOG_HIERARCHY_SCENE</code>，场景的层级节点信息会 log 到文件 “intermediate&#x2F;hierarchy_log.txt”，部分层级如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++">|-vk_root<br>|**[trans: <span class="hljs-comment">// ...变换矩阵省略</span><br>|**[<span class="hljs-built_in">pos</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>), <span class="hljs-built_in">rot</span>(<span class="hljs-number">0</span>,<span class="hljs-number">-0</span>,<span class="hljs-number">0</span>)<br>|<br>|----|-scene_root<br>|    |**[trans: <span class="hljs-comment">// ...变换矩阵省略</span><br>|    |**[<span class="hljs-built_in">pos</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.0128205</span>,<span class="hljs-number">0.0128205</span>,<span class="hljs-number">0.0128205</span>), <span class="hljs-built_in">rot</span>(<span class="hljs-number">-90</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>|    |<br>|    |----|<span class="hljs-number">-5</span>a174a9db4f94280a<span class="hljs-number">298e075478</span>d761a.fbx<br>|         |**[trans: <span class="hljs-comment">// ...变换矩阵省略</span><br>|         |**[<span class="hljs-built_in">pos</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>), <span class="hljs-built_in">rot</span>(<span class="hljs-number">90</span>,<span class="hljs-number">-0</span>,<span class="hljs-number">0</span>)<br>|         |<br>|         |----|-RootNode<br>|              |**[trans: <span class="hljs-comment">// ...变换矩阵省略</span><br>|              |**[<span class="hljs-built_in">pos</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>), <span class="hljs-built_in">rot</span>(<span class="hljs-number">0</span>,<span class="hljs-number">-0</span>,<span class="hljs-number">0</span>)<br>|              |<br>|              |----|-Diorama<br>|                   |**[trans: <span class="hljs-comment">// ...变换矩阵省略</span><br>|                   |**[<span class="hljs-built_in">pos</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>), <span class="hljs-built_in">rot</span>(<span class="hljs-number">0</span>,<span class="hljs-number">-0</span>,<span class="hljs-number">0</span>)<br>|                   |               <br>|                   |----|-Floor_Junk_Cluster_01_Clip2<br>|                        |**[trans: <span class="hljs-comment">// ...变换矩阵省略</span><br>|                        |**[<span class="hljs-built_in">pos</span>(<span class="hljs-number">-3.94234</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8.75777</span>), <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>), <span class="hljs-built_in">rot</span>(<span class="hljs-number">0</span>,<span class="hljs-number">21.1553</span>,<span class="hljs-number">0</span>)<br>|                        |<br>|                        |----|-Floor_Junk_Cluster_01_Clip2_Metal_Aluminium_0<br>|                             |**[trans: <span class="hljs-comment">// ...变换矩阵省略</span><br>|                             |**[<span class="hljs-built_in">pos</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>), <span class="hljs-built_in">rot</span>(<span class="hljs-number">0</span>,<span class="hljs-number">-0</span>,<span class="hljs-number">0</span>)<br>|                              <br>|----|-DefaultCamera<br>     |**[trans: <span class="hljs-comment">// ...变换矩阵省略</span><br>     |**[<span class="hljs-built_in">pos</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>), <span class="hljs-built_in">rot</span>(<span class="hljs-number">0</span>,<span class="hljs-number">-0</span>,<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><strong>Mesh 数据的组织方式</strong>：目前只有静态 mesh，即不会发生变形的 mesh。在加载资源过程中，按照如下方式组织 mesh 数据：</p><ul><li>将所有 mesh 数据加载到连续区域的 buffer 中。目前所有 mesh 共享同一连续区域，之后如果支持动态 mesh 后，可能会根据 mesh 类型划分。</li><li>mesh 的数据结构：不直接包含 mesh 原数据，而是保存其 mesh 数据在 buffer 区域中的位置描述，由 <code>PrimitiveEntity</code> 持有，<ul><li>buffer location: mesh 数据所在 buffer 的起始地址</li><li>offset: mesh 数据在 buffer 中相对于其实地址的偏移量</li><li>size: mesh 数据的大小</li></ul></li></ul><h1 id="Draw-Call-组织策略"><a href="#Draw-Call-组织策略" class="headerlink" title="Draw Call 组织策略"></a>Draw Call 组织策略</h1><p>对于一个复杂场景而言，具有很多种类的材质、mesh，往往需要很大量的 draw call 进行绘制，但 draw call 的固有开销又限制了实时条件下硬件能支持的最大数量。在 Nvidia 有关 Draw Call 优化 <a href="#%5B1%5D">[1]</a> 的演讲中有提到，draw call 会有固有的驱动层的参数验证开销，这在当时是最大的瓶颈，而这种验证开销是由管线状态改变导致的，下面是不同管线状态改变相对开销对比：</p><img src="/images/Render Engine/Scene Graph and Draw Call Grouping Strategy.assets/image-20220716235751202.png" alt="image-20220716235751202" style="zoom: 25%;"><p>可以看出 render target、shader、texture 的开销依次降低，想要支持的 draw call 数量更大，就要减少这些状态改变。其中提高一些策略：</p><ul><li>使用 texture array 可以一次性配置好所有 texture，减少 texture binding 的改变</li><li>使用 SSBO 存储整个场景的 uniform 数据，减少 UBO binding 的改变</li><li>使用 indirect draw，可以一次性下发一批 draw call，让验证一次完成，减少 draw call 的验证开销</li></ul><p>下面介绍上述 draw call 策略的实现</p><h2 id="1-绘制时由-mesh-数据结构到-render-proxy"><a href="#1-绘制时由-mesh-数据结构到-render-proxy" class="headerlink" title="1. 绘制时由 mesh 数据结构到 render proxy"></a>1. 绘制时由 mesh 数据结构到 render proxy</h2><p>绘制不直接接触 mesh 数据结构，而是使用为每个 render object 构建的 render proxy。在初始化场景渲染信息时，遍历场景结点的 render object 创建 render proxy，并加入场景的 render proxy list 中。一个 render object 可能是一个完整的物体，例如车，而车可能包含多个使用不同材质的 mesh。render proxy 对其拥有的所有 mesh 进行组织，根据材质不同，划分出 meshBatch。每个 meshBatch 保持的是 render object 的一种材质的所有 mesh 信息。因此一个 render object 的 render proxy 包含：</p><ul><li>&lt;mat0, meshBatch0&gt;，&lt;mat1, meshBatch1&gt;，… …</li><li>其所属场景节点的 <code>node ID</code></li><li><code>proxyIndex</code>：render proxy 在场景的 render proxy list 的索引位置</li></ul><p>来自相同的场景结点的 render proxy 可以使用同一个 UBO 传递变换矩阵。不同场景结点的 render proxy具有不同的变换，需要使用不同的 UBO。而不同材质又需要不同的材质 UBO、不同的 texture 等等。如果按照最直接的 indexed draw call，不同材质、不同场景结点的 render proxy 必须使用不同的 draw call，这会使得 draw call 数量非常多。</p><h2 id="2-将大量-render-proxy-组织到少量-render-group-中"><a href="#2-将大量-render-proxy-组织到少量-render-group-中" class="headerlink" title="2. 将大量 render proxy 组织到少量 render group 中"></a>2. 将大量 render proxy 组织到少量 render group 中</h2><p>本渲染器使用 <code>MeshMaterialRenderGroup</code> 实现组织 draw call 策略，根据开启的策略，将 render proxy 组织成 render group，一个 render group 即表示了一个 index draw call。下面介绍使用 SSBO、texture array 来从所有的 render proxy 构建出场景的 render group 列表。</p><h3 id="2-1-组织策略"><a href="#2-1-组织策略" class="headerlink" title="2.1 组织策略"></a>2.1 组织策略</h3><p><strong>Scene SSBO</strong>：对于场景节点变换矩阵等节点数据，使用 SSBO 存储场景结点变换数据，存储位置为节点的 node ID。</p><p><strong>Group Mat SSBO</strong>：对于不同材质的参数、贴图，如果材质可以合并（参数种类相同，贴图格式、大小相同），则合并到同一个 render group。使用 SSBO 存储材质的参数，合并多个材质的贴图为 texture array。材质参数在 SSBO 中的位置为material index。每种材质贴图在 texture array 中的位置也需要一个索引。</p><p><strong>Group Instance SSBO</strong>：由于一个场景节点可能会有多个 render proxy，因此还需要使用一个 SSBO 来存储 render proxy 所使用的 node ID 与 material index，分别索引 Scene SSBO与Group Mat SSBO，获取 render proxy 的变换、材质数据。</p><p>最后配置 render group 的 draw call 使得内置变量 <code>gl_InstanceIndex</code> 能够索引 Group Instance SSBO，也就是 render proxy 在场景的 render proxy 列表中的索引。</p><h3 id="2-2-实现-render-group-的组织"><a href="#2-2-实现-render-group-的组织" class="headerlink" title="2.2 实现 render group 的组织"></a>2.2 实现 render group 的组织</h3><p>经过场景中的所有 render proxy 得到很多材质和 meshBatch 的组合，例如 &lt;mat0, meshBatch0&gt;，&lt;mat0, meshBatch1&gt; ，&lt;mat1, meshBatch0&gt;，&lt;mat1, meshBatch2&gt; 等等。依次尝试将每个组合合并到现有 render group 中，如果没有找到可以合并的 render group，则为该组合创建一个新的 render group。对于输入 mat+meshBatch 组合遍历现存的每个 render group，如果同时满足以下条件则可以合并：</p><ul><li>输入 mat+meshBatch 组合的材质种类是否与当前 render group 的材质种类相同，不相同则不可合并。</li><li>输入 mat+meshBatch 组合的材质贴图格式、大小等是否与当前 render group 的材质相同，不相同则不可合并。</li></ul><p>当一个输入 mat+meshBatch 组合可以合并到目标 render group 时，进行合并操作，为目标 render group 生成一个 <code>group instance</code>：</p><ul><li><p>材质信息存入目标 render group 的材质列表中。该材质位于 render group 中的位置作为索引 material index。由于多个材质可能引用同一贴图，贴图在 texture array 中的索引与材质索引可能不同，因此还需要存储不同贴图的索引，如 baseColor 贴图索引、normal map 索引。以及存储材质参数，如 base color 因子等。这些材质数据都存储在 <strong>Group Mat SSBO</strong> 的一个元素中，如下例结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MaterialUniformBufferParams</span><br>&#123;<br>    Vector4f BaseColorFactor;<br>    <span class="hljs-type">float</span> RoughnessFactor;<br>    <span class="hljs-type">float</span> MetallicFactor;<br>    <span class="hljs-type">float</span> OcculusionStrength;<br><br>    <span class="hljs-type">uint32_t</span> BaseColorTexIndex;<br>    <span class="hljs-type">uint32_t</span> OccuRoughMetalTexIndex;<br>    <span class="hljs-type">uint32_t</span> NormalMapIndex;<br>    <span class="hljs-type">uint32_t</span> EmissiveMapIndex;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>meshBatch 信息存入目标 render group。如果已有相同的 meshBatch 则为对应 group instance 增加一个 instance 数据，即输入的 meshBatch 对应的 <code>&#123;node index、material index&#125;</code>。如果不存在相同的 meshBatch，则为输入的 meshBatch 新增一个 group instance。这些信息都存储于 <strong>Group Instance SSBO</strong> 的一个元素中，如下例结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MeshInstanceData</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> NodeIndexInScene;<br>    <span class="hljs-type">uint32_t</span> MatIndex;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>render group 的 group instance 创建完成，组织 draw call 信息，得到有效的 <code>gl_InstanceIndex</code> ，用以索引 <strong>Group Instance SSBO</strong>。初始化 instanceOffset 为 0，按照 meshBatch 在 render group 中的顺序，依次进行：</p><ul><li>当前 meshBatch 的 group instance 的数量作为 instanceCount，当前的 instanceOffset 作为 firstInstance</li><li>instanceOffset &#x3D; instanceOffset+instanceCount</li></ul></li></ul><p>经过以上步骤，可以通过 <code>gl_InstanceIndex</code> 索引 <strong>Group Instance SSBO</strong>，得到当前绘制 mesh 对应的 node index 和 material index。node index 用来索引 <strong>Scene SSBO</strong> 获取当前 mesh 对应的场景 node 数据，如 model to world 变换。material index 用来索引 <strong>Group Mat SSBO</strong> 得到当前 mesh 对应的材质参数，以及材质贴图在 texture array 中的索引。</p><h2 id="3-不同条件下的性能比较"><a href="#3-不同条件下的性能比较" class="headerlink" title="3. 不同条件下的性能比较"></a>3. 不同条件下的性能比较</h2><p>本渲染器目前的场景比较简单：只有静态 mesh，无实时交互，只有单线程，并且场景全部加载。因此直接使用 FPS 进行性能比较。三个相关宏：</p><ul><li><p><code>IS_SHARE_VTX_IDX_BUFFER</code>：是否整个场景公用同一个 index&#x2F;vertex buffer</p></li><li><p><code>IS_USING_MERGE_MATERIAL</code>：是否合并材质，使用 texture array</p></li><li><p><code>IS_USING_INDIRECT_DRAW</code>：是否开启 indirect draw，</p></li></ul><p>测试场景一共创建了 170 个 mesh render proxies。</p><ul><li>关闭所有选项使用最直接的 index draw call：组织为 170 个 render group，每个 render group 需要一次 index draw call，FPS 为 65 左右</li><li>只开启 <code>IS_SHARE_VTX_IDX_BUFFER</code> 使得 170 次 index draw call 都使用同一个 index&#x2F;vertex buffer，FPS 无明显变化</li><li>只开启 <code>IS_USING_MERGE_MATERIAL</code>，将材质可以合并的 mesh 合并为一个 render group，一共得到 6 个 render group。每个 render group 使用一次 index draw call，同时使用一个 index&#x2F;vertex buffer，FPS 提高到 142 左右<ul><li>同时开启 <code>IS_USING_MERGE_MATERIAL</code> 和 <code>IS_SHARE_VTX_IDX_BUFFER</code>，即 6 次 index draw call 共享同一个 index&#x2F;vertex buffer。FPS 无明显改变。</li></ul></li><li>只开启 <code>IS_USING_INDIRECT_DRAW</code>，这时 IS_SHARE_VTX_IDX_BUFFER 也会同时开启。将所有 index draw call 参数存到一个 indirect buffer 中，使用一次 indirect draw 将所有 index draw call 提交。因为没有合并材质，因此共生成 170 个 render group，即 170 个 index draw call，每个 render group 在一个 indirect draw 中提交。FPS 为 68 左右，比最直接的 index draw call 有些许提高。本测试场景瓶颈在材质种类数量，而不在节点数量，因此不合并材质 indirect draw 发挥不了作用 </li><li>同时开启 <code>IS_USING_INDIRECT_DRAW</code> 和 <code>IS_USING_MERGE_MATERIAL</code>，一共生成 6 个 render group，即 6 个 index draw call，在一次 indirect draw 中提交。FPS 为 650 左右，相比于最直接的 index draw call，提升了 10 倍。就算对于仅合并材质的情况，即使用 6 次 index draw call，也有将近 4.5 倍提升。</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a name="[1]">[1]</a> <a href="https://developer.nvidia.com/content/how-modern-opengl-can-radically-reduce-driver-overhead-0">https://developer.nvidia.com/content/how-modern-opengl-can-radically-reduce-driver-overhead-0</a></p>]]></content>
    
    
    <categories>
      
      <category>Render Engine</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vulkan Render Design</title>
    <link href="/2023/09/20/Render%20Engine/Vulkan%20Render%20Design/"/>
    <url>/2023/09/20/Render%20Engine/Vulkan%20Render%20Design/</url>
    
    <content type="html"><![CDATA[<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>本文介绍了本渲染器的 Vulkan 管线管理策略以及 Shader 管理策略。</p><h1 id="Vulkan-管线管理策略"><a href="#Vulkan-管线管理策略" class="headerlink" title="Vulkan 管线管理策略"></a>Vulkan 管线管理策略</h1><p>Vulkan 包含三种管线 graphics、compute、raytracing，管线只是一种状态描述，描述了整个工作流中涉及的状态。人们经常提 OpenGL 是个状态机，OpenGL 的状态是由根据使用者的 API 调用来进行切换的，属于 high-level 的 API 设计。而Vulkan 使用 <strong>PSO(pipeline state object)</strong> 来描述管线状态，类型为 <code>VkPipeline</code>，这个类型的对象需要用户自己创建。</p><p>PSO 只是描述管线的各种状态，状态相同的管线可以使用同一个 PSO，不相容的状态则需要创建新的 PSO。因此对于 PSO 的管理采用将当前状态进行 hash 处理，如果存在当前状态 hash 的 PSO 则直接使用，否则创建新的 PSO 并记录到 unordered_map 中。这部分工作由类 <code>VulkanPipelineStateManager</code> 完成，目前的 hash 算法只是简单的移位与异或，留待之后更改。</p><p>创建 PSO 的 API 有三个，<a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateGraphicsPipelines.html"><code>vkCreateGraphicsPipelines</code></a> 创建 graphics PSO，<a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateComputePipelines.html"><code>vkCreateComputePipelines</code></a> 创建 compute PSO， <a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRayTracingPipelinesKHR.html"><code>vkCreateRayTracingPipelinesKHR</code></a> 创建 raytracing PSO。创建 PSO 需要传入描述管线状态的结构体，管线状态的 hash 也主要对这些结构体中的字段进行。另一个 cache 参数，是允许用户将执行过程中创建的 PSO 保存到文件，然后下次启动加载到 cache 参数中，Vulkan 可以通过 cache 来减少创建过程中需要的底层开销，可以提高运行时帧数的稳定性。</p><p>对于 PSO 的封装有类 <code>VulkanPipeline</code> 及其三个子类 <code>VulkanGraphicsPipelineState</code>、<code>VulkanComputePipeline</code> 以及 <code>VulkanRayTracingPipeline</code>。下面以 graphics PSO 为例，介绍管线的创建流程。</p><h1 id="Graphics-PSO-的创建"><a href="#Graphics-PSO-的创建" class="headerlink" title="Graphics PSO 的创建"></a>Graphics PSO 的创建</h1><h2 id="1-Vulkan-Graphics-Pipeline-介绍"><a href="#1-Vulkan-Graphics-Pipeline-介绍" class="headerlink" title="1. Vulkan Graphics Pipeline 介绍"></a>1. Vulkan Graphics Pipeline 介绍</h2><p>创建 Vulkan Graphics PSO 的描述封装在结构体 <a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGraphicsPipelineCreateInfo.html"><code>VkGraphicsPipelineCreateInfo </code></a> 中，下面简要介绍它的成员：</p><ul><li><code>VkPipelineShaderStageCreateInfo*</code> ：管线使用的 shader 信息数组，每个元素包含使用的 shader 对象(VkShaderModule)、入口函数、shader 阶段(vertex&#x2F;fragment …)等。</li><li><code>VkPipelineVertexInputStateCreateInfo*</code>：每个元素描述顶点包含的输入属性(vertex shader)，即 location、binding、数据格式以及相对于顶点起始位置的偏移量。</li><li><code>VkPipelineInputAssemblyStateCreateInfo</code>：描述图元数据的拓扑结构(VkPrimitiveTopology)，如<br> POINT_LIST、TRIANGLE_LIST 等。</li><li><code>VkPipelineTessellationStateCreateInfo</code>：曲面细分阶段的配置参数，例如控制点数量</li><li><code>VkPipelineViewportStateCreateInfo</code>：用来描述当前渲染的 viewport 和 scissor 的区域，视口和裁剪可能变化较频繁，可以设置为 dynamic state，创建管线时不设置，在渲染前使用 command 动态设置。</li><li><code>VkPipelineRasterizationStateCreateInfo</code>：描述光栅化阶段的配置参数，几何绘制模式(填充&#x2F;线框)，正面的顶点环绕方向，剔除面(正面剔除还是背面剔除)。是否开启 depth bias，对 depth buffer 中的深度加上一个偏移量，可以在避免自遮挡时使用</li><li><code>VkPipelineMultisampleStateCreateInfo</code>：描述光栅化阶段的采样数，1 表示无超采样。</li><li><code>VkPipelineDepthStencilStateCreateInfo</code>：描述是否开启深度测试、模板测试，以及深度测试的操作、模板测试的操作。</li><li><code>VkPipelineColorBlendStateCreateInfo</code>：描述 frame buffer 中每个 render target 的 blend 操作，包含 blend 参数、blend 计算方式等。</li><li><code>VkPipelineDynamicStateCreateInfo</code>：描述管线状态中哪些是可以使用 command 指定的动态状态，其他则是创建管线时就确定的。</li><li><code>VkPipelineLayout</code>：包含管线中着色器的输入资源描述</li><li><code>VkRenderPass</code>：管线所使用的 render pass，包含了 render pass 的 render target 的描述。</li></ul><h3 id="1-1-Vulkan-Render-Pass"><a href="#1-1-Vulkan-Render-Pass" class="headerlink" title="1.1 Vulkan Render Pass"></a>1.1 Vulkan Render Pass</h3><p>Vulkan Render Pass 也是一种描述，因此同样使用 hash 方式进行自动创建，主要包含三部分：</p><ul><li>描述其使用到的所有 attachment 的描述 <code>VkAttachmentDescription</code>，一个 attachment 即为一个 image view，用于访问 vulkan texture。进入 renderpass 之前、renderpass 之内、renderpass 结束时的 image layout；加载与存储时的操作；attachment 格式，采样数。</li><li>描述其内部的 subpass，并且至少包含一个 subpass。每个 subpass 描述包含其 color&#x2F;resolve&#x2F;depth attachment 的引用描述，即 framebuffer 中 attachment index、image layout</li><li>subpass 之间的依赖</li></ul><p>Vulkan Render Pass 特殊之处在于其是由 subpass 来描述内部多个子阶段的，绘制指令也会被记录在一个当前激活的 subpass 中。subpass 的设计是为了能够高效利用某些 tile-based 架构的移动端 GPU，即 fragment shader 的执行是以 tile 为单位的，因此之后的 subpass 可以直接读到上一个 subpass 写入 attachment 的数据，而不需要等到整个 render pass 执行完。</p><p><a href="#%5B1%5D">[1]</a> 以由两个 pass 组成的 deferred shading 为例，第一个 pass 为了绘制 G-Buffer，第二个 pass 基于 G-Buffer 进行光照计算，得到最终绘制结果。可以设置 render pass 包含两个 subpass，第一个 subpass 绘制 G-Buffer，第二个 subpass 将第一个 subpass 的 G-Buffer 作为 <code>input attachment</code>，执行光照计算。流程如下述伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">cmdBeginRenderPass</span><br><span class="hljs-function"><span class="hljs-title">cmdBindPipeline</span><span class="hljs-params">(pipeline0)</span></span><br><span class="hljs-function">... <span class="hljs-comment">// bind vertex/index buffer or descriptor set of shader resource</span></span><br><span class="hljs-function">cmdDraw</span><br><span class="hljs-function">cmdNextSubpass</span><br><span class="hljs-function"><span class="hljs-title">cmdBindPipeline</span><span class="hljs-params">(pipeline1)</span></span><br><span class="hljs-function">... <span class="hljs-comment">// bind vertex/index buffer or descriptor set of shader resource</span></span><br><span class="hljs-function">cmdDraw</span><br><span class="hljs-function">cmdEndRenderPass</span><br></code></pre></td></tr></table></figure><p>注意两个 subpass 使用的是两个 PSO，因为 geometry pass 的 shader 与 deferred shading 的 shader，以及其 shader 输入肯定不同。在第二个 subpass 使用到的 pipeline1 的 shader 则可以使用如下方式来声明 input attachment，</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span> (input_attachment_index = <span class="hljs-number">0</span>, set = <span class="hljs-number">0</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> subpassInput inputColor;<br><span class="hljs-keyword">layout</span> (input_attachment_index = <span class="hljs-number">1</span>, set = <span class="hljs-number">1</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">uniform</span> subpassInput inputDepth;<br></code></pre></td></tr></table></figure><p><code>subpassLoad(inputColor)</code> 则会读取上个 subpass 在 inputColor 同样区域写入的数据。</p><h3 id="1-2-Vulkan-Pipeline-Layout"><a href="#1-2-Vulkan-Pipeline-Layout" class="headerlink" title="1.2 Vulkan Pipeline Layout"></a>1.2 Vulkan Pipeline Layout</h3><p>shader 中的输入参数需要对应描述符 <code>VkDescriptorSetLayout</code> 对其描述，而 vulkan pipeline layout 则包含了整个管线的所有 shader 输入参数的描述符。上述 set&#x3D;0、set&#x3D;1 则分别表示了索引 0、1 的 VkDescriptorSetLayout 对象，相当于整个管线的描述符分到了两个描述符堆上。一个输入资源的描述符 <code>VkDescriptorSetLayoutBinding</code>，包含了 binding、资源类型(如上例中的 <code>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT</code>)、当为数组时的数组长度以及被哪些 shader 阶段使用。</p><p>Vulkan Pipeline Layout 只是对管线 shader 输入的描述，相当于函数签名中形参，真正使用的数据资源，如 sampler、texture、buffer 等，需要使用 command 在 draw call 之前指定。因此 Vulkan Pipeline Layout 同样使用 hash 自动创建。</p><p>特别注意，描述符堆是从 descriptorPool 中使用 VkDescriptorSetLayout 创建得到的，每个描述符堆 <code>VkDescriptorSet</code> 同时只能由一个 command buffer 使用，因此描述符堆的申请使用与停止使用应该由 command buffer 完成。类 <code>VulkanDescriptorPoolManager</code> 维护已经创建的描述符堆以及其使用状态，command buffer 在更新描述符资源之前请求使用，如果没有可用的 descriptorSet 则新创建。command buffer 具有自己执行是否完成的 fence，类 <code>VulkanCommandBufferManager</code> 更新 command buffer 状态时，如果 command buffer 中的指令已经完成，则归还其使用的描述符堆。</p><h2 id="2-从上层到渲染层的管线创建"><a href="#2-从上层到渲染层的管线创建" class="headerlink" title="2. 从上层到渲染层的管线创建"></a>2. 从上层到渲染层的管线创建</h2><p>本渲染器的最初设计是面向多平台的，设置了平台无关层，只是目前只有 Vulkan 的渲染层，因此平台无关层更偏向于 Vulkan。下面介绍与管线创建相关的平台无关层的类。</p><ul><li><code>GPIRenderPassInfo</code>：对标 vulkan render pass 的描述，但不仅仅包含了对 render pass 的描述，还包含 render pass 中使用到的 render target ，因此 render pass 对应的 frame buffer 的创建所需参数也是从该类型中获取。</li><li><code>GPIGfxPipelineStateInitializer</code>：对标 Graphics PSO 的配置参数。</li></ul><p>抽象类 <code>GraphicsBridge</code> 定义了一系列到渲染层的接口，不同的平台实现其接口。例如，设置 render pass 以及管线的接口 <code>GPIBeginRenderPass</code> 、<code>GPISetGfxPipelineState</code>。下面是管线创建的上层逻辑的伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">GPIRenderPassInfo basePassInfo;<br><span class="hljs-comment">// ... // config basePass info</span><br>gGfxBridge-&gt;<span class="hljs-built_in">GPIBeginRenderPass</span>(basePassInfo);<br>&#123;<br>    GPIGfxPipelineStateInitializer PSOInitializer;<br>    <span class="hljs-comment">// ... // config PSOInitializer</span><br>    gGfxBridge-&gt;<span class="hljs-built_in">GPISetGfxPipelineState</span>(PSOInitializer, basePassInfo);<br>    <span class="hljs-comment">// ... // config the resources of descriptor set</span><br>    gGfxBridge-&gt;<span class="hljs-built_in">GPIDrawPrimitive</span>();<br>&#125;<br>gGfxBridge-&gt;<span class="hljs-built_in">GPIEndRenderPass</span>();<br></code></pre></td></tr></table></figure><p><code>GPIBeginRenderPass</code> 会根据参数 basePassInfo 来生成 vulkan render pass 的配置，以及 frame buffer 的资源参数，通过 hash 的方式查找是否存在对应配置的 render pass 与 frame buffer，不存在则创建。同理 <code>GPISetGfxPipelineState</code> 根据 PSOInitializer 与 basePassInfo 参数以 hash 方式查找 PSO，并绑定到当前 command buffer。</p><p>同时 <code>GPIBeginRenderPass</code> 还做了一些开始管线前的准备工作，比如向 <code>VulkanCommandBufferManager</code> 申请 command buffer，以及将 render pass 需要的 render target 调整到其所指定的输入 layout 等。</p><h1 id="Shader-的管理与配置"><a href="#Shader-的管理与配置" class="headerlink" title="Shader 的管理与配置"></a>Shader 的管理与配置</h1><p>上述管线创建过程中，还需要 shader 的配置。<code>UltraShader</code> 基类定义了 shader 相关描述，如 shader 源码文件路径、shader 编译相关配置、shader 输入参数描述等。不同 shader 继承自此基类，声明自己的参数，其中输入参数会被用于管线创建 <code>VkPipelineLayout</code> 资源描述。而编译相关配置则包括一些全局编译配置，如平台、优化参数等，以及一些宏定义，用以开启或关闭某些代码。</p><h3 id="1-Shader-源码编译与加载"><a href="#1-Shader-源码编译与加载" class="headerlink" title="1. Shader 源码编译与加载"></a>1. Shader 源码编译与加载</h3><p>本渲染器的 shader 编译与加载由类 <code>ShaderCompilerManager</code> 完成。该类基于 shaderc，但为了在 renderdoc 能够源码级调试 shader，在 debug 时使用 glslangValidator 编译。目前编译触发条件，有两种：</p><ul><li>加载过程中，shader 文件及其 include 文件的时间戳要比记录文件中的更新。或者 shader 的一些配置发生改变。</li><li>运行过程中，shader 的一些配置(如宏定义)发生改变。[TODO] 运行过程中文件的改动主动触发编译</li></ul><p>Shader 文件的后缀分为作为头文件的 .glsl 以及表示不同阶段的源码文件如 .ver、.frag、.comp 等。编译过程中会记录源码文件以及其 include 文件的时间戳，用以辨别是否有更改。同时将 shader 编译配置进行 hash，作为编译输出文件的文件名一部分，用以辨别当前 shader 编译配置是否已经编译过。这些信息都会记录在 “intermediate&#x2F;Shaders&#x2F; ShaderFileCache.json” 文件中，该文件在启动时加载。</p><p>由于 include 文件会有多级 include，因此只有加载了 shader 源码将所有层级的 include 文件进行时间戳比对才能确定是否需要编译此 shader，因此这一模式只能在加载过程中应用。在运行时需要采用主动触发编译，目前主动触发编译只有实现了 shader 的编译配置发生改变，文件发生改变主动触发编译留待之后实现。</p><h3 id="2-Shader-输入参数描述"><a href="#2-Shader-输入参数描述" class="headerlink" title="2. Shader 输入参数描述"></a>2. Shader 输入参数描述</h3><p>模板类 <code>TShaderResourceParameter</code> 可以容纳各种类型的 shader 参数描述，同时可以绑定实际的资源。但这些目前都需要大量的手写代码完成，手动与 shader 代码里的声明对齐，手动绑定资源。更合理的做法应该是，</p><ul><li>实现 C++ 反射宏，使用宏能够更快速声明 shader 参数描述</li><li>shader 编译过程应该利用 shader 反射生成包含输入资源描述的头信息。shader 参数在 C++ 中使用相同的名称，使用头信息中的名称进行自动配置参数描述(layout信息等)，并进行验证。</li></ul><p>这些留待之后实现。</p><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><p>由于时间有限，有很多搁置的策略未实现。</p><ul><li>描述符堆目前未实现同时多个堆策略</li><li>shader 编译流程生成 layout 头信息，使用 C++ 反射宏进行绑定</li><li>多线程渲染</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a name="[1]">[1]</a> <a href="https://www.saschawillems.de/blog/2018/07/19/vulkan-input-attachments-and-sub-passes/">https://www.saschawillems.de/blog/2018/07/19/vulkan-input-attachments-and-sub-passes/</a></p>]]></content>
    
    
    <categories>
      
      <category>Render Engine</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Real-Time Global Illumination using Precomputed Light Field Probes</title>
    <link href="/2023/09/20/Paper%20Notes/GI/Real-Time%20Global%20Illumination%20using%20Precomputed%20Light%20Field%20Probes/"/>
    <url>/2023/09/20/Paper%20Notes/GI/Real-Time%20Global%20Illumination%20using%20Precomputed%20Light%20Field%20Probes/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Summary"><a href="#1-Summary" class="headerlink" title="1 Summary"></a>1 Summary</h2><p>这篇论文提出了一种基于light probe的全局光照方法，其中包括预计算过程中probe数据的生成方式、基于probe数据的光线追踪算法以及实时渲染中的着色过程。</p><p>在预计算过程中，对场景的每个离散采样点生成以该位置为中心的probe数据，每个probe包含了球面分布的两组数据：probe中心收到每一方向上最近点的radiance、该最近点的法线以及该最近距离(radial distance)；为了处理diffuse间接光，对probe中心收到的radiance进行prefilter得到的irradiance、最近距离及其平方。</p><p>同时，probe数据采用了具有分段线性投影特性的octahedral map存储，作者提出了在基于此map的具有2-level层级加速的高效光线追踪算法。为了得到确定的求交结果，需要在着色点周围的八个probe中选择进行求交测试，为此，作者提出最小化octahedral map访问次数的选取策略。</p><p>在实时渲染的着色过程中，直接光照选择采用传统的deferred shading。对于间接光照，作者将BRDF拆分为Lambertian项和glossy项，并为每一项采样一条光线计算间接光照：前者由于其在分布空间变化平缓的特性，而选择采样irradiance map，并可以使用较大的filter进行降噪；而后者在其分空间变化强烈，采样radiance map，并使用较小的filter降噪。而对于降噪filter过程，除了应用传统的空间与时序的降噪，作者还提出使用probe中的几何信息来构建geometry-aware的权重，来避免light&#x2F;shadow-leaking问题。</p><p>作者源码 <a href="#%5B3%5D">[3]</a></p><h2 id="2-Light-Field-Probe-Structure"><a href="#2-Light-Field-Probe-Structure" class="headerlink" title="2 Light Field Probe Structure"></a>2 Light Field Probe Structure</h2><p>Light Field(光场)描述了空间中一点的radiance在出射方向上的分布，假设点 $\mathbf{x}\in \mathcal{R}^3$，以及该点的一个出射方向 $\omega\in \mathcal{S}^2$ (应该指上半球)，那么Light Field可使用 $\mathcal{L}(\mathbf{x},\omega)$ 表示。不可能对场景中每一点都定义Light Field，作者通过将场景的包围盒均分为grid来将空间离散化，对每个grid的一个采样点定义一个light field。</p><p>在每个离散采样点 $\mathbf{x}’$（每个grid的一个采样点）上存储一个球形light field probe数据，用以记录点 $\mathbf{x’}$ 的每个方向 $\omega$ 的数据，包括：</p><ul><li>$\mathcal{L}(\mathbf{x’},\omega)$：点 $\mathbf{x}’$ 在方向 $\omega$ 的入射radiance。light field是在球面上的定义，而probe像素有一定大小，可以看作在球面上一片的radiance，因此文中称为spherical light field slice radiance。</li><li>在方向 $\omega$ 上距点 $\mathbf{x’}$ 最近的点 $\mathbf{x’’}$ 的表面法线：$\vec{\mathbf{n_{x’’}}}$</li><li>$\mathbf{x’}$ 与 $\mathbf{x’’}$ 之间的radial distance $r_{\mathbf{x’}\leftrightarrow\mathbf{x’’}}$</li></ul><h3 id="2-1-Probe-数据生成方式"><a href="#2-1-Probe-数据生成方式" class="headerlink" title="2.1 Probe 数据生成方式"></a>2.1 Probe 数据生成方式</h3><p>上述Probe数据中的几何信息，例如 $\vec{\mathbf{n_{x’’}}}$、$r_{\mathbf{x}’\rightarrow\mathbf{x’’}}$，作者使用光栅化管线生成。而spherical light field slice radiance $\mathcal{L}(\mathbf{x’},\omega)$ 需要光线模拟过程来生成：可以通过光栅化过程现有的着色技术(deferred renderer with shadow map)来计算；或者使用离线path tracer；作者选择迭代应用本文提出的着色算法来生成，具体做法：对于一次反射的直接光照 $\mathcal{L}(\mathbf{x’},\omega)$ 只包含场景中光源的发光，重复应用着色算法得到具有额外反射的 $\mathcal{L}(\mathbf{x’},\omega)$。</p><h3 id="2-2-实现细节"><a href="#2-2-实现细节" class="headerlink" title="2.2 实现细节"></a>2.2 实现细节</h3><p>一个probe本质上是以其中心点 $\mathbf{x’}$ 为球心的球面上所有方向的信息，类似于全向相机的渲染（Omnidirectional），其数据组织为cube map的形式，每个像素的数据为其对应方向 $\omega$ 的probe数据。本文提出的算法中不直接使用cube map，而是在生成probe数据过程中，将cube map重采样到octahedral map(oc-map)中 <a href="#%5B1%5D">[1]</a> <a href="#%5B2%5D">[2]</a> <a href="#5.1">[5.1]</a>，之后的算法就不再需要cube map。八面体参数化是将球面映射到一个方形平面上，相比于cube map，oc-map具有优势：失真度更低；同等质量水平下，存储开销与带宽降低4倍；分段线性的投影能够应用于高效的ray marching。</p><p>每个probe的oc-map数据作为2D texture array的一个layer存储，一个oc-map像素大小为32字节，其存储格式为：</p><ul><li>HDR radiance $\mathcal{L}(\mathbf{x’},\omega)$：R11G11B10F (32 bits&#x2F;pixel)</li><li>法线 $\vec{\mathbf{n_{x’’}}}$：RG8 (16 bits&#x2F;pixel)</li><li>radial distance $r_{\mathbf{x}’\rightarrow\mathbf{x’’}}$：R16F (16 bits&#x2F;pixel)</li></ul><p>irradiance probe：很多着色过程得益于prefilter light field radiance $\mathcal{L}(\mathbf{x’},\omega)$，因此将prefilter结果预存储到一个cosine-weighted incident irradiance probe $\mathbf{E}(\mathbf{x’},\vec{\mathbf{n}})$，即点 $\mathbf{x’}$ 处的法线方向 $\vec{\mathbf{n}}$ 上收到的radiance积分。例如，Lambertian项描述的漫反射项。作者发现irradiance probe的oc-map的分辨率高于 $128\times 128$ 后就不会再有精确度方面的收益了。irradiance probe的数据存储格式和上述基本相同，只是将radiance替换为irradiance，法线替换为radial distance的平方，之后用于降噪过程的切比雪夫测试。</p><p>radiance probe需要的分辨率取决于渲染分辨率和场景中的最低粗糙度，避免完美镜面反射的走样。为此需要满足八面体纹素对着的立体角不大于probe中心位置的像素对着的立体角。文中建议1024x1024的分辨率。</p><blockquote><p>场景中不同区域在屏幕上的像素比例不同，例如离相机远的区域占用像素更少、粗糙度越低对应的立体角越小。如果probe分辨率不足，会导致八面体纹素对应的立体角大于像素对应的立体角，像素采样到的radiance信息超出了像素范围，即radiance采样率不足。</p></blockquote><h2 id="3-Light-Field-Probe-Ray-Tracing"><a href="#3-Light-Field-Probe-Ray-Tracing" class="headerlink" title="3 Light Field Probe Ray Tracing"></a>3 Light Field Probe Ray Tracing</h2><p>已知光线方程 $\mathbf{p}(t)&#x3D;\mathbf{r}_o+t\cdot\mathbf{r}_d$，求解最近交点 $\mathbf{p}(t’)\equiv\mathbf{p}’$。Light field probe中的几何信息radial distance和法线用于解决incoherent世界空间求交，radiance probe和irradiance probe包含了所需的辐射量，交点处的出射radiance $\mathcal{L}(\mathbf{p}’,-\mathbf{r}_d)$和入射irradiance $\mathcal{L}(\mathbf{p}’,\vec{\mathbf{n}}\equiv\vec{\mathbf{r}_d})$。</p><p>作者提出的Light Field ray trace过程如下图：先选择一个候选probe，执行single-probe ray trace，当得到miss或hit结果时，则求交结束。当无法得到求交确定结果时，选择下一个候选probe继续执行single-probe ray trace。</p><blockquote><p>如果得到不确定的结果，则表示本次选择的probe缺少光线传播区域的信息，例如从probe视角来看，光线传播区域被遮挡，因此无法确定是miss或hit。</p></blockquote><img src="/images/Paper Notes/GI/Real-Time%20Global%20Illumination%20using%20Precomputed%20Light%20Field%20Probes.assets/image-20230201162511726.png" alt="image-20230201162511726" style="zoom: 67%;"><img src="/images/Paper Notes/GI/Real-Time%20Global%20Illumination%20using%20Precomputed%20Light%20Field%20Probes.assets/image-20230202104825030.png" alt="image-20230202104825030" style="zoom:67%;"><p>作者提出的 light field ray  tracing算法主要包括两方面：选择候选probe的启发式策略；probe的oc-map中的光线求交。</p><h3 id="3-1-Single-Probe光线求交"><a href="#3-1-Single-Probe光线求交" class="headerlink" title="3.1 Single-Probe光线求交"></a>3.1 Single-Probe光线求交</h3><p>球面的八面体投影性质：将三维空间的线段映射为oc-map中的多段线(最多4段线)，其中每段线分布在oc-map的不同面；probe的三维球体被以probe中心为原点的坐标系分割成8个平面，分别对应了oc-map的8个面，而每段线的端点为三维空间的线段与三个坐标轴对齐面的交点在oc-map的投影。</p><p>probe的光线求交：首先计算出光线在oc-map投影的几组端点；然后沿着线段进行ray-march，使用当前位置与probe中心的radial distance $t_0$ 以及当前位置在oc-map中的对应纹素存储的radial distance $t_1$ 做求交测试，</p><ul><li>如果 $t_0&gt;t_1$ 表示光线交于一个表面(hit)或者从一个表面后面通过(unknown，光线行进区域在probe中被遮挡)</li><li>否则miss</li></ul><blockquote><p>probe的光线求交与SSR思想类似，不同的是：</p><ul><li>光线在depth buffer中的投影是一条直线，而在oc-map中的投影是几段线</li><li>对于光线行进位置处的求交测试：SSR使用相机视角的depth buffer在行进位置处的深度值与相机到行进位置距离，而本文的probe求交则使用oc-map在行进位置处的radial distance与probe中心到行进位置的radial distance</li></ul></blockquote><p>对于oc-map的一个面内ray-march可以使用hierarchy算法加速 <a href="#%5B4%5D">[4]</a>。上述求交测试中，当 $t_0 &lt; t_1$ 可以确定miss，但 $t_0 &gt; t_1$ 有可能hit，也有可能从后面通过(unknown)。为了得到确定结果，需要确定求交平面即oc-map的对应texel在三维空间的范围。oc-map的每个纹素描述的是距离probe中心 $r_{\mathbf{p}’\leftrightarrow \mathbf{x}’’}$ 并且法线为 $\vec{\mathbf{n_{x}}’’}$ 的一个小patch(surfel)。基于法线和表示精度，作者使用一个球形体素包围该patch。只有当前行进点与该体素相交时，才表示与光线与patch表面相交。法线也可以用作排除掉相对于光线方向的背面的交点。下图为光线求交过程的可视化，光线在如图oc-map投影得到三个线段</p><img src="/images/Paper Notes/GI/Real-Time%20Global%20Illumination%20using%20Precomputed%20Light%20Field%20Probes.assets/image-20230202213146200.png" alt="image-20230202213146200" style="zoom:67%;"><center>two-level层级结构的求交过程：黄色与绿色分别为粗粒度与细粒度的ray-march测试</center><h3 id="3-2-Probe选取策略"><a href="#3-2-Probe选取策略" class="headerlink" title="3.2 Probe选取策略"></a>3.2 Probe选取策略</h3><p>对于任意光线起点 $\mathbf{r}_o$ 都会被其周围8个probe所描述立方体包裹，如下图中编号所示。light field ray tracing首先选择中心距光线最近的probe进行求交。根据空间局部性原理，这8个probe往往具有相似的visibility信息，这一启发策略在深度高复杂高和probe密度低的情况下会失效。而首先选择最近的probe是因为光线在该probe的oc-map中的投影最短，这样会带来ray-march过程中访问texture的次数较少；同时，最近的probe更可能观察到光线行进区域而不被遮挡。</p><p><a name="Fig 3.2"></a></p><img src="/images/Paper Notes/GI/Real-Time%20Global%20Illumination%20using%20Precomputed%20Light%20Field%20Probes.assets/image-20230203133555805.png" alt="image-20230203133555805" style="zoom: 67%;"><center>图3.2 光线起点周围的8个probe</center><p>当single-probe hierarchy ray march不能确定求交结果时，需要再选择一个probe执行求交过程。首先将光线起点移动到上一个确定求交结果的行进位置，$\mathbf{r}’_{d}&#x3D;\mathbf{r}_o+t’\mathbf{r}_d$ 。如果新的光线起点进入了一个新的立方体范围，那么再次选择一个距离光线最近的probe。如果新的光线起点还在原立方体范围内，从未进行求交测试的probe中选择一个距离上一个probe最远的probe，这种策略同样是基于空间局部性原理。为此，作者设计了简单高效位运算，假设light field ray tracing始于距光线最近的probe $i$，那么下一次选择 $i’&#x3D;(i+3)\space mod\space 8$，选择顺序如上图的有向曲线所示。</p><p>[图3.3](#Fig 3.3)使用像素颜色表示了该像素得到求交结果的probe编号，同样的颜色表示同一个probe。可以看出越近的像素，其遮挡信息越相近。注意：probe的选取策略只会影响性能，不会影响求交结果。</p><p><a name="Fig 3.3"></a></p><img src="/images/Paper Notes/GI/Real-Time%20Global%20Illumination%20using%20Precomputed%20Light%20Field%20Probes.assets/image-20230203182557809.png" alt="image-20230203182557809" style="zoom: 50%;"><center>图3.3 probe选取可视化。像素颜色表示该像素发出的glossy ray在颜色所表示编号的probe得到求交结果</center><h3 id="3-3-性能说明"><a href="#3-3-性能说明" class="headerlink" title="3.3 性能说明"></a>3.3 性能说明</h3><p>由于文中提出的probe选取策略会得到光线在所选probe的oc-map中的投影线段最短，而投影线段的缩短减少光线行进的步数，也就是减少oc-map的访问以及求交测试。这可以带来便利的内存-性能权衡：增大probe密度不仅能够提高准确度，也会由于缩短光线在oc-map的投影长度而提高性能。</p><p>在实现上，作者通过重新组织glsl中的branch，降低线程动态分支的开销。light field ray tracing使用two-level mipmap实现的层级加速，第2层分辨率是上一层的 $1&#x2F;16^2$。</p><h2 id="4-Shading-with-Light-Field-Probes"><a href="#4-Shading-with-Light-Field-Probes" class="headerlink" title="4 Shading with Light Field Probes"></a>4 Shading with Light Field Probes</h2><p><strong>原始的着色算法</strong>：光栅化直接可见表面后(deferred shading)在pixel shader中使用shadow map计算直接光照；然后在同一pixel shader中进行蒙特卡洛积分来估计间接光：基于重要性采样，发出 $n$ 个随机光线，每条光线对light field进行采样得到对应入射方向上的incident radiance。最后乘上cosine-weighted BRDF并使用采样分布和采样数 $n$ 归一化后得到积分估计。</p><p>上述原始算法可以捕获到静态和动态物体的间接效果，同时可以使用该算法<strong>再次渲染probe来逐步填充light field probe的在任意次反射之后的radiance分布</strong>。但该方法有两个局限：</p><ul><li><p>更高阶间接光照效果的视点偏差：当从light field probe中采样radiance时，得到的是采样点到probe中心的radiance，与着色点是有一定差距的。</p><blockquote><p>在使用上一章节描述的光追算法，得到采样光线的反射点后，可将probe中心点到反射点的方向进行转换得到对应的oc-map的采样坐标，采样radiance map得到的是probe中心收到反射点的入射radiance。</p></blockquote></li><li><p>性能：原始算法中需要很多光线数量来降低噪声，无法应用到实时渲染中</p></li></ul><p>但更高阶的光照效果的失真影响远远小于第一次反射，作者更关注性能问题。作者对原始着色算法进行近似与优化，使其更适用于现代实时渲染管线。</p><h3 id="4-1-Spatial-Temporal-Radiance-Denoising"><a href="#4-1-Spatial-Temporal-Radiance-Denoising" class="headerlink" title="4.1 Spatial-Temporal Radiance Denoising"></a>4.1 Spatial-Temporal Radiance Denoising</h3><p>实时渲染下能够支持的光线数量非常有限，应对噪声的通常做法是使用时序-空间上的降噪，即SVGF的思想。针对BRDF，作者将其分解为两项：描述diffuse的Lambertian项和描述specular的glossy项。间接光照的render pass为每一项采样(cosine-weighting)一条光线，并将结果写入带噪声的Lambertian和glossy入射radiance buffers。之后再在单独的denoise pass进行双边过滤(cross-bilateral)和时序重投影降噪。</p><p>对于Lambertian项，均匀分布在法线方向的上半球范围，同样采样率水平下，噪声更大，但变化较小。因此可以直接采用存储积分后的irradiance，同时由于其变化较为平缓的特点，可以使用更大的filter，文中采用半径为12像素、步长为2像素的空间滤波与98%置信度的时序滤波。glossy项虽然噪声较小，但变化较为剧烈，因此使用更小的filter，采用半径为3像素的空间滤波与75%置信度的时序滤波，如 [图4.1](#Fig 4.1) 所示。</p><p><a name="Fig 4.1"></a></p><img src="/images/Paper Notes/GI/Real-Time%20Global%20Illumination%20using%20Precomputed%20Light%20Field%20Probes.assets/image-20230213234756136.png" alt="image-20230213234756136" style="zoom:80%;"><center>图4.1 使用一个采样光线的glossy indirect buffer。左边为降噪前，右边为降噪后</center><h3 id="4-2-Irradiance-with-Pre-Filtered-Visibility"><a href="#4-2-Irradiance-with-Pre-Filtered-Visibility" class="headerlink" title="4.2 Irradiance with (Pre-)Filtered Visibility"></a>4.2 Irradiance with (Pre-)Filtered Visibility</h3><p>前文所述的预计算过程，通过蒙特卡洛计算radiance积分估计，得到probe中心位置的irradiance oc-map(128X128)中，采样坐标为法线方向转换得到oc-map坐标。在运行时，作者通过在如[图3.2](#Fig 3.2)的八个probe之间使用三线性插值来估计着色点处收到的irradiance。但该方法存在的缺陷：插值得到的irradiance会透过irradiance probe立方体网格体积内的物体，从而造成漏光或者漏阴影，如[图4.3](#Fig 4.3)所示。具体而言，在立方体网格体积内的着色点与一个或多个probe之间的可见性假设是无效的。</p><p>为此作者提出了一种geometry-aware方法来避免这些不合理现象。在预计算cosine-filtered irradiance map时，采用cosine-power lobe的滤波方式，对radial distance和其二次方进行滤波得到的filter map，这中滤波方式避免了距离的离散值带来的锯齿，同时又不造成过度模糊，如[图4.2](#Fig 4.2)所示。在运行时，结合基础的三线性插值的权重与额外的两项得到geometry-aware权重：</p><ul><li>着色点表面法线与其到probe的方向之间的clamp dot</li><li>local radial distance分布的切比雪夫可见性检验，方法与VSM<a href="#%5B5%5D">[5]</a>原理类似，分布方差为 $\sigma^2&#x3D;E[r]^2-E[r^2]$。</li></ul><p>最后累加结果使用8个probe权重之和归一化。</p><p><a name="Fig 4.2"></a></p><img src="/images/Paper Notes/GI/Real-Time%20Global%20Illumination%20using%20Precomputed%20Light%20Field%20Probes.assets/image-20230214001658030.png" alt="image-20230214001658030" style="zoom:67%;"><center>图4.2 每一列为irradiance probe的一组数据。行从上到下依次为：irradiance；过滤的radial distance；过滤的二次距离</center><p><a name="Fig 4.3"></a></p><img src="/images/Paper Notes/GI/Real-Time%20Global%20Illumination%20using%20Precomputed%20Light%20Field%20Probes.assets/image-20230214233524659.png" alt="image-20230214233524659"><center>图4.3 传统irradiance map的漏光缺陷，文中提出的irradiance map解决后的效果</center><h2 id="5-Appendix"><a href="#5-Appendix" class="headerlink" title="5 Appendix"></a>5 Appendix</h2><h3 id="5-1-八面体参数化"><a href="#5-1-八面体参数化" class="headerlink" title="5.1 八面体参数化"></a>5.1 <a name="5.1">八面体参数化</a></h3><p>cube map的八面体参数化过程：先将球面投影到正八面体上，然后再投影到 $z &#x3D; 0$ 平面上，并将 $z &lt; 0$ 的部分进行翻转，最终形成一个二维正方形。如下图所示</p><img src="/images/Paper Notes/GI/Real-Time%20Global%20Illumination%20using%20Precomputed%20Light%20Field%20Probes.assets/image-20230301210633868.png" alt="image-20230301210633868" style="zoom:67%;"><center>八面体参数化过程</center><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a name="[1]">[1]</a> Cigolle, Zina H., et al. “A survey of efficient representations for independent unit vectors.” <em>Journal of Computer Graphics Techniques</em> 3.2 (2014).</p><p><a name="[2]">[2]</a> <a href="https://zhuanlan.zhihu.com/p/384232048">https://zhuanlan.zhihu.com/p/384232048</a></p><p><a name="[3]">[3]</a> <a href="https://github.com/Global-Illuminati/Precomputed-Light-Field-Probes">https://github.com/Global-Illuminati/Precomputed-Light-Field-Probes</a></p><p><a name="[4]">[4]</a> McGuire M, Mara M. Efficient GPU screen-space ray tracing[J]. Journal of Computer Graphics Techniques (JCGT), 2014, 3(4): 73-85.</p><p><a name="[5]">[5]</a> William Donnelly and Andrew Lauritzen. 2006. Variance shadow maps. In Proceedings of the 2006 symposium on Interactive 3D graphics and games (I3D ‘06). Association for Computing Machinery, New York, NY, USA, 161–165.</p>]]></content>
    
    
    <categories>
      
      <category>Paper Notes</category>
      
      <category>GI</category>
      
      <category>Light Probe</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spatiotemporal reservoir resampling for real-time ray tracing with dynamic direct lighting</title>
    <link href="/2023/09/20/Paper%20Notes/Ray%20Tracing/Spatiotemporal%20reservoir%20resampling%20for%20real-time%20ray%20tracing%20with%20dynamic%20direct%20lighting/"/>
    <url>/2023/09/20/Paper%20Notes/Ray%20Tracing/Spatiotemporal%20reservoir%20resampling%20for%20real-time%20ray%20tracing%20with%20dynamic%20direct%20lighting/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Summary"><a href="#1-Summary" class="headerlink" title="1 Summary"></a>1 Summary</h1><p><code>Spatiotemporal reservoir resampling for real-time ray tracing with dynamic direct lighting</code> <a href="#%5B1%5D">[1]</a></p><p>解决 many-lights 下的直接光照的重要性采样问题。</p><h1 id="2-Background"><a href="#2-Background" class="headerlink" title="2 Background"></a>2 Background</h1><p>本论文将光源视为场景中的发光几何体，因此 many-lights 下的渲染方程为：着色点 $y$ 在方向 $\vec{\omega}$ 所反射的 radiance $L$ 是对所有发光表面 $A$ 的积分：<br>$$<br>L(y,\vec{\omega}) &#x3D; \int_A \rho(y,\vec{yx}\leftrightarrow\vec{\omega})L_e(x\rightarrow y)G(x\leftrightarrow y)V(x\leftrightarrow y) \space dA_x \tag{1} \label{render equation}<br>$$<br>其中，$\vec{\omega}$ 是观察方向，与相机相关；$\rho$ 与着色点 $y$ 的材质有关，论文中指 BSDF；$L_e$ 是光源表面一点 $x$ 到着色点 $y$ 方向上发出的 radiance；$G$ 几何项，包含了 inverse squared distance 和反射方向与入射方向的余弦项。</p><p>对渲染方程的表示进行一些符号简化，被积函数简化为 $f(x)$，积分微元 $dx$，有渲染方程的简化形式：<br>$$<br>L&#x3D;\int_A f(x)\space dx,\quad where \space f(x)\equiv\rho(x)\cdot L_e(x)\cdot G(x)\cdot V(x) \tag{2} \label{simple render equation}<br>$$</p><ul><li><strong>Importance Sampling(IS)</strong></li></ul><p>使用蒙特卡洛重要性采样方法估计 $\eqref{simple render equation}$ 式积分，从 source PDF $p(x_i)$ 中进行 $N$ 次采样，得到 $N$ 个样本，$\eqref{simple render equation}$ 积分的估计量为：<br>$$<br>L \approx \langle L \rangle_{IS}^N &#x3D;\frac{1}{N}\sum\limits_{i&#x3D;1}^N \frac{f(x_i)}{p(x_i)} \tag{3} \label{IS MC}<br>$$<br>其中如果在 $f(x)$ 非零时，$p(x)$ 都为正，IS 则为无偏估计；并且可以通过选取与 $f(x)$ 相关的 $p(x)$ 形式，来降低方差。</p><ul><li><a name="MIS"><strong>Multiple Importance Sampling(MIS)</strong></a></li></ul><p>由于 $f(x)$ 的复杂性（包含多项），直接采样与 $f(x)$ 成比例（相关）的分布是不可实行的，而通常采样与 $f(x)$ 中单项成比例的分布，例如 $\rho$ BSDF、$L_e$ 等。因此，定义 $M$ 个采样策略 $p_s$ (概率分布)，MIS 从每个采样策略 $s$ 中采样出 $N_s$ 个样本，再将这些样本组合到一个 weighted-estimator 中，如下：<br>$$<br>L\approx \langle L\rangle_{MIS}^{M,N}&#x3D;\sum\limits_{s&#x3D;1}^M\frac{1}{N_s}\sum\limits_{i&#x3D;1}^{N_s}w_s(x_i)\frac{f(x_i)}{p(x_i)} \tag{4}\label{MIS MC}<br>$$<br>其中，只要权重 $w_s$ 可以组成一个归一化整体，MIS 就是无偏估计，即 $\sum^M_{s&#x3D;1}w_s(x)&#x3D;1$。一种流行且较好的启发式选择为 $\Large w_s(x)&#x3D;\frac{N_s p_s(x)}{\sum_j N_jp_j(x)}$，等价于采样 $M$ 个独立采样策略的混合分布。</p><h2 id="2-1-Resample-Importance-Sampling-RIS"><a href="#2-1-Resample-Importance-Sampling-RIS" class="headerlink" title="2.1 Resample Importance Sampling(RIS)"></a>2.1 Resample Importance Sampling(RIS)</h2><p>由 $\eqref{MIS MC}$ 可以看出，MIS 是对着色项的线性组合的采样，而另一种可选的采样策略是对其中一些项的乘积进行近似成比例地采样。RIS 通过以下过程实现该采样策略：RIS 从 source PDF $p$ 中生成 $M\geq 1$ 个候选样本 $\boldsymbol{x}&#x3D;{x_1,\cdots,x_M}$，其中 $p$ 选择次佳但易于采样的分布，如 $p \propto L_e $。然后从这个候选池中使用以下离散概率分布进行随机选取 $z\in{1,\cdots,M}$，<br>$$<br>p(z\mid \boldsymbol{x})&#x3D;\frac{\mathrm{w}(x_z)}{\sum^M_{i&#x3D;1}\mathrm{w}(x_i)} \quad with \quad \mathrm{w}(x)&#x3D;\frac{\hat{p}(x)}{p(x)} \tag{5}\label{discrete PDF}<br>$$<br>其中，$p(x)$ 为易于采样的 source PDF；$\hat{p}(x)$ 为期望得到的 target PDF，例如无法直接采样的分布 $\hat{p}\propto \rho\cdot L_e \cdot G$。对于 <strong>1-sample RIS</strong> 估计量，因此有 $y\equiv x_z$，有<br>$$<br>L\approx \langle L \rangle^{1,M}<em>{RIS} &#x3D; \frac{f(y)}{\hat{p}(y)}\cdot\left(\frac{1}{M}\sum\limits^M</em>{j&#x3D;1}\mathrm{w}(x_j)\right) \tag{6} \label{1-sample RIS}<br>$$</p><blockquote><p>对 $\eqref{1-sample RIS}$ 的理解：RIS 一次采样相当于得到一个 target PDF $\hat{p}$ 的样本 $y$，这个分布是可以采用多项乘积的形式。回顾重要性采样 IS，要使得被积函数对应的估计量 $\langle L\rangle$ 无偏，需要估计量的形式为 $f(y)&#x2F;p_y(y)$，注意这里的 $p_y(y)$ 是 $y$ 的真实 PDF，而不是 target PDF。因此需要乘上括号部分，来近似 $y$ 的真实 PDF，但这种近似并不总是无偏的，会在某些情况下引入偏差，之后部分会有具体分析。</p></blockquote><p>多次执行 RIS，然后取平均，可以得到一个 N-sample RIS 估计量：<br>$$<br>L \approx\langle L\rangle^{M,N}<em>{RIS}&#x3D;\frac{1}{N}\sum\limits^N</em>{i&#x3D;1}\left(\frac{f(y_i)}{\hat{p}(y_i)}\cdot \left(\frac{1}{M}\sum^M_{j&#x3D;1}\mathrm{w}(x_{ij})\right)\right) \tag{7} \label{N-sample RIS}<br>$$<br>在 $M,N\geq 1$ 并且 $f$ 非零时，$p,\hat{p}$ 都为正，RIS 则为无偏估计。理论上 $M$ 和 $N$ 存在与方差有关的最优比，但实际中，这个比值难以事先预知。本文中采用简单形式 $N&#x3D;1$，即 1-sample RIS。有算法流程：</p><ol><li><p>预设 source PDF $p$，文中实验将其设为在面光源上的面积采样分布；target PDF $\hat{p}$，文中实验设置为 unshadowed path contribution 部分，即 $\rho \cdot L_e\cdot G$，不包含 visibility 项</p></li><li><p>设置初始为空的权重列表 $\textup{W}$，初始为 $0$ 的权重累积和 $\textup{w}_{sum}$，初始为空的候选样本列表 $\boldsymbol{x}$</p></li><li><p>对 source PDF $p$ 进行 $M$ 次采样：</p><ul><li><p>第 $i$ 次采样的随机样本为 $x_i$，放入候选样本列表 $\boldsymbol{x}$</p></li><li><p>计算样本 $x_i$ 的权重 $\mathrm{w}_i&#x3D;\Large \frac{\hat{p}(x_i)}{p(x_i)}$，并放入权重列表 $\mathrm{W}$</p></li><li><p>累积权重和 $\mathrm{w}<em>{sum}&#x3D;\mathrm{w}</em>{sum}+\mathrm{w}_i$</p></li></ul></li><li><p>对候选样本权重进行归一化：$\mathrm{w}_i&#x3D; \Large \frac{\mathrm{w}<em>i}{\mathrm{w}</em>{sum}}$</p></li><li><p>将归一化权重作为候选样本的概率分布，采样候选样本列表得到最终选出的样本 $y&#x3D;x_z$</p></li><li><p>返回选出的样本 $y&#x3D;x_z$ 以及本次 RIS 的候选样本的权重累积和 $\textup{w}_{sum}$</p></li></ol><p>假设像素 $q$ 对应 target PDF $\hat{p}(q)$，以及其渲染方程积分 $f_q$，1-sample RIS 算法伪代码如下：</p><p><a name="Algo 1"></a></p><img src="/images/Paper Notes/Ray Tracing/Spatiotemporal reservoir resampling for real-time ray tracing with dynamic direct lighting.assets/image-20220717215808514.png" alt="image-20220717215808514" style="zoom: 50%;"><center>算法 1</center><p>$\eqref{1-sample RIS}$ 式的计算需要候选样本数量 $M$，这是算法输入，是已知的；$\mathrm{w}_{sum}$，算法输出；$\hat{p}(y)$，$y$ 是算法选出的样本，$\hat{p}$ 是预设 target PDF，本文使用的是代入样本到被积函数后的颜色转为亮度。</p><h2 id="2-2-Weighted-Reservoir-Sampling-WRS"><a href="#2-2-Weighted-Reservoir-Sampling-WRS" class="headerlink" title="2.2 Weighted Reservoir Sampling(WRS)"></a>2.2 Weighted Reservoir Sampling(WRS)</h2><p>WRS 是一类从一个 stream ${x_1,x_2,\cdots,x_M}$ 中通过一遍操作来随机采样 $N$ 个元素的算法，该 stream 数据中每个元素 $x_i$ 都关联一个权重 $\textup{w}(x_i)$，$x_i$ 被选中的概率为<br>$$<br>P_i &#x3D; \frac{\mathrm{w}(x_i)}{\sum^M_{j&#x3D;1}\mathrm{w}(x_j)} \tag{8} \label{reservoir CDF}<br>$$<br>Reservoir sampling 对每个元素只进行一次操作，仅需要 $N$ 个元素保留在内存中，并且 stream 的长度 $M$ 不必事先预知。Reservoir sampling 算法，分为有放回采样与无放回采样，由于蒙特卡洛积分积分的采样通常是相互独立的，因此本论文只考虑较为简单的有放回采样算法。</p><p>Reservoir sampling 按照 input stream 的次序来处理其中的元素，保存一个具有 $N$ 个样本的 reservoir。<strong>在任何时刻，reservoir sampling 保持采样自 desired PDF 的 reservoir 中的样本的概率分布仍然是 desired PDF</strong>。即当处理一个来自 stream 的新元素时，更新 reservoir 来<strong>保持其中的样本分布的不变性</strong>，更新操作为：</p><p>在处理了 m 个样本之后，样本 $x_i$ 在 reservoir 出现的概率为 $\textup{w}(x_i)&#x2F;\sum^m_{j&#x3D;1}\textup{w}(x_j)$。处理下一个新元素 $x_{m+1}$ 的更新规则为，使用下一个样本 $x_{m+1}$ 以以下概率随机替换 reservoir 中样本 $x_i$ ：<br>$$<br>\frac{\mathrm{w}(x_{m+1})}{\sum^{m+1}<em>{j&#x3D;1}\mathrm{w}(x_j)}<br>$$<br>因此任意之前的样本 $x_i$ 在 reservoir 内的概率(即已在 reservoir 中，且不会被下一个样本替换掉的概率)为：<br>$$<br>\frac{\mathrm{w}(x_i)}{\sum^m</em>{j&#x3D;1}\mathrm{w}(x_j)}\left(1-\frac{\mathrm{w}(x_{m+1})}{\sum^{m+1}<em>{j&#x3D;1}\mathrm{w}(x_j)}\right)&#x3D;\frac{\mathrm{w}(x_i)}{\sum^{m+1}</em>{j&#x3D;1}\mathrm{w}(x_j)}<br>$$</p><blockquote><p>可以看出 N 个样本的 reservoir 接收到一个新元素的更新规则是，逐个样本执行更新规则</p></blockquote><p>观察 $\eqref{reservoir CDF}$ 中给出的 reservoir CDF 可知，在处理过一个新的元素后 reservoir 中元素的概率分布依然不变。N&#x3D;1 时的 WRS 算法如下：</p><img src="/images/Paper Notes/Ray Tracing/Spatiotemporal reservoir resampling for real-time ray tracing with dynamic direct lighting.assets/image-20220717215902454.png" alt="image-20220717215902454" style="zoom:50%;"><h1 id="3-Streaming-RIS-With-Spatiotemporal-Reuse"><a href="#3-Streaming-RIS-With-Spatiotemporal-Reuse" class="headerlink" title="3 Streaming RIS With Spatiotemporal Reuse"></a>3 Streaming RIS With Spatiotemporal Reuse</h1><p>RIS 算法对多个 source PDF 的样本进行重采样，重采样的概率分布结合了被积函数的(unshadowed) target PDF 以及源分布，而 target PDF 可以近似为渲染方程 $\eqref{simple render equation}$ 的被积函数每一项对应分布的乘积形式，这种乘积形式要比 <a href="#MIS">MIS</a> 的线性组合形式更接近被积函数的真实分布。因此，<strong>RIS 最终选出的样本可近似看作一次 MIS 采样(包含多种采样策略)的样本，且理论上更优。</strong></p><p>WRS 算法能够高效地维护一个 reservoir，在保持 reservoir 中原有样本所服从分布不变的情况下，不断纳入新的随机样本，使得 reservoir 样本不断逼近目标估计量的期望值。</p><p>理论上，对 RIS 应用 WRS 可以得到一个使 RIS 样本不断逼近期望值的高效算法，当然由于本文的 target PDF 选取 unshadowed path contribution，最终会由于 visibility 无法继续提高 RIS 样本。下面介绍如何应用 WRS 算法，从而得到 Streaming RIS 算法。</p><h2 id="3-1-Streaming-RIS-Using-Reservoir-Sampling"><a href="#3-1-Streaming-RIS-Using-Reservoir-Sampling" class="headerlink" title="3.1 Streaming RIS Using Reservoir Sampling"></a>3.1 Streaming RIS Using Reservoir Sampling</h2><p>RIS 算法为每个像素 $q$ 独立地生成候选样本，再在候选样本中以 target PDF $\hat{p}_q$ 重新采样，选出最终的样本。对 RIS 可以直接应用 WRS 算法，RIS 选出的样本及其对应的权重，可以直接用于 WRS 算法更新其 reservoir。论文中，通过均匀采样 emitter 的面积，并且使用无阴影的路径的贡献 $\hat{p}(x)&#x3D;\rho(x)\cdot L_e(x)\cdot G(x)$ 作为 target distribution，仅对 reservoir 中的 $N$ 个样本进行 trace shadow ray。Streaming RIS 算法如下，</p><p><a name="Algo 3"></a></p><img src="/images/Paper Notes/Ray Tracing/Spatiotemporal reservoir resampling for real-time ray tracing with dynamic direct lighting.assets/image-20220717215920480.png" alt="image-20220717215920480" style="zoom:50%;"><center>算法 3</center><p>这里每次更新 reservoir ：候选样本 $x_i$ 及其权重 $\eqref{discrete PDF}$ 中的 $\Large \textup{w}_{i}&#x3D;\frac{\hat{p}(x_i)}{p(x_i)}$。</p><h2 id="3-2-Spatiotemporal-Reuse"><a href="#3-2-Spatiotemporal-Reuse" class="headerlink" title="3.2 Spatiotemporal Reuse"></a>3.2 Spatiotemporal Reuse</h2><h3 id="3-2-1-复用-reservoir"><a href="#3-2-1-复用-reservoir" class="headerlink" title="3.2.1 复用 reservoir"></a>3.2.1 复用 reservoir</h3><p>Reservoir 样本累积了目前见过的所有样本信息，如果可以基于某些策略(如接下来的Spatiotemporal)，选择与当前像素<strong>样本分布相似</strong>的某些像素的 reservoir，再与当前像素的 reservoir 进行结合复用，就能大幅提高当前像素的采样率。</p><p>一种易想到的简单复用方式使用 2-pass 算法：第一个 pass 先为每一个像素生成其候选样本；第二个 pass 再结合自身与其周围像素的候选样本，进行重采样。但这种方式带来的内存开销非常大，需要存储每个像素的候选样本，即 input stream (如前述算法中 $M$ 个)。</p><p>为了规避内存开销问题，论文使用了 Reservoir sampling 的一个重要性质，该性质可以在不访问其他 reservoir 的 input stream 的条件下，结合多个 reservoir。如果多个 reservoir 中样本分布相似，同样可以将多个 reservoir 输入到一个新的 reservoir 中，这个新的 reservoir 汇集了所有输入 reservoir 的样本信息，并且由于相似的样本分布，而得到采样率&#x2F;质量更高的样本。</p><p>以两个 reservoir 为例：每个 reservoir 当前的状态包含当前选择的样本 $y$ 以及其 sum weight $\textup{w}_{sum}$，作为一个新的 reservoir 的输入，重采样出一个结合两个输入 reservoir 的新样本和新权重。这种方式只需要访问 reservoir 的当前状态，避免了存储 input stream 的开销，但结果在数学形式上等同于在两个 reservoir 的 input streams 重采样。</p><p>复用 reservoir 只是与当前 reservoir 的样本分布相似，但不完全相同，因此需要根据样本分布调整权重。假设 $q$ 为当前像素，$q’$ 为复用像素，论文中将新的 reservoir 中的样本权重使用 $\hat{p}<em>q(r.y)&#x2F;\hat{p}</em>{q’}(r.y)$ 进行调整，采用 [算法 3](#Algo 3) 中的符号得到最终新的权重为 $\hat{p}_q(r.y)\cdot r.W \cdot r.M$。对于任意数量的 reservoir 都可以以这种方式结合，下面是 $k$ 个 reservoir 结合的算法，只有 O(k) 的复杂度：</p><p><a name="Algo 4"></a></p><img src="/images/Paper Notes/Ray Tracing/Spatiotemporal reservoir resampling for real-time ray tracing with dynamic direct lighting.assets/image-20220717215937128.png" alt="image-20220717215937128" style="zoom:50%;"><center>算法 4</center><p>这里新的 reservoir 更新：输入 reservoir 样本，其对应权重根据 $\eqref{discrete PDF}$ 理论上应为 $\Large \frac{\hat{p}_q(r.y)}{p_q(r.y)}$，但 $y$ 的真实分布是未知的，这里使用 $\hat{p}_q(r.y)\cdot r.\textup{W}$ 来近似，$r.M$ 则是为了对不同候选样本数量的 reservoir 的加权。<strong>在复用 reservoir 样本时，新的 reservoir 的 source PDF 就是输入 reservoir 样本的分布，即 $p_y(y)$。</strong></p><p>下面介绍，选用那些像素的 reservoir 来增强当前像素。</p><h3 id="3-2-2-Spatial-Reuse"><a href="#3-2-2-Spatial-Reuse" class="headerlink" title="3.2.2 Spatial Reuse"></a>3.2.2 Spatial Reuse</h3><p>空间复用基于一种观察：相邻像素的 target PDFs 通常存在显著联系，通常具有相似的 Geometry 和 BSDF。因此可以结合相邻像素的 RIS 候选样本来增加自身的 RIS 候选样本数量。</p><p>空间复用相邻像素的 reservoir 的步骤如下：</p><ol><li>使用 [算法 3](#Algo 3) RIS(q) 为每个像素生成 $M$ 个候选样本，并将 reservoir 的结果存储在 image-sized buffer 中。</li><li>每个像素选取 $k$ 个邻居像素，并使用 [算法 4](#Algo 4) 结合 $k$ 个邻居像素的 reservoirs 以及自身的 reservoir。</li></ol><p>每像素的复杂度为 $O(k+M)$，但产生了 $k\cdot M$ 个候选样本。Spatial Reuse 可以重复多次执行，其中每次都是上个 reuse pass 的输出。对于执行了 $n$ 次空间复用迭代，假设每次迭代都复用不同的相邻像素，那么时间复杂度为 $O(kn+M)$，但产生了 $k^n\cdot M$ 个候选样本。</p><p>注意，虽然空间复用可以大幅增多候选样本，即采样率，进而提高图像质量，但这种提升不会随着迭代次数增加而一直增加下去。直至迭代次数多到相邻像素的像素信息被全部利用到，图像质量不再提升。</p><h3 id="3-2-3-Temporal-Reuse"><a href="#3-2-3-Temporal-Reuse" class="headerlink" title="3.2.3 Temporal Reuse"></a>3.2.3 Temporal Reuse</h3><p>上一帧的像素同样可以提供可复用的候选样本。当完成绘制一帧时，将当前帧的像素的 reservoir 结果存入历史帧信息中。在下一帧时利用 motion vector 找到像素的对应关系，复用对应像素的历史 reservoir。</p><h3 id="3-2-4-Visibility-Reuse"><a href="#3-2-4-Visibility-Reuse" class="headerlink" title="3.2.4 Visibility Reuse"></a>3.2.4 Visibility Reuse</h3><p>不幸的是，即使有无限数量的候选样本，RIS 也无法达到无噪声的图像质量。尽管理论上，$M\rightarrow \infty$ 时，reservoir 样本的分布趋向于 target PDF $\hat{p}$，但 $\hat{p}$ 并没有完美采样渲染方程的被积函数。因为，在实际中，$\hat{p}$ 通常设置为了无阴影的 path contribution，当 $M$ 不断增大时，由于 visibility 项噪声会越来越明显，并且 visibility 噪声会表现的非常严重。论文为了解决这一问题，同样对 visibility 进行复用。</p><p>在进行 spatial reuse 或者 temporal reuse 之前，先**对每个像素的 reservoir 选择的样本 $y$ 进行 visibility 评估。如果 $y$ 被遮挡，则丢弃该 reservoir，即被遮挡的样本不会传递给其相邻像素。**visibility 评估需要对当前像素向复用的 reservoir 样本发射 shadow ray。</p><h3 id="3-2-5-完整算法描述"><a href="#3-2-5-完整算法描述" class="headerlink" title="3.2.5 完整算法描述"></a>3.2.5 完整算法描述</h3><p>将上述过程全部考虑进来，得到完整的算法流程：</p><ol><li>首先为每个像素生成 $M$ 个 light candidates，进行重采样，选出最终的样本</li><li>对选出的样本进行 visibility 测试，从中丢弃掉被遮挡的样本</li><li>结合每个像素的 reservoir 和上一帧的对应像素的 reservoir</li><li>执行 $n$ 次空间复用迭代，利用附近 $k$ 个像素的 reservoirs</li></ol><p>算法伪代码如下所示：</p><p><a name="Algo 5"></a></p><img src="/images/Paper Notes/Ray Tracing/Spatiotemporal reservoir resampling for real-time ray tracing with dynamic direct lighting.assets/image-20220717215954040.png" alt="image-20220717215954040" style="zoom:50%;"><h1 id="4-Eliminating-Bias-in-Multi-Distribution-RIS"><a href="#4-Eliminating-Bias-in-Multi-Distribution-RIS" class="headerlink" title="4 Eliminating Bias in Multi-Distribution RIS"></a>4 Eliminating Bias in Multi-Distribution RIS</h1><p>虽然上一部分引入复用样本，提升了图片质量，但由于每个像素都具有不同的积分区域和 target PDF，复用会引入潜在的偏差，导致蒙特卡洛积分成为有偏估计。下面通过分析 RIS 权重，推导出偏差的源头。这里假设所有的候选样本都来自于同一源分布 $p$ 。</p><h2 id="4-1-分析-RIS-权重"><a href="#4-1-分析-RIS-权重" class="headerlink" title="4.1 分析 RIS 权重"></a>4.1 分析 RIS 权重</h2><p>$\eqref{1-sample RIS}$ 式的 1-sample RIS 可以重写为：<br>$$<br>\langle L\rangle^{1,M}<em>{RIS}&#x3D;f(y)\cdot\left(\frac{1}{\hat{p}(y)}\frac{1}{M}\sum\limits^M</em>{j&#x3D;1}\mathrm{w}(x_j)\right)&#x3D;f(y)\mathrm{W}(\boldsymbol{x},z) \tag{9}\label{regroup 1-sample RIS}<br>$$<br>其中 $\boldsymbol{x}&#x3D;{x_1,x_2,\cdots,x_M}$，source PDF 的 $M$ 次独立采样；$\textup{W}$ 是 RIS 选出的样本 $y\equiv x_z$ 对应的权重，挑选过程是随机，可知是个随机变量。</p><blockquote><p>理解 $y$ 与 $(\boldsymbol{x},z)$ 以及 $\textup{W}(\boldsymbol{x},z)$：首先 $(\boldsymbol{x},z)$ 表示从 $M$ 次独立采样得到的 $M$ 个样本中，随机挑选出第 $z$ 个。因此 $\boldsymbol{x}$ 是 $M$ 个独立同分布于 source PDF 的 $M$ 维随机变量，有 $p(\boldsymbol{x})&#x3D;\prod\limits^M_{i&#x3D;1}p_i(x_i)$；$z$ 服从一个离散分布，有 $\eqref{discrete PDF}$ 描述的条件形式。其次 $y$ 是 RIS 算法得到的样本，虽然采样过程已知，但 $y$ 的真实概率密度没有解析形式。但根据 RIS 算法，$y$ 与 $(\boldsymbol{x},z)$ 有关，但对于一个样本 $y$，会有很多种 $(\boldsymbol{x},z)$ 的组合，例如 $x_1&#x3D;y$，$(x_2,\cdots,x_M)$ 随机选择，同理也可以有 $x_2&#x3D;y$，因为 $\boldsymbol{x}$ 是 $M$ 次独立采样，每次采样都有可能得到样本 $y$。</p><p>对于 $\textup{W}$，虽然文中公式形式为 $\textup{W}(\boldsymbol{x},z)$，但实际意义应该是，RIS 采样得到样本 $y$ 时对应的权重，即 $x_z&#x3D;y$ 的权重。换句话说，给定样本 $y$ 时的权重，<strong>权重更精确的形式</strong>是：<br>$$<br>\mathop{\textup{W}}\limits_{x_z&#x3D;y}(\boldsymbol{x},z)&#x3D;\frac{1}{\hat{p}(y)}\frac{1}{M}\sum\limits^M_{j&#x3D;1}\textup{w}(x_j) \tag{10} \label{RIS weight}<br>$$<br>即在 $x_z&#x3D;y$ 的条件下的权重。</p></blockquote><p>首先猜想如何使得 RIS 估计量是个无偏估计？虽然 $y$ 的真实分布是未知的，但根据 $\eqref{IS MC}$ 式的重要性采样理论，这里的 $\textup{W}(\boldsymbol{x},z)$ 需要充当 $1&#x2F;p(y)$ 的作用才能得到无偏估计，注意这里的 $p(y)$ 指的是 $y$ 的真实 PDF，而不是 source PDF，为了区分，我们重写为 $p_y(y)$。 如 $\eqref{RIS weight}$ 式描述，对于给定的 RIS 样本 $y$，可能有很多种 $(\boldsymbol{x},z)$，因此 $\textup{W}(\boldsymbol{x},z)$ 是一个随机变量，要想使得 RIS 无偏，则需要 $\textup{W}(\boldsymbol{x},z)$ 的期望值等于 $1&#x2F;p_y(y)$。</p><p>[算法 4](#Algo 4) 中将多个 reservoir 整合为一个新的 reservoir 时，每个 reservoir 的权重根据 $\eqref{discrete PDF}$ 理论上应为 $\Large \frac{\hat{p}(y)}{p_y(y)}$，而算法 4 使用的近似为 $\hat{p}(y)\cdot \textup{W}$，这里则是用了 $\textup{W}$ 作为 $1&#x2F;p_y(y)$ 的估计量。额外的 $M$ 则是为了对不同候选样本数量的 reservoir 进行的加权。</p><h2 id="4-2-Biased-RIS"><a href="#4-2-Biased-RIS" class="headerlink" title="4.2 Biased RIS"></a>4.2 Biased RIS</h2><p>我们将第 $i$ 次采样所服从分布的概率密度写为 $p_i(x_i)$，候选样本的联合概率密度有<br>$$<br>p(\boldsymbol{x})&#x3D;\prod\limits^M_{i&#x3D;1}p_i(x_i)<br>$$<br>$\eqref{discrete PDF}$ 式中候选样本的概率密度重写为<br>$$<br>p(z|\boldsymbol{x})&#x3D;\frac{\textup{w}<em>z(x_z)}{\sum^M</em>{i&#x3D;1}\textup{w}<em>i(x_i)} \quad where \space \space \textup{w}<em>i(x_i)&#x3D;\frac{\hat{p}(x_i)}{p_i(x_i)}<br>$$<br>候选样本与选取的样本索引 $z$ 的联合概率密度为<br>$$<br>p(\boldsymbol{x},z)&#x3D;p(\boldsymbol{x})\cdot p(z\mid \boldsymbol{x})&#x3D;\left(\prod\limits^M</em>{i&#x3D;1}p_i(x_i)\right)\cdot \frac{\mathrm{w}<em>z(x_z)}{\sum^M</em>{i&#x3D;1}\mathrm{w}<em>i(x_i)} \tag{11} \label{joint PDF}<br>$$<br>对于给定样本值 $y$，可能有非常多的 $(\boldsymbol{x},z)$ 组合，对于采样出值为 $y$ 的样本 $x_i$ 要满足 $p_i(y)&#x3D;p(\boldsymbol{x},i)&gt;0$，因此所有可能情况有：<br>$$<br>Z(y)&#x3D;{i\mid 1\leq i\leq M \wedge p_i(y)&gt;0 } \tag{12} \label{all z}<br>$$<br>因此最终输出 $y$ 的 PDF 可以由 $\eqref{joint PDF}$ 的联合概率密度和 $\eqref{all z}$ 的所有可能取值得到<br>$$<br>p_y(y)&#x3D;\sum\limits</em>{i\in Z(y)}\underbrace{\int\cdots\int}</em>{M-1} p(\boldsymbol{x}^{i\rightarrow y},i) \space \underbrace{dx_1\cdots dx_M}<em>{M-1} \tag{13} \label{y PDF}<br>$$<br>$p(\boldsymbol{x}^{i\rightarrow y},i) $ 是参照 $\eqref{joint PDF}$ 代入 $z&#x3D;i,x_i&#x3D;y$ 得到的 $(x_1,\cdots,x</em>{i-1},y,x_{i+1},\cdots,x_M)$ 的联合概率密度，对每种可能取值下的联合概率密度求 $y$ 的边缘概率密度 $p_i(y)$，并求和得到 $p_y(y)$。</p><p>验证 RIS 是否无偏，需要知道 $\eqref{RIS weight}$ 中描述的权重的期望是否为 $1&#x2F;p_y(y)$，求解其期望如下：<br>$$<br>\mathop{\mathbb{E}}\limits_{x_z&#x3D;y}\left[\textup{W}(\boldsymbol{x},z)\right]&#x3D;\frac{1}{p_y(y)}\frac{|Z(y)|}{M} \tag{14} \label{weight expectation}<br>$$<br>由 $\eqref{all z}$ 可知，<strong>只有在所有候选样本分布都不为 0 时，上式的权重期望才为 $1&#x2F;p_y(y)$，RIS 才是无偏的</strong>。</p><p>如果部分积分区域上的 source PDF 为 0，则有 $\large\frac{|Z(y)|}{M} &lt; 1$， 此时，重要性采样的 inverse PDF 会偏小，积分结果会偏小，带来能量损失。</p><h2 id="4-3-Unbiased-RIS"><a href="#4-3-Unbiased-RIS" class="headerlink" title="4.3 Unbiased RIS"></a>4.3 Unbiased RIS</h2><p>上一节给出了 RIS 有偏的情况，即会有部分样本的 source PDF 为 0。这是由于 visibility 项导致的，我们在复用其他像素的 reservoir 时，并没有考虑这些 reservoir 样本是否对当前像素可见。同样，在执行 [算法 3](#Algo 3) streaming RIS 时，会根据 shadow ray 丢弃掉部分不可见候选样本，但在复用阶段，这些被丢弃的样本可能对当前像素是可见的，这就损失了部分能量。</p><p>因此若想得到无偏 RIS 则需要对 $\eqref{RIS weight}$ 和 $\eqref{weight expectation}$ 的候选样本的总数 $M$ 进行调整，调整为当前像素可见的候选样本总数，设置 $m(x_z)&#x3D;\frac{1}{M}$，新的权重及其期望形式为<br>$$<br>\begin{align}<br>\mathop{\textup{W}}\limits_{x_z&#x3D;y}(\boldsymbol{x},z)&amp;&#x3D;\frac{1}{\hat{p}(x_z)}\left[m(x_z)\sum\limits^M_{j&#x3D;1}\textup{w}(x_j)\right] \<br>\mathop{\mathbb{E}}\limits_{x_z&#x3D;y}\left[\textup{W}(\boldsymbol{x},z)\right]&amp;&#x3D;\frac{1}{p_y(y)}\sum\limits_{i\in Z(y)}m(x_z)<br>\end{align}<br>$$<br>因此当 $\sum\limits_{i\in Z(y)}m(x_z)&#x3D;1$ 时，RIS 为无偏估计。如何保证这一条件？</p><h2 id="4-4-A-Practical-Algorithm-for-Unbiased-Reuse"><a href="#4-4-A-Practical-Algorithm-for-Unbiased-Reuse" class="headerlink" title="4.4 A Practical Algorithm for Unbiased Reuse"></a>4.4 A Practical Algorithm for Unbiased Reuse</h2><p>本文使用光源分布作为 source PDF，候选样本以及选出的 reservoir 样本都是光源面上一点。并且对于直接光照采样，只会采样着色点可见光源，即 $\eqref{weight expectation}$ 中使用的候选样本分布都不为 0，因此对于初始候选样本重采样的过程是无偏的。但对于reservoir 重用过程，新的 reservoir 的 source PDF 变成了，每个 reservoir 样本的分布，这个是未知的，因此重用过程的 source PDF 可能互不相同。重用过程引入 bias 的原因是：尽管复用 reservoir 对其像素可见，但对于当前像素可能不可见，这就导致了新 reservoir 的部分 source PDF 为 0，为 $\eqref{weight expectation}$ 引入了 bias。</p><p>论文中提出一种无偏 RIS 算法，该算法基于一种观察：尽管复用 reservoir 样本 PDF (即新 reservoir 的 source PDF)不可知，但当样本对当前像素不可见时，其 PDF 为 0。因此可以在复用 reservoir 样本之前，先进行 visibility 测试，如果不可见，设置其 PDF 为 0，即丢弃掉该样本，也就是 visibility reuse。相比有偏算法，无偏算法开销很大，因为需要对每个复用 reservoir 样本发射一条 shadow ray。</p><h1 id="5-Design-and-Implementation"><a href="#5-Design-and-Implementation" class="headerlink" title="5 Design and Implementation"></a>5 Design and Implementation</h1><p>作者为有偏与无偏算法选用不同的参数配置，以达到两种算法的开销近似。</p><p><strong>$M&#x3D;32$ 个初始候选样本的生成</strong>：根据三角面片发光的 power 重要性采样选择一个三角形，然后在三角形上均匀采样一个点 $x$，即 source PDF $p(X)\propto L_e(x)$。如果有环境光贴图，那么 25% 的候选样本由重要性采样环境光贴图生成。重要性采样发光三角形与环境光贴图都是离散采样，采用 alias table <a href="#%5B2%5D">[2]</a>。同时，作者也测试了通过预计算为场景的发光三角形生成 VPL 集合，虽然能够提高性能，但有 visual artifact。</p><p><strong>Target PDF</strong>：在重采样步骤中，需要 target PDF 对选出的样本进行加权，作者使用 unshadowed path contribution 作为 target PDF，即 $\hat{p}\propto \rho\cdot L_e\cdot G$。作者为场景所有几何使用统一的材质，Lambertian diffuse 和 dielectric  GGX microfacet 。而对于复杂的材质模型，为每个候选样本计算会更耗时。</p><p><strong>Neighbor Selection</strong>：对于 Spatial Reuse，在 30-pixel 半径范围内采样 $k$ 个像素进行复用，无偏选用 $k&#x3D;3$，有偏选用 $k&#x3D;5$。对于 Temporal Reuse，则使用 motion vector 找到历史帧对应的像素。</p><p><strong>Biased RIS 降低偏差</strong>：对于有偏算法，重用来自不同几何&#x2F;材质的像素会增加偏差，因此作者使用一种简单的启发式策略拒绝这部分像素。比较重用像素与当前像素的到相机距离、normal 夹角，拒绝超过预设阈值的像素(10% 当前像素的深度和 25°)。</p><p><strong>Evaluated Sample Count</strong>：对于 [算法 5](#Algo 5) ，每个像素存储 $N$ 个 reservoir，无偏算法采用 $N&#x3D;1$，有偏算法采用 $N&#x3D;4$。</p><p><strong>Reservoir storage and temporal weighting</strong>：每个像素只存储选出的样本 $y$ 及其权重 $W$，候选样本的数量 $M$。对于 temporal reuse，对当前像素产生贡献的候选样本数量会无限制增加，因为每一帧都结合了历史帧的 reservoir。在重采样过程中，这样会导致 temporal sample 加权高度不成比例，作者将历史帧的候选样本数量限制在当前帧 $20\times M$ 内，这样就限制了时序信息的影响。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a name="[1]">[1]</a> Benedikt Bitterli, Chris Wyman, Matt Pharr, Peter Shirley, Aaron Lefohn, and Wojciech Jarosz. 2020. Spatiotemporal reservoir resampling for real-time ray tracing with dynamic direct lighting. <i>ACM Trans. Graph.</i> 39, 4, Article 148 (August 2020), 17 pages. DOI:<a href="https://doi.org/10.1145/3386569.3392481">https://doi.org/10.1145/3386569.3392481</a></p><p><a name="[2]">[2]</a> Alastair J Walker. 1974. New fast method for generating discrete random numbers with arbitrary frequency distributions. Electronics Letters 10, 8 (1974), 127–128.  </p><h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><h2 id="1-重要性采样为何要到-Resample-Importance-Sampling"><a href="#1-重要性采样为何要到-Resample-Importance-Sampling" class="headerlink" title="1. 重要性采样为何要到 Resample Importance Sampling"></a>1. <a name="App 1">重要性采样为何要到 Resample Importance Sampling</a></h2><p>蒙特卡洛积分估计理论上是进行越多的采样次数，越接近 groud-truth，但实际中要限制开销，只能以有限的采样次数来进行积分估计。因此，采样分布如果能够更倾向于采样被积函数较重要的区域，则会更快达到收敛，这就是重要性采样 (IS) 的思想。$\eqref{IS MC}$ 式描述的重要性采样(IS)是蒙特卡洛积分的最简单的无偏估计，因为 IS 只采样了一种分布，例如 cosine-weighted sample hemisphere 就是根据渲染方程 cosine 项的特征得到的采样方法。</p><p>但通常渲染方程被积函数包含多项，如 $\eqref{simple render equation}$ 中的 $\rho,L_e,G$ 等。于是又有了，$\eqref{MIS MC}$ 式描述的多重重要性采样，MIS 使用了多种采样策略，每种采样策略都进行了一次重要性采样，最后将多次重要性采样结合在一起。虽说，MIS 考虑了多种分布，但其估计量形式相当于是<strong>对多种分布的线性组合</strong>，而对于渲染方程而言，其被积函数是多项的乘积形式，因此不能更好地采样被积函数的重要性区域。</p><p>对于多种分布的乘积形式，是无法直接采样的。但可以使用 Resample Importance Sampling(RIS) $\eqref{1-sample RIS}$ 来近似成比例地采样多种分布乘积形式。</p><h2 id="2-RIS-权重期望"><a href="#2-RIS-权重期望" class="headerlink" title="2. RIS 权重期望"></a>2. RIS 权重期望</h2><p>$$<br>\begin{align}<br>\mathop{\mathbb{E}}\limits_{x_z&#x3D;y}\left[\textup{W}(\boldsymbol{x},z)\right]&amp;&#x3D;\underbrace{\int \cdots \int}<em>M\frac{ \textup{W}(\boldsymbol{x},z,x_z&#x3D;y)\cdot p(\boldsymbol{x},z,x_z&#x3D;y)}{p_z(x_z&#x3D;y) \space } \space dx_1\cdots dx_Mdz \<br>&amp;\overset{\eqref{y PDF}}{&#x3D;}\sum\limits</em>{i\in Z(y)}\underbrace{\int\cdots\int}<em>{M-1} \frac{ \textup{W}(\boldsymbol{x}^{i\rightarrow y},i)\cdot p(\boldsymbol{x}^{i\rightarrow y},i)}{p_y(y) } \space dx_1\cdots dx_M \<br>&amp;&#x3D; \sum\limits</em>{i\in Z(y)} \frac{\underbrace{\int\cdots\int}<em>{M-1} \textup{W}(\boldsymbol{x}^{i\rightarrow y},i)\cdot p(\boldsymbol{x}^{i\rightarrow y},i)\space dx_1\cdots dx_M}{p_y(y)} \<br>&amp;&#x3D; \frac{1}{p_y(y)}\cdot \sum\limits</em>{i\in Z(y)} \underbrace{\int\cdots\int}<em>{M-1} \textup{W}(\boldsymbol{x}^{i\rightarrow y},i)\cdot p(\boldsymbol{x}^{i\rightarrow y},i)\space dx_1\cdots dx_M \<br>&amp;\overset{代入 \eqref{RIS weight},\eqref{joint PDF}}{&#x3D;}  \frac{1}{p_y(y)}\sum\limits</em>{i\in Z(y)}\int\cdots\int \left(\frac{1}{\hat{p}(x_i)}\frac{1}{M}\sum\limits^M_{j&#x3D;1}\textup{w}(x_j)\right) \left(\prod\limits^M_{j&#x3D;1}p_j(x_j)\right) \frac{\textup{w}<em>i(x_i)}{\sum^M</em>{j&#x3D;1}\textup{w}<em>j(x_j)} \space dx_1\cdots dx_M \<br>&amp;&#x3D; \frac{1}{p_y(y)}\sum\limits</em>{i\in Z(y)}\int\cdots\int \left(\frac{1}{\hat{p}(x_i)}\frac{1}{M}\right) \left(\prod\limits^M_{j&#x3D;1}p_j(x_j)\right) \textup{w}<em>i(x_i) \space dx_1\cdots dx_M \<br>&amp;&#x3D; \frac{1}{p_y(y)}\sum\limits</em>{i\in Z(y)}\left(\frac{p_i(x_i)}{\hat{p}(x_i)}\frac{\textup{w}<em>i(x_i)}{M}\underbrace{\int\cdots\int \prod\limits^M</em>{j\neq i}p_j(x_j) \space dx_1\cdots dx_M}<em>1\right) \<br>&amp;&#x3D;\frac{1}{p_y(y)}\sum\limits</em>{i\in Z(y)}\left(\frac{p_i(x_i)}{\hat{p}(x_i)}\frac{\textup{w}<em>i(x_i)}{M}\right) \<br>&amp;&#x3D; \frac{1}{p_y(y)}\sum\limits</em>{i\in Z(y)}\frac{1}{M} \<br>&amp;&#x3D; \frac{1}{p_y(y)}\frac{|Z(y)|}{M}<br>\end{align}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>Paper Notes</category>
      
      <category>Ray Tracing</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Texel Shading</title>
    <link href="/2023/09/20/Paper%20Notes/Render%20Pipeline/Texel%20Shading/"/>
    <url>/2023/09/20/Paper%20Notes/Render%20Pipeline/Texel%20Shading/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Summary"><a href="#1-Summary" class="headerlink" title="1 Summary"></a>1 Summary</h1><p>传统的光栅化管线着色（forward&#x2F;deferred）是基于屏幕空间像素的着色过程，由于光栅化流水线作业的限制，shading rate完全由分辨率、几何复杂度、帧率控制。而本文提出的texel shading管线将着色转化为texture space的任务，并将着色结果cache在texture space，最终的着色通过采样cache完成。</p><p>基于texture space的着色将shading rate与分辨率、几何复杂度、帧率解耦，可以每像素调整shading rate，变得更加可控。同时texture space下对于时空复用类算法更加友好。概况地讲，texture space shading(TSS)的提出主要有如下动机：</p><ol><li>可控的表面像素采样率。对于远处高光的小物体，相机的运动会导致非常不稳定的效果。例如，从正对着表面运动到grazing视角，表面变得更加高频，而采样率不足。TSS的着色受相机视角影响较小。</li><li>更加准确的帧间复用。不同的观察位置、角度下，相邻帧之间的表面像素的不匹配程度较高，例如可能处于不同的mip level。传统光栅化管线在时序上的复用难以考虑这一点，而TSS着色结果cache在texture space，时序连续性较高。</li><li>更加准确的空间复用。屏幕空间的像素之间暴露出incoherent性质，这对于空间复用很不友好。而texture space下，相邻像素往往满足世界空间的coherent。</li></ol><h1 id="2-Pipeline设计"><a href="#2-Pipeline设计" class="headerlink" title="2 Pipeline设计"></a>2 Pipeline设计</h1><p>texel shading的前提是使用某种参数化方式将场景的mesh统一到唯一的texture space下，即每一个surface point都具有唯一的texture坐标。这种参数化方式在TSS技术中也是一大问题，本文未做这方面的详细调研。texel shading管线共包含三个阶段：</p><ol><li><strong>Shade Queuing</strong>：使用一个geometry pass来标记需要着色的texel tiles(8x8)，每个texel tile作为着色任务。再新增着色任务前会先查询cache中是否已存在。</li><li><strong>Shade Evaluation</strong>：compute shader中提取着色任务需要的顶点属性，并生成着色结果到cache texture中。</li><li><strong>Shade Gathering</strong>：再执行一次geometry pass，从cache texture中收集着色结果，得到最终屏幕着色。</li></ol><h2 id="2-1-预处理"><a href="#2-1-预处理" class="headerlink" title="2.1 预处理"></a>2.1 预处理</h2><p>为了能够在compute shader中得到几何信息，还需要在预处理阶段生成triangle index texture，即texture space下纹理坐标到triangle ID的映射。</p><p><strong>实现设计</strong>：对整个texture space分辨率进行一次光栅化即可得到triangle index texture。</p><h2 id="2-2-Shade-Queuing"><a href="#2-2-Shade-Queuing" class="headerlink" title="2.2 Shade Queuing"></a>2.2 Shade Queuing</h2><p>本阶段通过geometry pass为每个像素生成texel单位的shade任务，并选择合适的mip level。通过一张cache texture来缓存每个8x8 tile的状态，例如最近更新的帧数，可以控制tile的更新频率。8x8 tile的shade任务生成算法如下：</p><img src="/images/Paper Notes/Render Pipeline/Texel Shading.assets/image-20230703182339279.png" alt="image-20230703182339279" style="zoom: 50%;"><blockquote><p>算法：geometry pass生成的texel任务(i, j, L)转为 8x8 tile任务(i&#x2F;8. j&#x2F;8, L-3)。一个L-3级别上的8x8 tile可以计算得到一个L的texel。</p></blockquote><p>这里可以看出控制shading rate的方式有：</p><ul><li>tile的更新频率阈值（多少帧更新一次）</li><li>texel的mip level越大，意味着越少数量的texel，一个texel可以覆盖多个像素，这适用于低频区域。</li></ul><p><strong>实现设计</strong>：</p><ul><li>geometry pass需要对带纹理坐标的几何进行光栅化，得到每个像素的纹理坐标、以及重心坐标。</li><li>cache texture：从算法实现上看，cache texture应该是N-3层级的贴图，给定shade texel(i, j, L)，其在cache中的坐标为(i&#x2F;8, j&#x2F;8, L-3)。cache texture的texel是对应tile的状态信息：<ul><li>上一次更新的帧数</li><li>bias配置：提高mip level来减少shade texel</li></ul></li><li>如果在本阶段的geometry pass中计算的mip level向上取整，一个8x8 tile的着色可以在Shade Gathering阶段做到三线性插值。</li></ul><h2 id="2-3-Shade-Evaluation"><a href="#2-3-Shade-Evaluation" class="headerlink" title="2.3 Shade Evaluation"></a>2.3 Shade Evaluation</h2><p>本阶段执行于compute shader，每个thread group执行一个8x8 tile。通过texel的纹理坐标从triangle index texture得到当前triangle ID，并根据此ID得到triangle数据。使用texel的重心坐标进行插值得到texel的顶点数据。之后便可以按照传统渲染的方式对texel着色。</p><h2 id="2-4-Shade-Gathering"><a href="#2-4-Shade-Gathering" class="headerlink" title="2.4 Shade Gathering"></a>2.4 Shade Gathering</h2><p>此时，cache中已经有了屏幕着色需要的所有数据。再执行一次geometry pass得到对应level的texel着色。</p>]]></content>
    
    
    <categories>
      
      <category>Paper Notes</category>
      
      <category>Render Pipeline</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Texture Space Shading</title>
    <link href="/2023/09/20/Paper%20Notes/Render%20Pipeline/Texture%20Space%20Shading/"/>
    <url>/2023/09/20/Paper%20Notes/Render%20Pipeline/Texture%20Space%20Shading/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Summary"><a href="#1-Summary" class="headerlink" title="1 Summary"></a>1 Summary</h1><p>传统的光栅化管线（forward或者deferred）执行于屏幕空间，表面采样率或者像素密度与相机距离、视角相关。同时，GPU光栅化管线的流水线作业使得shading rate完全由分辨率、几何复杂度、帧率控制。而texture space shading(TSS)提出在texture space着色，使得shading rate变得更加可控。同时texture space下的texel着色具有更优的spatial coherent以及temporal coherent，这对于时空复用类算法更加友好。</p><p>概况地讲，TSS的提出主要有如下动机：</p><ol><li>可控的表面像素采样率。对于远处高光的小物体，相机的运动会导致非常不稳定的效果。例如，从正对着表面运动到grazing视角，表面变得更加高频，而采样率不足。TSS的着色受相机视角影响较小。</li><li>更加准确的帧间复用。不同的观察位置、角度下，相邻帧之间的表面像素的不匹配程度较高，例如可能处于不同的mip level。传统光栅化管线在时序上的复用难以考虑这一点，而TSS着色结果cache在texture space，时序连续性较高。</li><li>更加准确的空间复用。屏幕空间的像素之间暴露出incoherent性质，这对于空间复用很不友好。而texture space下，相邻像素往往满足世界空间的coherent。</li></ol><h1 id="2-Category"><a href="#2-Category" class="headerlink" title="2 Category"></a>2 Category</h1><p>本文按照 <a href="#%5B1%5D">[1]</a> 给出的分类方法描述TSS的相关工作，以及设想中的大致实现思路。</p><p>![image-20230628191733254](&#x2F;images&#x2F;Paper Notes&#x2F;Render Pipeline&#x2F;Texture Space Shading.assets&#x2F;image-20230628191733254.png)</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a name="[1]">[1]</a> Neff, T., Mueller, J.H., Steinberger, M. and Schmalstieg, D. (2022), Meshlets and How to Shade Them: A Study on Texture-Space Shading. Computer Graphics Forum, 41: 277-287. <a href="https://doi.org/10.1111/cgf.14474">https://doi.org/10.1111/cgf.14474</a></p>]]></content>
    
    
    <categories>
      
      <category>Paper Notes</category>
      
      <category>Render Pipeline</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Glossy Probe Reprojection for Interactive Global Illumination</title>
    <link href="/2023/09/20/Paper%20Notes/GI/Glossy%20Probe%20Reprojection%20for%20Interactive%20Global%20Illumination/"/>
    <url>/2023/09/20/Paper%20Notes/GI/Glossy%20Probe%20Reprojection%20for%20Interactive%20Global%20Illumination/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Summary"><a href="#1-Summary" class="headerlink" title="1 Summary"></a>1 Summary</h2><p><code>Glossy Probe Reprojection for Interactive Global Illumination  </code> <a href="#%5B8%5D">[8]</a></p><p>这篇论文提出了一种基于 light probe 思想的实时全局光照算法，高效解决带有 glossy 路径的全局光照问题。light probe 思想在场景中放置多个 light probe，每个 light probe 包含了该位置的间接光照信息，这些信息通过预计算过程存入 light probe，并用于在实时渲染过程中计算着色点的全局光照。本论文提出自适应的 probe 参数化，通过评估不同角度、不同位置的几何信息，自适应不同情况所需要的 probe 分辨率，用以缓解 glossy 全局光照带来的高内存消耗问题。在实时渲染中提出基于 specular path perturbation 的间接光反射点估计方法，高效 reproject glossy path 信息到实时的 novel view space，进而收集到实时全局光照信息。同时论文改善了 occlusion boundaries 附近出现的硬边界问题，通过预计算过程中降低几何 roughness 来预计算 probe data，以收集到更大范围的全局光照信息，在实时渲染中设计 filter 重构原 roughness，达到硬边界的平滑过渡。</p><h2 id="2-Background"><a href="#2-Background" class="headerlink" title="2 Background"></a>2 Background</h2><h3 id="2-1-Light-Probe"><a href="#2-1-Light-Probe" class="headerlink" title="2.1 Light Probe"></a>2.1 Light Probe</h3><ul><li><p><input disabled type="checkbox"> light probe 算法思想</p></li><li><p><input disabled type="checkbox"> 基于 3D-grid 的 light probe <a href="#%5B1%5D">[1]</a></p></li></ul><h2 id="3-Approach"><a href="#3-Approach" class="headerlink" title="3 Approach"></a>3 Approach</h2><h3 id="3-1-Probe-预计算"><a href="#3-1-Probe-预计算" class="headerlink" title="3.1 Probe 预计算"></a>3.1 Probe 预计算</h3><p>Probe 中存储实时渲染过程中需要使用的全局光照信息，通过 path-tracer 计算得到。glossy BRDF 需要较多的采样才能得到平滑的着色，如果在整个场景中的每个 probe 的所有方向都收集同样多样本的信息，会使得 probe 数据存储消耗过大。因此作者提出 adaptive probe resolution，即根据不同位置、不同视角观察到的几何信息来评估该位置需要的 probe resolution，高分辨率对应高样本数，低分辨率对应低样本数。先介绍一下本论文使用的 probe data 存储的数据</p><h4 id="3-1-1-Per-Probe-Data"><a href="#3-1-1-Per-Probe-Data" class="headerlink" title="3.1.1 Per Probe Data"></a>3.1.1 Per Probe Data</h4><p>预计算过程中，为每个 Probe 生成数据，包含三张贴图，如下图所示：</p><p><img src="/images/Paper Notes/GI/Glossy Probe Reprojection for Interactive Global Illumination.assets/image-20220717214054549.png" alt="image-20220717214054549" style="zoom:50%;"><img src="/images/Paper Notes/GI/Glossy Probe Reprojection for Interactive Global Illumination.assets/image-20220717214112108.png" alt="image-20220717214112108" style="zoom:50%;"><img src="/images/Paper Notes/GI/Glossy Probe Reprojection for Interactive Global Illumination.assets/image-20220717214125605.png" alt="image-20220717214125605" style="zoom:50%;"></p><ul><li><p>(a) 可见的三角形信息(三角形 ID、重心坐标)</p></li><li><p>(b) probe 空间的环境贴图(只存储 glossy BRDF 计算的颜色值)</p></li><li><p>(c) 将每个面视为镜面，记录完美反射过程中的几何信息(反射点、及其材质 ID)</p></li></ul><p>这三张贴图都是 360 度贴图，将 probe 作为相机，贴图中每个 texel 存储的是不同角度看向场景得到的信息，即 probe view 下的渲染信息。</p><h4 id="3-1-2-Probe-Parameterization"><a href="#3-1-2-Probe-Parameterization" class="headerlink" title="3.1.2 Probe Parameterization"></a>3.1.2 Probe Parameterization</h4><p>对于有限的内存消耗，probe 数量是有限的，这篇论文提出的 adaptive probe resolution 是为了将更多地 probe resolution 分配到需要高采样的区域(因为同样的 fov 下，probe 数据的分辨率越高，包含采样的样本越多)。作者设计了一种 probe 需求的评估策略，评估结果为一个方向看到的场景所需的 probe resolution 参数。根据评估得来的 probe resolution 不断调整 probe 对应 3D grid 的等划分网格，最终达到网格大小与 probe resolution 相匹配，即 probe resolution 越大，网格越大。对网格中像素对应的场景角度，使用 path tracer 计算 probe 离线数据。</p><p><strong>如何确定什么情况需要较高的 probe resolution 或较低的 probe resolution？</strong></p><ul><li>a) 因为光滑表面频率信息较高，因此越光滑的表面需要越高的分辨率，反之粗糙的材质频率较低，需要较少的样本</li><li>b) 远距离表面或者 grazing 角度看到的表面需要较高的分辨率</li><li>c) 高频几何(法线)信息在 reflected radiance 上表现出很大的变化，因此需要较高的分辨率。</li></ul><p>根据上述要求，论文使用 lat-long (相当于球坐标) 对 probe 分辨率参数化。在 probe view space 中，计算每个角度对应的 probe resolution 参数，并存储到 adaptive resolution map 中。lat-long 参数化易于确定 adaptive resolution map 的每个像素对应的 ray direction，方便 probe data预计算过程的 ray-tracing。</p><h5 id="3-1-2-1-Adaptive-Resolution-Map-计算"><a href="#3-1-2-1-Adaptive-Resolution-Map-计算" class="headerlink" title="3.1.2.1 Adaptive Resolution Map 计算"></a>3.1.2.1 Adaptive Resolution Map 计算</h5><p>一个 Adaptive resolution map 的元素表示 probe 每个方向对应的 probe resolution 参数。计算该 Map 前先使用以 probe 出发的 ray casting 构建 4 个 256x128 的 buffers，(i) 材质 smoothness $\large m_{mat}$，(ii) 深度值 $\large m_{depth}$，(iii) 法线 $\large m_{norm}$，(iv) facing angle $\large m_{face}$ (入射光方向与表面法线点乘)。</p><p>Adaptive resolution map 的元素计算：</p><p>$$<br>m&#x3D;m_{mat}(m_{size}+m_{complexity})<br>$$<br>可以看出 </p><ul><li><p>$m_{mat}$​ 满足了 a)，越光滑 $m_{mat}$​ 越大，得到的分辨率参数 $m$​ 也越大；</p></li><li><p>$m_{size}$​​​​ 考虑了 b) 中距离与角度的要求，其计算为<br>            $$<br>            m_{size}&#x3D;\frac{m^2_{depth}}{m_{face}}\cos(\theta_{long})<br>$$</p><blockquote><p> depth 越大，表面面积相对越小，对应较大的 $m$​；$m_{face}$​​ 越小，表示入射光与 normal 夹角越大，越 grazing，对应较大的 $m$</p></blockquote><ul><li><input disabled type="checkbox"> 不明白：This term converts probe area to actual object size, compensating for perspective and angular foreshortening akin to a form factor. $\theta_{long}$ is the longitude angle, which compensates for size variations induced by the lat-long base parameterization.</li></ul></li><li><p>要求 c) 需要对局部几何复杂度分析，作者使用频率分析代替：<br>   $$<br>   m_{complexity}&#x3D;\frac{1}{N^2}\sum\limits^{N-1}<em>{p&#x3D;0}\sum\limits^{N-1}</em>{q&#x3D;0}w_{p,q}||\mathbf{b}<em>{p,q}*m</em>{norm}||_1<br>   $$</p><ul><li><input disabled type="checkbox"> 2D Discrete consine transform <a href="#%5B2%5D">[2]</a>: $\mathbf{b}$​ 是 basis function，basis function 与 法线的卷积用来分析 local neighborhood 的频率信息</li></ul><p>   $w_{p,q} &#x3D;||[p,q]||^k$ 权重用来确保高频对几何复杂度贡献更高，论文中取 $N&#x3D;16,k&#x3D;5$。</p></li></ul><p>$m_{size}$ 和 $m_{complexity}$ 使用均值经过归一化。</p><p>上述 Adaptive Resolution Map 只是计算了 probe 在不同方向上的分辨率参数，但这个参数只是相对分辨率，反应不同方向上分辨率的大小关系，而不是真正的分辨率。接下来需要根据这个相对分辨率参数，进行对 probe 真正分辨率的参数化。</p><h5 id="3-1-2-2-Adaptive-Parameterization"><a href="#3-1-2-2-Adaptive-Parameterization" class="headerlink" title="3.1.2.2 Adaptive Parameterization "></a>3.1.2.2 Adaptive Parameterization <a name="1.2.2"></a></h5><p>本小节，作者使用 tensorial quasi-harmonic maps <a href="#%5B3%5D">[3]</a>，将 adaptive resolution map 转为 adapted resolution。转换过程如下：</p><ul><li><input disabled type="checkbox"> 需要理解 <a href="#%5B3%5D">[3]</a> 的数学原理，描述下面过程的细节</li></ul><ol><li>将每个 proble 对应的 3D grid 进行离散等划分，得到均分的四边形网格 quad mesh (应该是 3D grid 的六面划分成 四边形网格)，并且 adaptive resolution map 中每一个元素对应一个 quad mesh。</li><li>根据 adaptive resolution map ，求解 quasi-harmonic equation ，得到 forward flow map。</li><li>forward flow map 指示如何调整 quad mesh 的顶点，不断对 quad mesh 变形，最终达到与 apaptive resolution map 相一致的参数化。probe 对应的 3D  grid 最终变形为如图 [Fig. 1.2.2(h)](#Fig. 1.2.2) 所示。</li></ol><p>至此，变形的 quad mesh 达到与 adaptive resolution map 描述一致的 adaptive resolution，即 adaptive resolution map 较大的元素对应较大的网格，较小的元素对应较小的网格。下面就需要计算不同分辨率的 probe data，即对网格的每个像素进行 path-tracing 计算 probe data。但由于变形，这里的像素位置已经不能确定 path-tracing 的光线方向，即像素的 view vector。作者将 forward flow map 进行求逆，得到 inverse flow map，这样就可以确定像素真正的 view vector。</p><p><a name="Fig. 1.2.2"></a></p><img src="/images/Paper Notes/GI/Glossy Probe Reprojection for Interactive Global Illumination.assets/image-20220717214426137.png" alt="image-20220717214426137" style="zoom: 67%;"><center>Fig. 1.2.2</center><p>全局光照包含两个组成成分 glossy 和 diffuse：glossy 成分存储在 probe 数据中，在计算 probe 时，path-tracer 计算 glossy BRDF；Diffuse 成分与 view 视角无关(view-independent)，因此存储在传统的 lightmap 中。</p><h4 id="3-1-3-Geometric-Information"><a href="#3-1-3-Geometric-Information" class="headerlink" title="3.1.3 Geometric Information"></a>3.1.3 Geometric Information</h4><p>上一小节完成了 probe 中包含的全局光照信息的预计算，但 probe 贴图数据中包含的是 360° 视角的全局信息，在实时渲染中，需要确定当前着色点需要哪些 probe 数据的样本。对于此，作者使用 specular path perturbation 的方法，这个在之后章节阐述，但该方法需要几何面的导数信息。</p><p>因此本小节预计算场景几何信息，估计场景中每个顶点的主曲率，以此将 mesh 近似为具有解析表达式形式的抛物面，这样的抛物面可以高效计算出其高阶导，用于实时渲染中收集 probe 样本的 glossy light 信息。过程如下：</p><ol><li><ul><li><input disabled type="checkbox"> 对于每个顶点，使用 <a href="#%5B4%5D">[4]</a> 技术估计其主曲率与对应方向 [Fig 1.3(a)](#Fig 1.3)。该步骤在每个物体上分别进行，并且为了更好的结果，对较大表面，先进行细分 [Fig 1.3(b d)](#Fig 1.3)。</li></ul></li><li>计算来的主曲率可以以曲率方向为坐标轴将物体表面局部表示为具有解析表达式的抛物面 [Fig 1.3(c)](#Fig 1.3)，该解析表达式方便后续高效计算其高阶导。</li></ol><p><a name="Fig 1.3"></a></p><p><img src="/images/Paper Notes/GI/Glossy Probe Reprojection for Interactive Global Illumination.assets/image-20220717214455780.png" alt="image-20220717214455780" style="zoom:67%;"><img src="/images/Paper Notes/GI/Glossy Probe Reprojection for Interactive Global Illumination.assets/image-20220717214514069.png" alt="image-20220717214514069" style="zoom:67%;"></p><center>Fig 1.3</center><p>至此，预计算部分已经结束，下面开始实时渲染。</p><h3 id="3-2-Rendering-Global-Illumination"><a href="#3-2-Rendering-Global-Illumination" class="headerlink" title="3.2 Rendering Global Illumination"></a>3.2 Rendering Global Illumination</h3><p>上述预计算的数据都是 probe view 下的光照信息，实时渲染中则需要将 probe view 重投影为 novel view 下所需要的全局光照信息。全局光照信息包含 diffuse 与 glossy 光照信息，对于 diffuse 全局光照，直接采样预计算的 lightmap。而 glossy 成分则需要对 light probe 重投影到 novel view。</p><p>glossy 光线路径的全局光照渲染概要：</p><ol><li><p>需要将预计算的 light probe 进行重投影(reprojection)。为此，先光栅化一个 G-buffer，其中包含 position、normal、表面曲率和材质(ID和roughness)。</p></li><li><p>使用 ray-caster，发射光线到 specular pixels(应该指把像素看作 specular)，再经过完美镜面反射。ray data 中存储反射光的 hit position 和对应的材质 IDs。</p></li><li><p>之后基于像素附近收集的 probes 信息来计算像素的 glossy 光照信息。</p><ul><li><p>选择距离着色点最近的 probe(最终方案为最近的 8 个)，确定 probe data 中与当前像素关联的 sample：计算 probe 经过镜面反射最终到达 ray data 中的 hit position 的反射点，probe data 中该反射点对应的 sample 即包含了着色像素的 glossy GI 信息。(因为 camera -&gt; shading point -&gt; hit position -&gt; specular reflected position -&gt; probe 正好形成了一条带有间接光照的光线路径，前三个是一个镜面反射路径(从 ray data 中获取)，后三个是一个镜面反射路径(由选定的 probe 位置计算得到))。 </p><blockquote><p>如图 [Fig 2(a)](#Fig 2) 所示，光线路径为 $\mathbf{p}\rightarrow \mathbf{x} \rightarrow \mathbf{q} \rightarrow \mathbf{x’} \rightarrow \mathbf{p’}$​，其中 $\mathbf{x}$ 为像素对应的着色点，$\mathbf{q}$ 为经过镜面反射的 hit position(存储在 ray data 中)，$\mathbf{p’}$ 为​挑选的 probe，$\mathbf{x’}$ 为由 $\mathbf{p’}$ 与 $\mathbf{q}$​ 作为镜面反射路径端点计算得到。 </p></blockquote></li><li><p>基于一种设计的评估策略，在反射点对应的 probe sample 附近搜索选择最优的 probe sample，即为最终用来计算着色点 GI 的 sample。</p></li></ul></li></ol><p><a name="Fig 2"></a></p><img src="/images/Paper Notes/GI/Glossy Probe Reprojection for Interactive Global Illumination.assets/image-20220717214548051.png" alt="image-20220717214548051" style="zoom:67%;"><center>Fig 2</center><p>由上述可知，想要收集 probe samples 信息，必须先知道反射点 $\mathbf{x’}$ 的位置。虽然可以再次使用 ray-caster，但为了高效，作者引入 specular path perturbation 方法。</p><h4 id="3-2-1-On-the-fly-Reflection-Position-Estimation"><a href="#3-2-1-On-the-fly-Reflection-Position-Estimation" class="headerlink" title="3.2.1 On-the-fly Reflection Position Estimation"></a>3.2.1 On-the-fly Reflection Position Estimation</h4><p>当相机由 $\mathbf{p}$​​​ 移动到 $\mathbf{p’}$​​​ 时，作者基于 specular path perturbation 理论来确定 $\mathbf{x}$​​​ 移动到的位置 $\mathbf{x’}$​​​。这样的移动描述的其实是镜面反射路径$\mathcal{S}_1$​​​($p\rightarrow x\rightarrow q$​​​) 到 $\mathcal{S}_2$​​​($p’\rightarrow x’\rightarrow q$​​​​) 的 specular motion。其中反射路径 $\mathcal{S}_1$​​​​ 在 G-buffer 光栅化后已经确定，那么只有 $\mathbf{x’}$​​​ 是未知的。</p><ul><li><input disabled type="checkbox"> 基于 specular path perturbation <a href="#%5B5%5D">[5]</a> 理论，此时问题转化为：已知 $\Delta p&#x3D;p’-p$​​，近似 $\Delta x&#x3D;x-x’$​​，从而得到 $x’&#x3D;x+\Delta x$​​.<br>                                        $$<br>\Delta x&#x3D;J\Delta p+[\Delta p]^TH[\Delta p]<br>$$<br>其中，$J(p,q,x,f)$​​ 是一个 3X3 Jacobian 矩阵，$H(p,q,x,f)$​​ 是一个 3x3x3 tensor，$[\Delta p]$​​ 是重复 $\Delta p$​​ 三次的  1x1x3 tensor。由于 specular path perturbation 需要使用到 $f$​​ 的一阶、二阶、三阶导数，这里就使用到了预计算中近似的抛物面。</li></ul><p>至此，已经计算出 $p\rightarrow  x \rightarrow  q \rightarrow  x’ \rightarrow  p’$ 光线路径中 $x’$ 的位置，作者对于得到的 $x’$ 做了额外的处理，只保留和 $x$ 具有相同材质的 $x’$ 点。下面可以使用 $x’$ 来收集 probe data 中的 probe samples，从而得到 probe data 中存储的 glossy GI 信息。</p><h4 id="3-2-2-Gathering-View-dependent-Color"><a href="#3-2-2-Gathering-View-dependent-Color" class="headerlink" title="3.2.2 Gathering View-dependent Color"></a>3.2.2 Gathering View-dependent Color</h4><p>结合 specular path perturbation 和预计算中表面曲率估计的方法，只是得到了 novel view 到 probe view 的 specular motion。为了得到更加鲁棒的结果，需要在 $x’$ 对应的 probe sample 的区域中搜索，选取最优的 probe sample。</p><blockquote><p>在 $p\rightarrow  x \rightarrow  q \rightarrow  x’ \rightarrow  p’$ 光线路径中，$p’\rightarrow x’\rightarrow q$ 为镜面反射的路径，但 probe data 中存储的是 glossy GI，glossy BRDF 是一个 lobe，光线路径对应的是一个区域，只要最终能到达 $q$ 即为所找 probe sample。因此，$x’$ 对应的样本附近区域也属于该镜面反射对应的 glossy 路径。因此可以在这个区域的 probe samples 中选取最优的 sample。注意：probe data 中的每个 sample 携带的都是其 probe 对应的 3D grid 区域的 glossy BRDF 的全局光照信息，若要使得像素的全局光照信息更加平滑，应收集不同区域 (即不同 probe) 的全局光照信息。</p></blockquote><p><strong>probe sample 搜索算法</strong>：使用 two-level 的 grid 搜索算法，coarse-level 在较大的区域内使用较大的 step-size 进行搜索，得到 coarse-level 的最优 sample。然后以这个最优 sample 为中心，使用较小的 step-size 进行 fine-level 搜索。</p><p><strong>评估 probe sample 的优劣</strong>：接下来使用 [Fig 2(b)](#Fig 2) 中的符号，probe view 下的 reflector position $r_p$、normal $n_p$ 和 reflected position $R_p$；novel view 下对应的 $r_v$、$n_v$ 和 $R_v$​ 。设计 energy function 来评估 probe sample 优劣的四个标准：</p><ul><li><p>novel view sample($R_v$) 和 probe view samples($R_p$) 更倾向于位于同一表面。如果二者的材质 ID 不同，则惩罚总 energy，即乘上 $\large s_a&#x3D;10$. 因此只有在其他样本不可用时，才会选用材质不匹配的样本。</p></li><li><p>$R_v$ 与 $R_p$ 距离近更好，对此引入 $s_b&#x3D;||R_v-R_p||$.</p></li><li><p>相近的表面法线 $n_v$​ 和 $n_p$​ 可以确保一致的光照。对此引入 $s_c&#x3D;1-(n_v\cdot n_p)$​</p></li><li><p>样本应该具有相近的 reflected ray，对此引入：<br>         $$<br>         s_d&#x3D;1-\frac{(R_v-r_v)\cdot (R_p-r_p)}{||R_v-r_v||\cdot||R_p-r_p||}<br>         $$     </p></li><li></li></ul><p>结合以上标准，设计 energy function 为：</p><p>$$<br>\varepsilon&#x3D;s_a\cdot \big(min(s_b,1)+min(s_c,1)+min(s_d,1)\big) \tag{1} \label{energy function}<br>$$<br>由于预计算 probe data 过程中应用了 apaptive parameterization，因此在搜索 sample 邻域中不能按常规使用固定大小的 grid(即搜索算法中的步长大小单位不应该固定)，因为这样会在压缩区域中丢失细节，或在放大区域中不充分搜索。对于此，作者对 step size 进行一次 scale，即步长(grid 数量)要乘以</p><p>$$<br>|\frac{\partial f^{-1}_h}{\partial x}|^{-1}<br>$$<br>其中 $\large f^{-1}_h$​​ 是预计算过程中生成的 <a href="#1.2.2">inverse flow field</a>。在作者实验中，coarse-level 搜索区域大小为 7X7 samples，步长为 4 texels；fine-level 搜索区域大小为 3X3 samples，步长为 2 texels。(步长都是 scale 前的)。</p><p>至此已经完成在 probe data 中选取最优 probe sample 的方法。下面将 probe sample 中的 glossy GI 信息加入到像素的最终着色中。</p><p>如果简单的只收集一个 probe 的 probe sample 中的 glossy GI，相机移动过程中会出现 pop-up 不平滑现象。作者使用距离 novel view 最近（即距相机最近）的 8 个 probe，每个 probe 选取一个最优 probe sample，最终以以下方式整合：<br>$$<br>C&#x3D;\frac{1}{Z}\sum\limits^8_{i&#x3D;1} t_i\cdot exp(-\phi\varepsilon_i)\cdot c_i \tag{2} \label{the sum of neighboor probes}<br>$$<br>其中 $t_i$​ 是 trilinear weight；$\phi$ 是 falloff 因子，论文中设为 8；$Z$ 是归一化系数，确保加权和为一个 unity；$c_i$ 从 probe data 中得到，当 sample 没有 color-blend 时，在加载 $c_i$​​ 过程中使用 bilinear 插值。对于没有找到有效 sample 的像素，对上一帧的 probe 进行 reprojection。</p><h3 id="3-3-Two-step-Convolution-For-Accurate-Warping-of-Glossy-Probes"><a href="#3-3-Two-step-Convolution-For-Accurate-Warping-of-Glossy-Probes" class="headerlink" title="3.3 Two-step Convolution For Accurate Warping of Glossy Probes"></a>3.3 Two-step Convolution For Accurate Warping of Glossy Probes</h3><p>上述描述的都是完美镜面反射的着色点，即 $p\rightarrow x\rightarrow q$ 为镜面反射路径，但实际中着色点更多的还是 glossy 材质。对于 glossy 材质的着色点，其对应的 hit position $q$ 会变为一个区域，即 glossy lobe 对应的区域。任何可以到达该区域的光线都可以复用该区域内对应的 probe samples。</p><p>对于一种特殊情况，两个相邻着色点的 BRDF lobe 的所有 probe samples 正好分别落在了 occlusion 边界两侧，这样就形成了明显的硬边界。图 [Fig 3](#Fig 3) 形象描述了出现这种情况的原理，[Fig 3(e)](#Fig 3) 中两个像素对应的着色点的 BRDF lobe 包含了黄色和蓝色两个平面的信息，这是 ground truth [Fig 3(a)](#Fig 3) 对应的 BRDF lobe 积分情况；简单的 reprojection 收集的 probe samples 正好落在了遮挡的一侧 [Fig 3(f)](#Fig 3)，使得模糊的边缘变得 sharpen  [Fig 3(d)](#Fig 3)；如果仅进行一次简单的 post-process filter，会导致 overblur，使得表面视觉 roughness 增大 [Fig 3(g)](#Fig 3)，注意着色像素的颜色(roughness 增大，导致像素包含了更大区域的信息，最终颜色过于平滑)。</p><p><a name="Fig 3"></a></p><img src="/images/Paper Notes/GI/Glossy Probe Reprojection for Interactive Global Illumination.assets/image-20220717214753044.png" alt="image-20220717214753044" style="zoom: 67%;"><center>Fig 3</center><p>本章节设计新的 filter，减小 Naive post-process filter 造成的 overblur。作者使用 Gaussian 分布拟合 BRDF，利用 Gaussian 分布卷积中的可分离特性，将 BRDF 包含的卷积进行分离为两步。在预计算过程中，减小表面 roughness，设计实时 image filter 重构原 roughness</p><blockquote><p>这种聚集 occlusion 边界一侧的现象可以理解为采样不足导致的，本章节提出在不提高采样数量的情况下，在 probe 预计算阶段降低几何表面的 roughness，这样会使得反射的光线更发散，probe sampe 更容易收集到周围着色点信息。在实时渲染过程中，再使用设计的 filter 重构原 roughness，得到原 roughness 下的周围着色点信息。</p></blockquote><h4 id="3-3-1-Filter-Footprint-Estimation"><a href="#3-3-1-Filter-Footprint-Estimation" class="headerlink" title="3.3.1 Filter Footprint Estimation"></a>3.3.1 Filter Footprint Estimation</h4><p>为了使用 Gaussian 分布可分离特性，首先需要使用 Gaussian 分布拟合 BRDF，为此需要估计其 footprint（指不同参数变化下 BRDF 的变化足迹）。为了估计 BRDF footprint，作者使用了一个简单的设定，如 [Fig 3.1(a)](#Fig 3.1) 所示：相机通过看向各向同性均匀 roughness 的反射平面($\mathbf{x}$​​​​​​​​)来观察 reflected point，其中反射平面法向量与 view direction 平行，并且与相机和 reflected point 的共线并行。基于这种设定，以固定的 fov 评估每一个点的 GGX BRDF(微表面法线模型) <a href="#%5B6%5D">[6]</a>，如 [Fig 3.1(b)](#Fig 3.1) 所示，中间区域最亮应该是直射区域，越往外侧越暗，GGX BRDF 的 specular lobe 反射到相机的越来越少。</p><p>影响 BRDF footprint 的参数有评估点的 roughness $\rho$​ 、相机到反射平面的距离 $d_c$​、反射平面到反射点的距离 $d_r$​​，给定这些参数，可以拟合一个协方差矩阵为 $\sum_{\rho}$​ 的 Gaussian 分布 $\mathcal{G}<em>{\rho}(\mathbf{x}:\rho,d_c,d_r)$​ 。协方差矩阵 $\sum</em>{\rho}$​ 可以通过选定一组 $[\rho, d_c,d_r]$​ 参数，采样 BRDF footprint 来确定。​例如 [Fig 3.1(c)](#Fig 3.1) 展示的是一条扫描线(相机移动轨迹)下的 BRDF 随 $\mathbf{x}$​ 变化的曲线。作者通过预计算不同参数组合下的协方差表格，供实时渲染时查表。该制表包含 32x32x32 bins，roughness 由 $0$ 到 $0.5$ 、距离由 $0.01$ 到 $10m$。并且采样过程选取 power sampling，在 $d_r&lt;0.5m$​ 降低协方差，防止这种情况下的拟合 overestimated 协方差。</p><p><a name="Fig 3.1"></a></p><img src="/images/Paper Notes/GI/Glossy Probe Reprojection for Interactive Global Illumination.assets/image-20220717214823052.png" alt="image-20220717214823052" style="zoom:67%;"><center>Fig 3.1</center><p>上述简单设定是 view direction 与反射平面垂直的情况，当二者不垂直时，即反射平面为一个倾斜平面，会使得 BRDF footprint 会由于远小近大而沿着倾斜方向缩小。在渲染时，通过将协方差乘上 view direction 和 surface normal 的点乘来进行补偿。</p><blockquote><p>使用 [Fig 3.1(a)](#Fig 3.1) 中的设置在预计算过程中拟合出 $[\rho, d_c,d_r]$ 参数不同组合下的 BRDF footprint 的 Gaussian 分布，然后在实时渲染中，根据当前着色点的 $[\rho, d_c,d_r]$ 查表获取该点的 BRDF footprint。但实时渲染中着色点、相机、反射平面多数不是 [Fig 3.1(a)](#Fig 3.1) 的简单设定，需要通过对协方差参数进行 scale 补偿，scale 系数为  view direction 和 surface normal 的点乘。</p></blockquote><p>假设 $\mathcal{G}<em>{\rho}$ 是反射平面的 BRDF，在 glossy light probes 预计算中获取；$\mathcal{G}<em>I$ 是 runtime image filter。我们可以在预计算中降低反射平面的 roughness，得到具有对应新 roughness $\rho’$ 的协方差矩阵 $\sum</em>{\rho’}$ 的 $\mathcal{G}</em>{\rho’}$. 使用 Gaussian 分布的性质：</p><p>​$$\sum(\mathcal{G}_1*\mathcal{G}_2)&#x3D;\sum(\mathcal{G}_1)+\sum(\mathcal{G}_2)$$​​, 其中 $\sum$ 是卷积的求和操作，其余为协方差矩阵</p><p>现在需要求得一个 image filter $\mathcal{G}<em>I$ 将降低过 roughness $\rho ‘$ 的 $\mathcal{G}</em>{\rho’}$ 重构为原 roughness 的 $\mathcal{G}_{\rho}$​. 利用上述性质，可以得到</p><p>$$<br>\sum_I&#x3D;\sum_{\rho}-\sum_{\rho’}<br>$$<br>从而得到 $\mathcal{G}_I$ （因为这里所有的 Gaussian 分布都采用均值为 0）。在实现中，作者使用 $\rho ‘&#x3D;\rho&#x2F;2$​ 作为预计算中光线路径中的第一个 glossy 顶点的 roughness 参数。</p><p>至此，已经完成对 image-space filter footprint 的估计。下面是如何应用 image filter。</p><h4 id="3-3-2-Gloss-Filtering"><a href="#3-3-2-Gloss-Filtering" class="headerlink" title="3.3.2 Gloss Filtering"></a>3.3.2 Gloss Filtering</h4><p>使用几何数据来估计公式 $\eqref{the sum of neighboor probes}$ 中的 $C$ ，<br>$$<br>\hat{C}(\mathbf{x})&#x3D;\frac{1}{Z(\mathbf{x})}\sum\limits_{\mathbf{x}_i\in\mathcal{N}(\mathbf{x})}\mathcal{G}_I(\mathbf{x}_i-\mathbf{x})w_r(\mathbf{x,x}_i)\space\varepsilon^{-1}(\mathbf{x}_i)C(\mathbf{x}_i) \tag{3} \label{glossy filtering}<br>$$<br>其中，$\mathcal{N}(\mathbf{x})$​​​​ 表示 $\mathbf{x}$​​​​ 处的 filter footprint；$\large \varepsilon$​​​​ 是 energy function $\eqref{energy function}$​​​​，其逆函数作为置信度来限制向匹配良好的像素的传播；range weight：</p><p>$$<br>w_r(\mathbf{x,x}<em>i)&#x3D;\mathbb{1}</em>{\mathbf{n(x)\cdot n}(\mathbf{x}<em>i)&gt;\alpha</em>\mathbf{n}}\cdot \mathbb{1}_{|d(\mathbf{x})-d(\mathbf{x}<em>i)|&lt;\alpha_d}\cdot \mathbb{1}</em>{m(\mathbf{x})&#x3D;m(\mathbf{x}<em>i)}<br>$$<br>作为 cross-bilateral 项，防止不连续的 normal 和 depth 或者不同反射材质 IDs 之间的 filtering. 实现中，作者设置 $\alpha</em>{\mathbf{n}}&#x3D;0.8$​ 和 $\alpha_d&#x3D;0.2$​；$Z$​​ is the normalizing partition function, ensuring filter weights sum to unity。</p><blockquote><p>求和的区域应该是 glossy BRDF lobe 对应的区域，对这个区域进行 filter</p></blockquote><h4 id="3-3-3-Efficient-Filter-Approximation"><a href="#3-3-3-Efficient-Filter-Approximation" class="headerlink" title="3.3.3 Efficient Filter Approximation"></a>3.3.3 Efficient Filter Approximation</h4><ul><li><input disabled type="checkbox"> $\eqref{glossy filtering}$​​​ 式的计算开销太大，作者使用 two passes, effectively using four 1D separable filters 进行高效近似计算 <a href="#%5B7%5D">[7]</a></li></ul><h2 id="4-Remain-Questions"><a href="#4-Remain-Questions" class="headerlink" title="4 Remain Questions"></a>4 Remain Questions</h2><ul><li><p><input disabled type="checkbox"> 不明白：This term converts probe area to actual object size, compensating for perspective and angular foreshortening akin to a form factor. $\large \theta_{long}$ is the longitude angle, which compensates for size variations induced by the lat-long base parameterization.  </p></li><li><p><input disabled type="checkbox"> 2D Discrete consine transform <a href="#%5B2%5D">[2]</a>: $\mathbf{b}$​ 是 basis function，basis function 与 法线的卷积用来分析 local neighborhood 的频率信息</p></li><li><p><input disabled type="checkbox"> 需要理解 <a href="#%5B3%5D">[3]</a> 的数学原理，描述下面过程的细节</p></li><li><p><input disabled type="checkbox"> 对于每个顶点，使用 <a href="#%5B4%5D">[4]</a> 技术估计其主曲率与对应方向 [Fig 1.3(a)](#Fig 1.3)。该步骤在每个物体上分别进行，并且为了更好的结果，对较大表面，先进行细分 [Fig 1.3(b d)](#Fig 1.3)。</p></li><li><p><input disabled type="checkbox"> 基于 specular path perturbation <a href="#%5B5%5D">[5]</a> 理论，此时问题转化为：已知 $\Delta p&#x3D;p’-p$，近似 $\Delta x&#x3D;x-x’$，从而得到 $x’&#x3D;x+\Delta x$.<br>                      $$<br>\Delta x&#x3D;J\Delta p+[\Delta p]^TH[\Delta p]<br>$$<br>其中，$J(p,q,x,f)$ 是一个 3X3 Jacobian 矩阵，$H(p,q,x,f)$ 是一个 3x3x3 tensor，$[\Delta p]$ 是重复 $\Delta p$ 三次的  1x1x3 tensor。由于 specular path perturbation 需要使用到 $f$​​ 的一阶、二阶、三阶导数，这里就使用到了预计算中近似的抛物面。</p></li><li><p><input disabled type="checkbox"> cross-bilateral 是什么</p></li><li><p><input disabled type="checkbox"> $\eqref{glossy filtering}$ 式的计算开销太大，作者使用 two passes, effectively using four 1D separable filters 进行高效近似计算 <a href="#%5B7%5D">[7]</a></p></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a name="[1]">[1]</a> Morgan McGuire, Mike Mara, Derek Nowrouzezahrai, and David Luebke. 2017b. Realtime global illumination using precomputed light field probes. In Proceedings of the Symposium on Interactive 3D Graphics and Games. ACM, 2  </p><p><a name="[2]">[2]</a> Nasir Ahmed, T Raj Natarajan, and Kamisetty R Rao. 1974. Discrete cosine transform. IEEE Trans. Comput. 100, 1 (1974), 90–93.  </p><p><a name="[3]">[3]</a> Rhaleb Zayer, Christian Rossl, and H-P Seidel. 2005. Discrete tensorial quasi-harmonic maps. In International Conference on Shape Modeling and Applications. IEEE, 276–285.  </p><p><a name="[4]">[4]</a> Mark Meyer, Mathieu Desbrun, Peter Schröder, and Alan H Barr. 2003. Discrete differential-geometry operators for triangulated 2-manifolds. In Visualization and Mathematics III. Springer, 35–57.  </p><p><a name="[5]">[5]</a> Perturbation methods for interactive specular reflections. IEEE Transactions on Visualization and Computer Graphics 6, 3 (2000), 253–264.  </p><p><a name="[6]">[6]</a> Bruce Walter, Stephen R Marschner, Hongsong Li, and Kenneth E Torrance. 2007. Microfacet Models for Refraction through Rough Surfaces. Rendering Techniques 2007 2007, 18th.  </p><p><a name="[7]">[7]</a> Eduardo SL Gastal and Manuel M Oliveira. 2011. Domain transform for edge-aware image and video processing. ACM Transactions on Graphics (TOG) (2011), 1–12.  </p><p><a name="[8]">[8]</a> <em>Simon Rodriguez, Thomas Leimkühler, Siddhant Prakash, Chris Wyman, Peter Shirley, and George Drettakis. 2020. Glossy probe reprojection for interactive global illumination.</em> <em>ACM Trans. Graph.</em> <em>39, 6, Article 237 (December 2020), 16 pages. DOI:<a href="https://doi.org/10.1145/3414685.3417823">https://doi.org/10.1145/3414685.3417823</a></em></p>]]></content>
    
    
    <categories>
      
      <category>Paper Notes</category>
      
      <category>GI</category>
      
      <category>Light Probe</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/20/C++/Effective%20Modern%20C++/Chapter%201%EF%BC%9A%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
    <url>/2023/09/20/C++/Effective%20Modern%20C++/Chapter%201%EF%BC%9A%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="条款一：模板类型推导"><a href="#条款一：模板类型推导" class="headerlink" title="条款一：模板类型推导"></a>条款一：模板类型推导</h2><p>对于下面一段模板伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(ParamType param)</span></span>;<span class="hljs-comment">// ParamType</span><br></code></pre></td></tr></table></figure><p><code>ParamType</code> 是模板形参类型，常带有修辞词(const)或引用声明。接下来将要谈论的几种情况：</p><ul><li>值传递：<code>ParamType</code>为<code>T</code></li><li>引用传递：<ul><li>左值引用：<code>ParamType</code>为<code>T&amp;</code>或<code>T const&amp;</code></li><li>万能引用：<code>ParamType</code>为<code>T&amp;&amp;</code></li></ul></li><li>指针传递：<code>ParamType</code>为<code>T*</code></li></ul><h3 id="类型推导规则"><a href="#类型推导规则" class="headerlink" title="类型推导规则"></a>类型推导规则</h3><ol><li><p>无论是上述哪种情况，引用类型的实参都会被当作非引用类型处理</p><p>这一点与普通函数调用类似，实参是否为引用类型不会影响到形参是否为引用</p></li><li><p>值传递模板类型：实参的 const&#x2F;volatile 会被去掉</p><p>这一点与普通函数调用类似，值传递形参只是实参的副本，const&#x2F;volatile 修饰对于值传递没有意义。</p></li><li><p>引用传递模板类型：</p><ul><li>a. 左值引用：遵循第1点，实参自带的引用类型会被忽略。<ul><li>1 const引用模板类型：实参的const会被忽略</li><li>2 非const引用模板类型：实参的const会被模板类型保留，这一点与普通函数调用不同</li></ul></li><li>b. 万能引用：会根据实参属于左值还是右值推导模板类型<ul><li>1 左值实参：模板类型会被解释为左值引用，剩下的推导过程与 3.a.1 相同</li><li>2 右值实参：模板类型会被解释为右值引用。右值实参没有const而言了（因为是右值）</li></ul></li></ul></li><li><p>指针模板类型：与左值引用推导规则类型</p><ol><li>会取消掉实参的指针类型</li></ol></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Effect-based Multi-viewer Caching for Cloud-native Rendering</title>
    <link href="/2023/09/20/Paper%20Notes/Cloud%20Rendering/Effect-based%20Multi-viewer%20Caching%20for%20Cloud-native%20Rendering/"/>
    <url>/2023/09/20/Paper%20Notes/Cloud%20Rendering/Effect-based%20Multi-viewer%20Caching%20for%20Cloud-native%20Rendering/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Summary"><a href="#1-Summary" class="headerlink" title="1 Summary"></a>1 Summary</h1><p>本文基于object-space&#x2F;texture-space shading管线，提出一种面向multi-viewers的云渲染的cache系统设计。对于effect中与视角无关的部分，通过转换为texture-space下的渲染任务，并且设计effect-based cache系统，使得不同viewers共享同一份effect中间数据。提出的effect-based cache系统共包含定义在物体表面的On-Surface Cache(OSC)与定义在grid上的World-Space Cache(WSC)两种策略，统一使用hash table的形式进行存储管理，但二者具有不同的hash key设计，包含实际数据的cache entry由具体的effect定义。作者为两种cache策略分别给出相应的具体effect应用，同时提出通过为不同的effect使用不同的bias配置来为低频effect选择低分辨率，减少内存开销。</p><h1 id="2-Background"><a href="#2-Background" class="headerlink" title="2 Background"></a>2 Background</h1><h1 id="3-Pipeline设计"><a href="#3-Pipeline设计" class="headerlink" title="3 Pipeline设计"></a>3 Pipeline设计</h1><p>管线设计如图 <a href="#Fig-1">Fig-1</a>，首先为每个viewer执行visibility pass来决定那些cache entries会被使用到；然后对所有viewers的cache request进行整合更新，这一步可以执行在不同的GPU上；之后viewers再通过采样cache来着色帧；最后是后处理，将生成的图像插入到output stream。</p><p><a name="Fig-1"></a><br>![image-20230703130901243](&#x2F;images&#x2F;Paper Notes&#x2F;Cloud Rendering&#x2F;Effect-based Multi-viewer Caching for Cloud-native Rendering.assets&#x2F;image-20230703130901243.png)</p><center>Fig-1 Cloud Native Rendering Pipeline</center><p>想要被多个viewer复用，被cache的计算只能是视角无关的，同时作者提出基于effect的cache设计，可以为不同类型的渲染计算进行调整。经过对现代游戏引擎中的效果分析，作者提出两种类型的cache：on-surface cache，共享表面点上的计算；world-space cache，共享世界空间数据。</p><h2 id="3-1-On-Surface-Caches"><a href="#3-1-On-Surface-Caches" class="headerlink" title="3.1 On-Surface Caches"></a>3.1 On-Surface Caches</h2><p>On-Surface Cache(OSC)采用类似于<a href="#%5B2%5D">[2]</a>的管线。首先预处理阶段需要为mesh生成唯一表示的纹理空间。作者通过将一定数量的相连接的面片划分成island单位，每个island有独立的texture space，可以生成triangle lookup texture，即每个texel的triangle id。</p><p>对于cache texture的实现，尽管目前硬件支持virtual texture，但64KB的page大小对于本系统过大，因此作者采用软件实现的cache系统。为了更好的spatio-temporal重用，作者设计了用于访问所有virtual textures的单个hash map，hash map中存储的是指向cache entry(实际数据)的hash entry。一个page table&#x2F;hash map entry（页表项）由如下部分组成：</p><ul><li>island index：32bit，用来标识island，island下是独立的texture space</li><li>resolution：4bit，应该是mipmap level</li><li>texel block coordinates：2x12bit，island下的8x8 texel block的纹理坐标。<br>因此可以最多表示 32kx32k的纹理空间（$2^{12}*8&#x3D;2^{15}&#x3D;32\mathrm{k}$）</li></ul><p>本文采用的cache entry大小为8x8 texel block，texel的实际大小由具体effect定义。</p><blockquote><p>应该需要实现GPU上的hash map，键为 hash entry，值为指向cache entry的索引。:exclamation:</p></blockquote><p>OSC pipeline主要由如图<a href="#%5BFig-2%5D">Fig-2</a>中的五个阶段组成：</p><ol><li>Visibility：决定哪些cache entity会被用到以及去重cache request</li><li>Cache Update Queuing：填充着色任务队列</li><li>Triangle Lookup Rendering：</li><li>Effect Update：cache更新</li><li>Compositing：整合cache数据以及剩余的渲染计算生成最终渲染结果</li></ol><p><a name="Fig-2"></a></p><p>![image-20230704143603816](&#x2F;images&#x2F;Paper Notes&#x2F;Cloud Rendering&#x2F;Effect-based Multi-viewer Caching for Cloud-native Rendering.assets&#x2F;image-20230704143603816.png)</p><center>Fig-2 OSC Pipeline</center><h3 id="3-1-1-Visibility"><a href="#3-1-1-Visibility" class="headerlink" title="3.1.1 Visibility"></a>3.1.1 Visibility</h3><p>为每个viewer执行visibility pass生成所请求的cache entry，此外可以根据屏幕空间梯度以及每个effect的先验知识来调整cache entry的bias，提高目标mip level。例如空间低频的effect可以渲染的目标分辨率更低。</p><blockquote><p>不是很清楚mip level如何工作的:question: 似乎是降低的是texture space的分辨率，例如level 0的分辨率32kx32k，level 1的分辨率则为16kx16k。</p><p>unbiased情况是通过屏幕空间梯度计算的mip level达到pixel与texel一一对应；biased情况是手动为某些低频effect增大mip level，多个pixel对应一个texel。</p></blockquote><p>为每个texel block配置一个64bit mask，来标识block内哪些texel需要更新。对于每个surface point可能需要1、4、8个texel blocks，分别用于point、bilinear、trilinear采样。</p><blockquote><p>虽然cache的最小单位是 8x8 texel block，但effect发起的应该是以像素为单位的请求，通过上面的bias来对应到具体的texel block的texel上。那么只有当shading point位于block边界上时，才会需要更多block用来做插值。</p></blockquote><p>对于来自shading point的请求，先查询hash table确定所请求cache entry是否已经map，如果没有map，则map一个empty block。然后设置texel mask的对应位。texel mask会在每帧重置。通过这种方式，可以优雅去除重复请求。</p><blockquote><p>基于virtual texture的hash table实现本身只是个数组，其查询过程需要从头到尾遍历。hash table的键值对，键为virtual texture的采用坐标、值为关联的texel block索引，该索引指向一块内存，由后面的memory manager管理。不同的effect应该指向不同的内存。</p></blockquote><h3 id="3-1-2-Cache-Update-Queuing"><a href="#3-1-2-Cache-Update-Queuing" class="headerlink" title="3.1.2 Cache Update Queuing"></a>3.1.2 Cache Update Queuing</h3><p>本阶段对visibility阶段生成的cache entry创建更新请求。为每个效果创建一个cache update queue，用于存储texel block的更新请求。生成update request可以通过遍历所有 page-table entries 或者使用 texel mask操作来确定需要更新的texel block。</p><blockquote><p>个人理解：应该是通过遍历hash map中的所有条目，检查每条是否关联了实际了texel block，如果关联了则表示需要更新。或者是，texel mask是否全为0。那么所谓的cache update queue存储的是什么呢？指向hash map中条目的索引？:question:</p></blockquote><p>为了应对一些情况，作者还在此阶段提出了三点优化。</p><ul><li><p>在不同的视角下，同一cache位置可能会被多种不同分辨率使用到，例如trilinear filter。对于某些开销大的effect，相比于为同一着色点执行不同分辨率下的计算，从更高分辨率进行重采样可能更优。因此，为了实现此策略，新增一个resampling queue。在添加一个texel到update queue之前，是否已经存在同位置更高分辨率的更新。如果有，则将该texel以及其对应的重采样候选texel组成一个重采样操作，加入resampling queue中。</p><blockquote><p>这里的重采样候选texel应该根据实际的重采样过程来确定。假设是mipmap，那么一个texel则需要4个更高分辨率的候选texel</p></blockquote></li><li><p>不同effect的更新频率也不一定相同。有些effect不需要每帧更新，例如AO与DDGI达到收敛后，基本不再改变。这种效果的更新频率也可以用来控制cache update queuing</p></li><li><p>云渲染场景下，面对很多viewers时，可以将这些分配到不同的GPU上。这会导致同一个effect在不同GPU上都有一个cache update queuing。</p></li></ul><h3 id="3-1-3-Memory-Management"><a href="#3-1-3-Memory-Management" class="headerlink" title="3.1.3 Memory Management"></a>3.1.3 Memory Management</h3><p>前述过程中的数据结构中都不包含实际的texel block数据，而是指向texel block的内存索引。texel的具体大小与effect相关，因为cache的计算更多是中间结果，因此很可能不是常规的texel格式。本系统为不同texel大小预分配一定大小的buffer，并划分成block，然后cache update操作只引用指向这些block的索引。在启动阶段，使用一个栈(free list)来管理这些buffer block索引。</p><p>在执行过程中，避免内存不足，还需要能够将hash table中关联的block indices动态释放，放回free list。这个过程可以使用一个额外的compute shader完成，避免同时发生插入与删除。block的访问时间越近，意味着其包含的数据越容易被使用到，因此可以使用访问时间来指导unmap操作。为此，根据空闲block与新请求数量之间的比值来调整一个动态阈值，回收该阈值数量的最久未访问的block。</p><h3 id="3-1-4-Triangle-lookup-rendering"><a href="#3-1-4-Triangle-lookup-rendering" class="headerlink" title="3.1.4 Triangle lookup rendering"></a>3.1.4 Triangle lookup rendering</h3><p>在cache update的计算过程中，需要从cache texel对应到surface location，获取该位置处三角形的插值属性。这里需要用到triangle lookup textures，用来记录每个像素的triangle id。在texel shading管线中，该texture使用预计算得到，但这样无法支持动态场景以及内存开销较大，难以实际应用。</p><p>作者选择通过一个indirect rasterization管线实时生成triangle lookup texture。同时将过程抽象为一个effect，对其应用effect的内存管理机制。不同的是，triangle lookup “effect” 会被其他effect使用到，而且同一island的不同instance可以复用。此外，对于请求的cache block，虽然可以知道属于哪个island，但无法确定属于哪个三角形。因此选择将整个island送入indirect rasterization管线。由于island最多有256个三角形，同时triangle lookup不会频繁更新，因此这个阶段还算高效。</p><p>如何得到渲染需要的gbuffer数据？</p><p>每个view的visibility pass生成的visibility buffer得到的是屏幕像素的visibility信息，这在cache的texture space下并不连续。例如，即使8x8的texel block完全位于一个三角形内，也可能有部分texel没有visibility数据。想要在cache space下生成visibility信息，可以是：</p><ol><li><p>view的visibility buffer得到命中的cache entry</p></li><li><p>为cache entry的每个texel遍历其所属island的每个三角形，判断texel属于哪个三角形。</p><p>判断过程使用 texel 的uv与三角形顶点的uv，还需要对未找到所属三角形的 texel 应用保守光栅化技术</p></li></ol><h3 id="3-1-5-Geometric-LOD-support"><a href="#3-1-5-Geometric-LOD-support" class="headerlink" title="3.1.5 Geometric LOD support"></a>3.1.5 Geometric LOD support</h3><p>对于LOD的支持，可以选择将几何的不同LOD作为不同的island，但这会导致同一几何的不同LOD的cache完全独立，无法共享。另一种做法是不同LOD仍然使用同一连续UV空间，这样不同LOD的cache也能复用。这样的连续UV空间生成可以通过在生成几何LOD过程中，对顶点的简化同样应用到island uv上。</p><h3 id="3-1-6-Thoughts"><a href="#3-1-6-Thoughts" class="headerlink" title="3.1.6 Thoughts"></a>3.1.6 Thoughts</h3><ol><li><p>所有effect的cache entry的确定都是统一的，应该都是屏幕像素的texture coord(hash key)来确定。只是不同的effect可以调整其mipmap的bias。</p><p>那这个bias似乎只能提前预设好。因为visibility pass就会生成hash table的条目，已经确定texture space坐标了。</p></li><li><p>hash table的实现：vritual texture vs. 哈希实现</p><ul><li><p>hash键的设计可以唯一索引virtual texture space的一个texel block。键的设计如下：</p><ul><li>island index：32bit，用来标识island，island下是独立的texture space</li><li>resolution：4bit，应该是mipmap level</li><li>texel block coordinates：2x12bit，(x, y)</li></ul><p>按照上下文理解，hash table应该是基于virtual texture原理实现的，但并不是直接使用现有virtual texture的技术。</p><p>一共有 $2^{32}&#x3D;2^{16}\times 2^{16}$ 个 island，每个island空间为 $2^{12} \times 2^{12}$，单位为 8x8 texel block。再加上mipmap，那么整个virtual texture space总大小为<br>$$<br>\begin{align}<br>&amp; (2^{16} \cdot 2^{12} \cdot 2) \times (2^{16} \cdot 2^{12} \cdot 2) \<br>&#x3D;&amp; 2^{29} \times 2^{29}<br>\end{align}<br>$$<br>可以看出，这是一个用于表示整个场景的非常庞大的virtual texture space。相当于使用了非常庞大的空间实现一个完全无碰撞的hash。但实际一个viewer使用到的是很少一部分。</p><ul><li>如果是直接使用VT的做法，那么cache entry则使用physical texture保存。而texture的格式是有限制的，灵活性受限</li><li>文中描述的是VT的原理，但存储使用自定义的buffer进行，SSBO可以自定义结构体。</li></ul></li><li><p>从后续“memory requirement”部分来看，本文采用的应该是hash table的实现，但没有给出具体的hash设计。</p><p>因此可以考虑实现一个高效的GPU上的hash table，可以避免virtual texture的开销（经过virtual texture的间接寻址过程），但同样会带来hash碰撞时的线性查找过程，以及hash table的大小难以确定，最大为每个viewer都是不重叠的情况。具体到底哪个更高效未知。</p></li></ul></li><li><p>对于trilinear filter，文中提出之前的工作要么是不支持硬件加速，要么会引入1-pixel border。但文中的cache也一样不支持硬件加速的trilinear filter，而是使用重采样软件计算的。</p></li><li><p>memory management的实现：SSBO vs. texture</p><ul><li>SSBO 可以自定义内部数据格式</li><li>texture只能使用rgba格式</li></ul></li></ol><h2 id="3-2-World-Space-Caches"><a href="#3-2-World-Space-Caches" class="headerlink" title="3.2 World-Space Caches"></a>3.2 World-Space Caches</h2><p>WSC 是基于世界空间grid的cache。基于grid的effect数据大小差距较大，例如，一个probe会存储 8x8 个样本，而volume shadow只有1个float。因此cache entry大小的选择，与OSC选择固定的8x8 texel block不同，probe选择1x1x1 bricks更优，而volume shadow选择4x4x4 bricks更优。grid下的cache entry使用**world-grid index(WGI)**关联：对于1x1x1 bricks，可直接采用其世界坐标关；对于4x4x4 bricks，使用其中心坐标。此外，还必须保证grid是静态的，虽然可以根据相机的移动而出现与消失，但不能根据相机的移动而移动。</p><p>在多层级grid情况下，对于不同cache entry大小，可能不需要完整的octree结构。例如 4x4x4 bricks，这个对应了coarser level的一个grid，可以跳过一个level。而 1x1x1 brick 则需要每层级都需要。</p><p>WSC的管线与OCS类似：visibility确定需要的WGIs，再经过cache update queuing来调度更新cache entry。cache entry的分配同样使用一个hash map，而更新过程不再需要triangle lookup。</p><h3 id="3-2-1-Hash-Table"><a href="#3-2-1-Hash-Table" class="headerlink" title="3.2.1 Hash Table"></a>3.2.1 Hash Table</h3><p>使用64bit整数的WGI作为键，其描述三个维度的grid坐标、以及层级level。每个维度使用21bits，可以描述两百万grids。而纵向维度往往范围较小，需要更小的分辨率，因此可以节省几个bits存放level。</p><p>对于非常大的场景，WGI满足不了分辨率，可以采用分块执行。</p><h3 id="3-2-2-Lookup"><a href="#3-2-2-Lookup" class="headerlink" title="3.2.2 Lookup"></a>3.2.2 Lookup</h3><p>与OSC不同，WSC的同一cache可能会被同一viewer多次查询。例如，一块像素采样周围的light probe采样到同一批probe。这会导致对同一个WGI进行多次hashing，这会重复访问hash map。</p><blockquote><p>在面对一个hash key时，只能从头遍历hash map。如果存在该key，则得到关联cache entry。如果不存在，则会关联一个空的cache entry。因为本文基于virtual texture的hash map并非真正的hash map，其查找过程只能是遍历。:exclamation:</p></blockquote><p>本文提出为每个viewer建立一个local lookup table，用来保存相机周围的cache entries，而对于其他位置仍然走hashing 流程。</p><blockquote><p>local lookup table应该是根据grid坐标得到一个索引，可以直接访问得到其中cache entry。而不需要从头遍历。</p></blockquote><h3 id="3-2-3-Coherence"><a href="#3-2-3-Coherence" class="headerlink" title="3.2.3 Coherence"></a>3.2.3 Coherence</h3><p>为了提高coherence，可以对cache update queue进行部分排序，同一viewer连续排放。</p><h3 id="3-2-4-Effect-Examples"><a href="#3-2-4-Effect-Examples" class="headerlink" title="3.2.4 Effect Examples"></a>3.2.4 Effect Examples</h3><p>Light probe、volumetric fog、volume shadow</p><h2 id="3-3-Effects"><a href="#3-3-Effects" class="headerlink" title="3.3 Effects"></a>3.3 Effects</h2><p>作者列举了一些效果实现的示例</p><h3 id="3-3-1-Hard-Shadows"><a href="#3-3-1-Hard-Shadows" class="headerlink" title="3.3.1 Hard Shadows"></a>3.3.1 Hard Shadows</h3><p>硬阴影只需要记录着色点到光源的可见性，cache在OSC。每个texel使用 2 Bytes记录16根shadow rays。</p><h3 id="3-3-2-Ambient-Occlusion"><a href="#3-3-2-Ambient-Occlusion" class="headerlink" title="3.3.2 Ambient Occlusion"></a>3.3.2 Ambient Occlusion</h3><p>AO缓存在OSC，具有时序累积过程。每个texel共 4 Bytes：记录16-bit AO值，以及16-bit 样本数量（最大样本数量64）。</p><h3 id="3-3-3-Indirect-Diffuse-Illumination"><a href="#3-3-3-Indirect-Diffuse-Illumination" class="headerlink" title="3.3.3 Indirect Diffuse Illumination"></a>3.3.3 Indirect Diffuse Illumination</h3><h3 id="3-3-4-Reseroir-Sampling"><a href="#3-3-4-Reseroir-Sampling" class="headerlink" title="3.3.4 Reseroir Sampling"></a>3.3.4 Reseroir Sampling</h3><h2 id="3-4-Cloud-Setup"><a href="#3-4-Cloud-Setup" class="headerlink" title="3.4 Cloud Setup"></a>3.4 Cloud Setup</h2><p>在分布式云渲染下，viewer GPUs发送cache request(V-buffer)到每个effect GPU，待effect GPU更新完effect cache后，再由 viewer GPUs 合成最终画面。</p><img src="/images/Paper Notes/Cloud Rendering/Effect-based Multi-viewer Caching for Cloud-native Rendering.assets/image-20230925161736654.png" alt="image-20230925161736654" style="zoom: 67%;"><h1 id="4-Evaluation"><a href="#4-Evaluation" class="headerlink" title="4 Evaluation"></a>4 Evaluation</h1><h2 id="4-1-Memory-requirements"><a href="#4-1-Memory-requirements" class="headerlink" title="4.1 Memory requirements"></a>4.1 Memory requirements</h2><p>每个texel block具有 8x8 texels，effect定义具体的texel大小，如3.3节。texel block的内存回收策略采用：当经过一定帧，没有被访问到后的texel block返回free list。</p><p>对于比较远或者比较小的物体，有可能对应的mip层级分辨率不足8x8或者texel block只有一个texel命中，此时会导致存储利用率降低。因此对于bias为2的版本，理论上存储开销为unbiased版本的1&#x2F;16，但实际上只有 1.5~3 倍的减少。对于texel的更新数量能达到理论上的减少，因为有texel mask。</p><p>除了meta data（texel block的访问时间）外，内存管理还会引入额外的存储开销：</p><ul><li>memory allocation：每个hash table entry使用键值对（64bit键，32bit texel block index）。为了保证hash table的性能，hash table的容量选择150%的block总数，不高于75%的填充率。</li><li>work queues：每项表示一个要执行的texel block，采用16 bytes 键值对</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a name="[1]">[1]</a> Alexander Weinrauch. 2023. Effect-based Multi-viewer Caching for Cloud-native Rendering. <em>siggraph</em> (2023).</p><p><a name="[2]">[2]</a> K. E. Hillesland and J. C. Yang. 2016. Texel Shading. In Proceedings of the 37th Annual Conference of the European Association for Computer Graphics: Short Papers (Lisbon, Portugal) (EG ’16). Eurographics Association, Goslar, DEU, 73–76.  </p>]]></content>
    
    
    <categories>
      
      <category>Paper Notes</category>
      
      <category>Cloud Rendering</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dynamic Diffuse Global Illumination with Ray-Traced Irradiance Fields</title>
    <link href="/2023/09/20/Paper%20Notes/GI/Dynamic%20Diffuse%20Global%20Illumination%20with%20Ray-Traced%20Irradiance%20Fields/"/>
    <url>/2023/09/20/Paper%20Notes/GI/Dynamic%20Diffuse%20Global%20Illumination%20with%20Ray-Traced%20Irradiance%20Fields/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Summary"><a href="#1-Summary" class="headerlink" title="1 Summary"></a>1 Summary</h2><p>本文提出了一种基于light probe的实时动态diffuse GI(DDGI) 算法。该算法的probe在世界空间下摆放，其数据完全实时生成，不需要预计算，因此支持具有动态光源与动态几何的场景。</p><p>DDGI算法主要包含了probe数据更新与probe-based shading：</p><ol><li><p>probe数据更新：为场景中的每个probe生成 $n$ 条probe-update光线，光线与表面相交记为surfel，最终每个probe可以得到存储求交信息的surfel buffer。使用probe-base shading方法进行surfel shading，包含了sufel上的直接光照与从surfel周围probes中得到的间接光照。将surfel shading以给定滞后系数blend到probe中。</p></li><li><p>probe-base shading：作者为surfel shading与最终着色提出了统一的probe-base shading，一共包含了两部分：直接光照pass生成的直接光照信息，注意作者为了简化面光源的模拟过程，使用一次反射的间接光作为面光源的直接光照，而其在直接光照过程中只会生成自发光信息；从probe数据中采样得到的间接光照信息。</p></li></ol><p>本文提出的probe-based shading可以使用上一帧的光照信息与probe数据，实现了将多次反射的开销分摊到多帧。但这也会在visibility信息快速变化时，带来time-lag的异常现象。</p><h2 id="2-DDGI-Probe-Overview"><a href="#2-DDGI-Probe-Overview" class="headerlink" title="2 DDGI Probe Overview"></a>2 DDGI Probe Overview</h2><p>和 <a href="#%5B1%5D">[1]</a> 类似，probe中同样存储球面分布的数据，包括几何信息和辐射度量数据，存储在两张oc-map中：</p><ul><li>距最近几何的距离及其平方，存储在16x16 oc-map中，数据格式为<code>RG16F</code></li><li>diffuse irradiance存储在8x8 oc-map中，数据格式为<code>R11G11B10F</code></li></ul><p>不同的是，在 <a href="#%5B1%5D">[1]</a> 中使用texture array打包所有probe的oc-map；而本文采用将所有probe的每一张oc-map打包进一张贴图集，并使用一个像素的边界隔开，同时增加额外的padding来确保4x4对齐。其次本文的probe数据是实时计算得到的，因此能够实现真正动态全局光照。在每一帧，除了插值probe深度信息以适应场景几何的变化外，还能够高效地将更新的光线追踪照明混合到probe地图集。</p><h2 id="3-DDGI-probe更新"><a href="#3-DDGI-probe更新" class="headerlink" title="3 DDGI probe更新"></a>3 DDGI probe更新</h2><p>每一帧都按照如下几步更新probe数据：</p><ol><li>为场景中的 $m$ 个active probe都生成并发出 $n$ 条primary rays，并将光线追踪得到的 $n\times m$ 求交信息存储到surfel buffer中</li><li>使用统一的着色方法对surfel buffer计算直接光照与间接光照</li><li>使用每个相交surfel得到的shading、距离及其平方结果以blending方式更新到 $m$ 个active probe的oc-map texel</li></ol><p>与probe相交的surfel着色计算依赖于前一帧的光照与probe数据，这样做有两个目的：这种方式可以将多次反射的计算分摊到多帧；以blending方式更新probe数据可以使得几何上与辐射度量上在随着时间的尖锐过渡变得平滑。相反，这种方式会在visibility剧烈变化的情况下，由于间接光照更新的延迟，表现出明显的变化。</p><h3 id="3-1-放置probe"><a href="#3-1-放置probe" class="headerlink" title="3.1 放置probe"></a>3.1 放置probe</h3><p>probe在场景中的放置方式与 <a href="#%5B1%5D">[1]</a> 相同，在轴向均匀的三维grid的每个顶点上放置一个probe，对于每轴需要不同空间离散化的场景，我们可以设置scale参数来独立地缩放网格在一个轴上的间距。空间中每一点都与一个包含该点的grid相关联，即对应了一个带有8个probe的cage，如下图所示。而着色过程则需要在cage的probe中进行查询。为了能够充分采样局部光照的变化，需要尽量满足每个点都能有cage的8个probe，避免某些probe位于墙内而无效。为此，作者建议使用grid分辨率以及缩放参数来使得每个类似房间的空间中产生至少一个完整的cage。文中给出，在人类尺度的场景中，1~2米的grid间隔效果最好。</p><img src="/images/Paper Notes/GI/Dynamic%20Diffuse%20Global%20Illumination%20with%20Ray-Traced%20Irradiance%20Fields.assets/image-20230224010007700.png" alt="image-20230224010007700" style="zoom: 67%;"><center>cage的8个probe [1]</center><h3 id="3-2-生成与追踪Probe-Update光线"><a href="#3-2-生成与追踪Probe-Update光线" class="headerlink" title="3.2 生成与追踪Probe-Update光线"></a>3.2 生成与追踪Probe-Update光线</h3><p>为了捕获场景中几何与光照的变化，作者选择 $m$ 个active probes，对每个active probe均匀采样 $n$ 个球面方向，采样方式采用stochastically-rotated Fibonacci spiral pattern与 <a href="#%5B1%5D">[1]</a> 类似。一个probe中心与这 $n$ 个方向可以生成 $n$ 条光线，作者将 $m$ 个probe的光线以thread-coherent方式排布，在一个batch内发出。经测试，这种组织方式要优于直接在Vulkan或DirectX的实时光追管线中的primary shader发出光线。</p><blockquote><p>球面方向采样方式stochastically-rotated Fibonacci spiral pattern <a href="#%5B3%5D">[3]</a>以及光线组织方式需要看实现代码</p></blockquote><p>此外，作者还测试了active probes选取场景中部分probe(相机周围给定半径的范围内)以及光线采样数量随相机距离增大而减少，但实验结果表明，虽然这些优化会带来性能收益，但优化参数依赖于场景，不同场景需要配置不同的参数，否则会带来artifact。在本文的实验中，作者统一采用了每帧更新probe、每个probe都为active以及为所有probe采样相同数量的光线。</p><h3 id="3-3-Secondary-Surfel-Shading"><a href="#3-3-Secondary-Surfel-Shading" class="headerlink" title="3.3 Secondary Surfel Shading"></a>3.3 Secondary Surfel Shading</h3><p>对于probe更新和最终渲染中的间接光，作者采用统一的着色模型。具体来说，计算全局光照的两个阶段：更新 $m\times n$ Probe-Update光线采样的surfels着色；最终输出图像中相机下的像素着色。这两个阶段使用相同的着色例程，结合直接光照pass和使用probe数据的间接光照pass。也就是说，surfel的shading包含其直接光照与间接光照：</p><ul><li>surfel的直接光照：从直接光照pass生成直接光照数据中获取，当然surfel不一定可见</li><li>surfel的间接光照：从surfel附近的probes中进行采样插值得到间接光照信息，即probe-based shading</li></ul><p>而probe更新与最终渲染之间的差异在于shading queries，着色例程需要着色位置、法线以及观察方向作为输入。对于基于probe光追的surfel shading更新，需要光线求交得到的surfel位置与法线，以及probe中心到surfel的观察方向。</p><h3 id="3-4-Probe-Surfel-Upates"><a href="#3-4-Probe-Surfel-Upates" class="headerlink" title="3.4 Probe Surfel Upates"></a>3.4 Probe Surfel Upates</h3><p>在surfel shading之后，可以得到 $m\times n$ surfel points中的每一个surfel的更新着色值、probe中心到surfel的距离及其平方，这些值需要更新到probe数据中。作者给出了alpha-blending的更新方式，设置 $\alpha$ 为滞后参数，用来控制更新至覆盖前一帧值得速度，那么更新速度为 $1-\alpha$，文中采用 $\alpha\in[0.85,0.98]$，有以下更新过程，<br>$$<br>newIrradiance[texelDir]&#x3D;lerp(oldIrradiance[texelDir], \<br>\sum_{ProbeRays}(\max(0,texelDir\cdot rayDir)*rayRadiance),\alpha)<br>$$<br>上式中可以看出，filtered irradiance是采用moment-based filtered shadow query:confused: 直接计算得到的，避免了prefilter高分辨的入射radiance map。这种平滑的入射irradiance被用于计算diffuse间接光照，同时，也可以选择维护一个更高频的irradiance map用于glossy和specular的间接光。</p><ul><li><input disabled type="checkbox"> 技术细节：</li></ul><h2 id="4-Shading-with-DDGI-Probes"><a href="#4-Shading-with-DDGI-Probes" class="headerlink" title="4 Shading with DDGI Probes"></a>4 Shading with DDGI Probes</h2><h3 id="4-1-直接光照"><a href="#4-1-直接光照" class="headerlink" title="4.1 直接光照"></a>4.1 直接光照</h3><p>点光源与方向光的直接光照采用variance shadow map(VSM)的deferred render <a href="#%5B2%5D">[2]</a> 来计算。</p><p>对于面积光源的直接光照，作者使用一次反射的间接光照管线计算。间接光照管线中，一次反射的间接光是计算场景中直接光的一次反射，多次反射的间接光则是基于前一次反射的间接光计算得到。而对于面积光源的一次反射间接光是基于区域的自发光，而不是面积光源下的直接光照，因此计算得到的是面积光源的直接光照。[图4.1](#Fig 4.1) 的最后一行给出了面积光源特殊处理的直观感受，直接光照结果只有面积光源区域的自发光，而没有照明场景中其他物体。</p><p>面积光源的特殊处理避免了对面积光源的直接光照的传统近似方式，例如在面积光源上采样多个点光源计算来近似面积光源的直接光照。除此之外，对面积光源的计算统一为本文提出的probe-base shading技术，可以得到平滑的面积光阴影与反射。</p><p><a name="Fig 4.1"></a></p><p>![image-20230226115136810](&#x2F;images&#x2F;Paper Notes&#x2F;GI&#x2F;Dynamic%20Diffuse%20Global%20Illumination%20with%20Ray-Traced%20Irradiance%20Fields.assets&#x2F;image-20230226115136810.png)<br>![image-20230226115205828](&#x2F;images&#x2F;Paper Notes&#x2F;GI&#x2F;Dynamic%20Diffuse%20Global%20Illumination%20with%20Ray-Traced%20Irradiance%20Fields.assets&#x2F;image-20230226115205828.png)</p><center>图 4.1 第一列只有直接光照，第二列有完整的全局光照</center><h3 id="4-2-Diffuse间接光"><a href="#4-2-Diffuse间接光" class="headerlink" title="4.2 Diffuse间接光"></a>4.2 Diffuse间接光</h3><p>为了弥补probe位置的入射irradiance没有考虑着色点周围的局部遮挡，作者使用SSAO得到的遮挡系数调制漫反射的出射radiance。但在更新probe过程中不会包含局部遮挡，间接光忽略该项的影响要远远小于直接可见表面的光照。</p><p>本文对间接漫反射的插值和采样技术结合了光线追踪与shadow map的想法，提高对动态几何和光源的鲁棒性，与 <a href="#%5B1%5D">[1]</a> 中不同。具体来说，在得到包含着色点的cage上的8个probe的索引后，为每个irradiance probe根据其相对于着色点的位置与方向计算插值权重。如[图4.2](#Fig 4.2)中surfel X的着色过程的权重包括：使用表面法线 n 采样eight-probe cage的每个probe；使用X到P的方向 dir，为每个probe P施加back-face权重；P中存储的(进行过filter)平均距离 r；为了避免visibility边界采样问题，作者会将X朝着法线方向施加一个偏移量。</p><p><a name="Fig 4.2"></a></p><img src="/images/Paper Notes/GI/Dynamic%20Diffuse%20Global%20Illumination%20with%20Ray-Traced%20Irradiance%20Fields.assets/image-20230226143129489.png" alt="image-20230226143129489" style="zoom:50%;"><center>图4.2 surfel X的着色。</center><p>[图4.3](#Fig 4.3)说明了这些加权阶段对最终渲染结果的影响，从最初的传统probe渲染开始，逐步加入权重项，强调每个权重如何消除artifacts：</p><ul><li>背面剔除位于着色点切平面下方的probe，设置一个soft threshold，当着色点法线与其到probe的方向之间的点乘小于该阈值时，则剔除。</li><li>人类视觉系统对于黑暗区域的低强度照明的敏感性，作者降低了少于5% irradiance范围的贡献</li><li>VSM中描述的mean- and variance-biased Chebyshev interpolants :confused:</li><li>对着色点应用与着色点法线和其到probe方向成正比的bias偏移，避免visibility函数边界处不连续阴影的问题</li><li>使用上述权重与bias，根据着色点与probe中心的距离，执行三线性插值</li></ul><p><a name="Fig 4.3"></a></p><img src="/images/Paper Notes/GI/Dynamic%20Diffuse%20Global%20Illumination%20with%20Ray-Traced%20Irradiance%20Fields.assets/image-20230226145015593.png" alt="image-20230226145015593" style="zoom: 67%;"><center>图4.3 封闭房间场景下的irradiance插值与采样。d~f逐渐加入权重</center><p>技术细节：之前的工作使用 $128\times 128 \times 6$ 的高精度cube map存储深度信息，而在应用本文的权重准则后，可以在不引入数值误差问题的情况下，降低至 $16 \times 16$ 的medium精度。</p><h3 id="4-3-多次反射的全局光照"><a href="#4-3-多次反射的全局光照" class="headerlink" title="4.3 多次反射的全局光照"></a>4.3 多次反射的全局光照</h3><p>多次反射的计算是一个递归过程，每一次反射的间接光都是基于前一次反射的radiance buffer。本文的间接光计算是分销在多帧的，因此会带来time-lag artifact，这一点对于静态相机下的静态场景最明显，而对于视角、光源和几何是动态的场景，这种延迟在间接光反射是不易察觉的。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a name="[1]">[1]</a> Morgan McGuire, Mike Mara, Derek Nowrouzezahrai, and David Luebke. 2017. Real-time global illumination using precomputed light field probes. In Proceedings of the 21st ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games (I3D ‘17). Association for Computing Machinery, New York, NY, USA, Article 2, 1–11. <a href="https://doi.org/10.1145/3023368.3023378">https://doi.org/10.1145/3023368.3023378</a></p><p><a name="[2]">[2]</a> Thaler, Jonathan. (2011). Deferred Rendering. URL: <a href="https://www.researchgate.net/profile/Jonathan_Thaler2/publication/323357208_Deferred_Rendering/links/5a8fce31aca272140560aaad/Deferred-Rendering.pdf">https://www.researchgate.net/profile/Jonathan_Thaler2/publication/323357208_Deferred_Rendering/links/5a8fce31aca272140560aaad/Deferred-Rendering.pdf</a></p><p><a name="[3]">[3]</a> Ricardo Marques, Christian Bouville, Mickaël Ribardière, Luis Paulo Santos, Kadi Bouatouch. Spherical Fibonacci Point Sets for Illumination Integrals. Computer Graphics Forum, 2013, 32 (8), pp.134-143. ⟨10.1111&#x2F;cgf.12190⟩. ⟨hal-01143347⟩</p>]]></content>
    
    
    <categories>
      
      <category>Paper Notes</category>
      
      <category>GI</category>
      
      <category>Light Probe</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Forward Light Cuts A Scalable Approach to Real-Time Global Illumination</title>
    <link href="/2023/09/20/Paper%20Notes/GI/Forward%20Light%20Cuts%20A%20Scalable%20Approach%20to%20Real-Time%20Global%20Illumination/"/>
    <url>/2023/09/20/Paper%20Notes/GI/Forward%20Light%20Cuts%20A%20Scalable%20Approach%20to%20Real-Time%20Global%20Illumination/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Summary"><a href="#1-Summary" class="headerlink" title="1 Summary"></a>1 Summary</h1><p><code>Forward Light Cuts: A Scalable Approach to Real-Time Global Illumination  </code>  <a href="#%5B1%5D">[1]</a></p><p>这篇论文假设了次级光源为 diffuse 材质的场景，并且不考虑次级光照的阴影，提出了一种能够很好结合 tessellation 和 geometry 阶段的并行特性的高效实时全局光照近似计算算法。该算法基于 many-light 框架，将场景中的三角形类比为虚拟点光源，首先通过将场景中三角形以一种概率分布划分为 multi-scale radiance 子集，在每个子集中的每个三角形上随机采样生成一个扰动的 VPL，这样就组成了多尺度的 VPL 集合。之后求解该 VPL 集合形成的 many-light 问题来近似全局光照。该算法既模拟了传统层级的光源数量的随尺度增加的几何级下降，又具有可高度并行的线性设计，在场景完全动态并且涉及大量物体时，相比于之前算法，画面质量无明显损失并且具有较大的性能提升。</p><h1 id="2-Motivation"><a href="#2-Motivation" class="headerlink" title="2 Motivation"></a>2 Motivation</h1><p>实时全局光照有很多基于 radiance caching 的方法，之前这些方法构建出场景中几何的层级结构（多为树形结构），使用这种层级结构来构建 multi-scale radiance function，之后通过查询该层级结构对像素进行照亮。</p><p>对于这种策略的方法，在场景完全动态并且涉及大量物体情况下，至少有两种局限，</p><ul><li>层级缓存结构每一帧都要重复计算，这个缺点带来的开销在现代图形学的并行结构下更为明显</li><li>对于实时渲染，初始 VPL 集合过大，带来的开销难以分摊</li></ul><h1 id="3-Approach"><a href="#3-Approach" class="headerlink" title="3 Approach"></a>3 Approach</h1><h2 id="3-1-VPLs-Generation"><a href="#3-1-VPLs-Generation" class="headerlink" title="3.1 VPLs Generation"></a>3.1 VPLs Generation</h2><h3 id="3-1-1-区分-Divergent-和-Regular-三角形"><a href="#3-1-1-区分-Divergent-和-Regular-三角形" class="headerlink" title="3.1.1 区分 Divergent 和 Regular 三角形"></a>3.1.1 区分 Divergent 和 Regular 三角形</h3><p>设置阈值 $S_0$ ，面积大于 $S_0$ 的三角形为 Divergent 三角形，这类三角形需要经过一次 tessellation 特殊处理，之后描述。</p><p>$$<br>S_0&#x3D;4\pi \frac{D^2_{near}}{N_{avg}}<br>$$<br>这个公式表达的是启发式地照亮一个像素，该像素周围有 $N_{avg}$ 个距离为至少 $D_{near}$ 的 VPLs 。参数配置：假设 $R_{scene}$ 为场景的半径长度，设置 $D_{near}&#x3D;0.2\times R_{scene}$，$N_{avg}$ 在区间 $[64,1024]$ 内进行 quality-speed tradeoff。</p><blockquote><p><code>个人理解见</code>：<a href="#%E9%99%84%E5%BD%951">附录 1. 阈值 $S_0$ 的启发式的理解</a></p></blockquote><h3 id="3-1-2-三角形抽取过程"><a href="#3-1-2-三角形抽取过程" class="headerlink" title="3.1.2 三角形抽取过程"></a>3.1.2 三角形抽取过程</h3><p>抽取操作目的是丢弃小三角形，因为这类三角形引入的 diffuse indirect lighting 对最终的渲染贡献很小，丢弃会加快速度，但如果全部无差别丢弃，则会丢失那些多个小三角形一起作用而带来的明显间接光照效果，因此提取操作中引入一种随机过程，即<strong>随机抽取过程</strong>：</p><p>对于每一个三角形计算一个 $[0,1]$ 区间均匀分布的随机数 $u_{t_i}$，如果三角形面积 $\mathcal{A}(t_i)&gt;u_{t_i}S_0$，则保留该三角形，否则丢弃。三角形保留的概率分布为</p><p>$$<br>\forall\space t_i\in \mathcal{L}, \quad P(t_i\in \mathcal{L^<em>})&#x3D;\frac{\mathcal{A}(t_i)}{S_0}<br>$$<br>其中 $\mathcal{L}$ 是全体 regular 三角形的集合，$\mathcal{L^</em>}$ 是保留的三角形集合。由此可以看出，**三角形面积越小，被丢弃的概率越大。**对于整个场景的面能够保留下来的数量的期望为 $\mathbb{E}(N_{sample})&#x3D;\frac{\mathcal{A}_{scene}}{S_0}$。</p><h4 id="基于随机提取过程的三角形多尺度划分"><a href="#基于随机提取过程的三角形多尺度划分" class="headerlink" title="基于随机提取过程的三角形多尺度划分"></a>基于随机提取过程的三角形多尺度划分</h4><p>将场景中三角形划分为 $(\mathcal{L}^0,…,\mathcal{L}^N)$ 共 $N+1$ 个子集，子集索引由 $0$ 到 $N$ 递增，影响距离递减（即尺度递减），子集包含的三角形数量递增。为了实现这样的划分，引入 $N+1$ 长度的递增序列 ${S_0&lt;…&lt;S_N}$。扩展随机提取过程到多尺度划分过程，三角形 $\large t_i$ 划分为子集 $\large \mathcal{L}^k$ 的概率为</p><p>$$<br>\forall k\in [0…N],\quad P(t_i\in \mathcal{L}^k)&#x3D;\frac{\mathcal{A}(t_i)}{S_k} \tag{1}\label{partition probability}<br>$$<br>在多尺度划分过程中，divergent 三角形的定义更改为<strong>面积大于 $S_N$ 的三角形</strong>。</p><p>实际划分算法又有进一步的改动，引入 $\large\forall k\in [0…N],\quad \tilde{S}<em>k&#x3D;\frac{1}{\sum^k</em>{j&#x3D;0}\frac{1}{S_j}}$ ， 算法伪代码如下</p><img src="/images/Paper Notes/GI/Forward Light Cuts A Scalable Approach to Real-Time Global Illumination.assets/image-20220717013637705.png" alt="尺度等级划分算法" style="zoom: 67%;"><blockquote><p>可知 $\tilde{S}_k$ 单调递减，与原 $S_k$ 单调递增相反，但算法中是只有三角形没有被分在 $k-1$ 子集中，才有可能判断是否可分到 $k$ 子集，这是条件概率。粗略地看，子集索引越大，三角形分到该子集的概率越低，因为需要在前面没有分到所有子集的条件，才进行后续子集的划分。</p></blockquote><p>至此，我们已经对场景三角形进行随机划分为多个不同尺度的子集，之后其中的每个三角形都会随机生成一个 VPL，形成 VPL 集。接下来基于生成的 VPL 求解 many-light 问题，即如何使用这些 VPL 照亮像素。</p><h2 id="3-2-VPLs-光照下的着色"><a href="#3-2-VPLs-光照下的着色" class="headerlink" title="3.2 VPLs 光照下的着色"></a>3.2 VPLs 光照下的着色</h2><h4 id="3-2-1-many-light-下的-VPLs-lighting-问题描述"><a href="#3-2-1-many-light-下的-VPLs-lighting-问题描述" class="headerlink" title="3.2.1 many-light 下的 VPLs lighting 问题描述"></a>3.2.1 many-light 下的 VPLs lighting 问题描述</h4><p>在 many-lights 框架中，对于 normal 为 $\vec{n_x}$ 的着色点 $x$ 的 indirect outgoing radiance，计算方法由连续积分近似为来自一个 VPLs 集合的 radiance 离散求和。</p><p>$$<br>L^{ML}(x,\vec{n_x})&#x3D;\sum_{t_i\in \mathcal{L}}H(t_i,x,\vec{n_x})\mathcal{A}(t_i) \tag{2}<br>$$<br>$\mathcal{L}$ 表示场景中所有三角形集合，$H(t_i,x,\vec{n_x})$ 表示 normal 为 $\vec{n_x}$ 的点 $\large x$ 接收到由 $t_i$(VPL) 出发的 radiance。对于 albedo 为 $\rho_x$ 的 diffuse receiver， $H$ 的形式如下：</p><p>$$<br>H(t_i,x,\vec{n_x})&#x3D;L(t_i,\bar{y_ix})\frac{\rho_x}{\pi}\frac{&lt;\vec{n_x},\bar{xy_i}&gt;^+&lt;\vec{n_i},\bar{y_ix}&gt;^+}{d_i^2}<br>$$<br>其中 $\large \bar{u}$ 表示 normalized 向量，$&lt;\vec{u},\vec{v}&gt;^+&#x3D;max(0,&lt;\vec{u},\vec{v}&gt;)$，$L(t_i,\bar{y_ix})$ 是离开 VPL 中心 $\large y_i\in t_i$ 朝向 $\large \bar{y_ix}$ 的 radiance， $d_i&#x3D;max(\epsilon,||\vec{xy_i}||)$ 是进行过 clamp 的 $y_i$ 与 $\large x$ 之间的距离，避免奇异点。</p><blockquote><p><code>对近似的个人理解见</code>：<a href="#%E9%99%84%E5%BD%952">附录 2. 着色方程积分近似为求和的理解</a></p></blockquote><p>VPL 对直接光照的 diffuse 反射表示为下面的 VPL 出射 radiance：</p><p>$$<br>L(t_i,\bar{y_ix})&#x3D;\rho_iE(t_i)\frac{3}{2\pi}&lt;\vec{n_i},\bar{y_ix}&gt;^+<br>$$<br>其中 $\large E_i$ 是直接到达三角形 $\large t_i$ 的直接 irradiance，由于 $&lt;\vec{n_i},\bar{y_ix}&gt;^+$ 可知上式并非 perfectly Lambertian (一种简单的漫反射：光线被均匀的反射到表面上方的半球)，而只会在几何法线方向发生完美反射。$\large \frac{3}{2\pi}$ <em>用来保证能量守恒</em>。</p><blockquote><p> 将 $\large L(t_i,\bar{y_ix})$ 代入 $\large H(t_i,x,\vec{n_x})$ 中有</p><p> $$<br> \begin{align}H(t_i,x,\vec{n_x})&amp;&#x3D;\rho_iE(t_i)\frac{3}{2\pi}&lt;\vec{n_i},\bar{y_ix}&gt;^+\frac{\rho_x}{\pi}\frac{&lt;\vec{n_x},\bar{xy_i}&gt;^+&lt;\vec{n_i},\bar{y_ix}&gt;^+}{d_i^2}\ &amp;&#x3D; \frac{3}{2\pi^2}\rho_i\rho_xE(t_i)\frac{&lt;\vec{n_x},\bar{xy_i}&gt;(&lt;\vec{n_i},\bar{y_ix}&gt;)^2}{d_i^2} \end{align}\tag{2} \label{received radiance}<br> $$ </p></blockquote><h4 id="3-2-2-多尺度划分下的-VPLs-lighting-的近似"><a href="#3-2-2-多尺度划分下的-VPLs-lighting-的近似" class="headerlink" title="3.2.2 多尺度划分下的 VPLs lighting 的近似"></a>3.2.2 多尺度划分下的 VPLs lighting 的近似</h4><p>上述进行的对三角形的多尺度随机划分引入了随机过程，因此 $L^{ML}(x,\vec{n_x})$  也变成了<strong>随机量</strong>，接下来就需要对该随机量进行估计。我们定义 $K(x,\vec{n_x})$ 为 $L^{ML}(x,\vec{n_x})$  <strong>估计量(Estimator)</strong>：</p><p>$$<br>K(x,\vec{n_x})&#x3D;\sum\limits^N_{k&#x3D;0}\sum\limits_{t_i\in\mathcal{L}^k}H(t_i,x,\vec{n_x})F^k(t_i,k)<br>$$<br>其中 $F^k(t_i,k)$ 是一个未知函数，参数 $x$ 为着色点，$t_i$ 为 VPL 所在三角形，$k$ 为子集索引。</p><p>下面就要确定 $F^k(t_i,k)$ 的形式：</p><p>$$<br>\begin{align} \mathbb{E}\left[K(x,\vec{n_x})\right]&amp;&#x3D; \mathbb{E}\left[\sum\limits^N_{k&#x3D;0}\sum\limits_{t_i^k\in \mathcal{L}^k}H(t_i^k,x,\vec{n_x})F^k(t_i^k,x)\right] \ &amp;&#x3D; \sum\limits_{t_i\in \mathcal{L}}H(t_i,x,\vec{n_x}) \mathbb{E}\left[\sum\limits^N_{k&#x3D;0}F^k(t_i,x)\mathbb{I}<em>{t_i\in \mathcal{L}^k}\right] \ &amp;&#x3D; \sum\limits</em>{t_i\in \mathcal{L}}H(t_i,x,\vec{n_x})\sum\limits^N_{k&#x3D;0}F^k(t_i,x)P(t_i\in \mathcal{L}^k)\end{align}\tag{3}\label{many light estimator}<br>$$<br>其中 $\mathbb{I}_{t_i\in \mathcal{L}^k}$ 为指示函数，当 $t_i\in \mathcal{L}^k$ 时值为 $1$，否则为 0。</p><blockquote><p><code>推导见</code>：<a href="#%E9%99%84%E5%BD%953">附录 3. VPL lighting 推导</a></p></blockquote><p>我们要选取 $F^k(t_i,x)$ 使得 $K(x,\vec{n_x})$ 为 $L^{ML}(x,\vec{n_x})$ 的无偏估计，即 $\mathbb{E}\left[K(x,\vec{n_x})\right]&#x3D;L^{ML}(x,\vec{n_x})$，比较式 (2) 和 (4) 可有</p><p>$$<br>\forall x,\quad \sum\limits_k F^k(t_i,x)P(t_i\in \mathcal{L}^k)&#x3D;\mathcal{A}(t_i)\label{partition derivate}<br>$$<br>根据划分策略，将 $F^k$ 定义为 $F^k(t_i,x)&#x3D;S_kf^k(t_i,x)$</p><blockquote><p><code>推导见</code>：<a href="#%E9%99%84%E5%BD%954">附录 4. 转为整体划分问题推导</a></p></blockquote><p>这样就将一个无偏估计问题转为了寻找对一个整体的划分问题。</p><p><strong>整体的划分选取</strong></p><p>$f^k(t_i,x)$ 划分函数的参数 $t_i,x$ 都为三维，论文采用一种方法将划分函数进行降维近似处理，此方法参考了论文  <em>Point-based approximate color bleeding</em> 中的 nested balls: $\mathcal{B}_h(t_i)$，其定义如下：</p><p>$$<br>\forall h\in \mathbb{R}^*, \quad \mathcal{B}_h(t_i)&#x3D;{x\in\mathbb{R}^3\space s.t. \space \underset{\vec{n_x}}{max}\space H(t_i,x,\vec{n})\geq h} \tag{4} \label{partition nested ball}<br>$$</p><blockquote><p>$H$ 是 $\large x$ 接收到 $t_i$ VPL 的 radiance，这个 nested ball 的含义就是定义了一个对着色点 $x$ 的 radiance 贡献较为显著的区域，这个显著程度由 $h$ 决定。</p></blockquote><p>此外，考虑 receiver 正对着 emitter 的情况，即 $\vec{n_x}&#x3D;\bar{xy_i}$，此时 $H$ 达到最大值，有：</p><p>$$<br>\mathcal{B}_h(t_i)&#x3D;{x\in\mathbb{R}^3\space s.t. \space \frac{||x-y_i||}{&lt;\vec{n_i},\bar{xy_I}&gt;^+}\leq D(h)} \tag{5} \label{nested ball}<br>$$<br>其中  $D(h)&#x3D;\frac{1}{\pi}\sqrt{\frac{3\rho_x\rho_iE(t_i)}{2h}}$</p><blockquote><p><code>推导见</code>：<a href="#%E9%99%84%E5%BD%955">附录 5. 整体划分选取推导</a></p></blockquote><p> $D(h)&#x3D;\frac{1}{\pi}\sqrt{\frac{3\rho_x\rho_iE(t_i)}{2h}}$ 与 $\large x$ 着色点无关，因此 $\mathcal{B}_h(t_i)$ 是一个 nest ball，其边界上有点 $y_i$，其中心位于直线 $(y_i,\vec{n_i})$ 上。如下图所示</p><img src="/images/Paper Notes/GI/Forward Light Cuts A Scalable Approach to Real-Time Global Illumination.assets/image-20220717013806858.png" alt="image-20220717013806858" style="zoom:67%;"><blockquote><p>上图是 $f^k(t_i,x)$ 函数的二维可视化，其值从 0(黑) 到 1(白)。</p></blockquote><p>作者做了一个假设：nest ball 边界上的三维划分 $^k(t_i,x)$ 是不变的，通过如下 $\large \mathbb{R}^3$ 到 $\large \mathbb{R}$ 的映射：</p><p>$$<br>\forall x\in \mathbb{R}^3, \quad d(t_i,x)&#x3D;\frac{||x-y_i||}{&lt;\vec{n_i},\bar{xy_I}&gt;^+}<br>$$<br>可以将三维划分将为一维划分：</p><p>$$<br>\forall x\in \mathbb{R}^3, \quad f^k(t_i,x)&#x3D;\tilde{f}^k(d(t_i,x))<br>$$<br> $\large f^k$ 将会在 rendering 中用作 splat function，因此尽可能使得 $f^k$ 易于计算且 smooth，论文定义为下面一组分段线性函数</p><p>$$<br>\forall d\in\mathbb{R},\quad \tilde{f}^k(d)&#x3D;\begin{cases}\begin{align}&amp;1 &amp;k&#x3D;0\space and \space d\in[0,D_1] \ &amp;\frac{d-D_{k-1}}{D_k-D_{k-1}} &amp;k&gt;0\space and \space d\in[D_{k-1},D_k] \ &amp;\frac{D_{k+1}-d}{D_{k+1}-D_k} &amp;k&gt;0 \space and \space d\in [D_k,D_{k+1}]\&amp;0 &amp;otherwise\end{align}\end{cases}<br>$$<br>${D_k}$ 定义了每一级 VPL 的影响距离。</p><p> <strong>参数配置</strong></p><p>作者为了模仿传统的层级表示，采用了子集大小几何级下降的参数配置。从前述划分策略来看，$S_k$ 影响到划分子集的结果，此外，可以将 $S_k$ 理解为子集 $\mathcal{L}^k$ 的平均面积，应几何级增加，因此定义如下参数配置：</p><p>$$<br>S_k&#x3D;S_0\mu^k<br>$$<br>其中 $\mu &gt;1$ 是用户定义的参数，论文建议 $[1.4,5]$。作者还建议定义影响距离参数，这样每个点都只会有一个可控数量的 VPL 到达，控制计算量，如：</p><p>$$<br>\begin{cases}D_k&#x3D;\sqrt{S_0\mu^k}\ D_{N+1}&#x3D;D_{N}\end{cases}<br>$$</p><blockquote><p>个人理解见：<a href="#%E9%99%84%E5%BD%956">附录 6. 模拟传统层级的几何级下降的理解</a></p></blockquote><h1 id="4-实现细节"><a href="#4-实现细节" class="headerlink" title="4 实现细节"></a>4 实现细节</h1><h4 id="4-1-Pipeline-描述"><a href="#4-1-Pipeline-描述" class="headerlink" title="4.1 Pipeline 描述"></a>4.1 Pipeline 描述</h4><p>本论文提出的技术共用到三个 geometry pass，其中两个主要 pass 用于生成 GBuffer 和生成 Splat VPLs。第三个 pass 用于处理 Divergent triangle。如下图所示</p><img src="/images/Paper Notes/GI/Forward Light Cuts A Scalable Approach to Real-Time Global Illumination.assets/image-20220717013853277.png" alt="image-20220717013853277" style="zoom:50%;"><h4 id="4-2-Divergent-三角形处理"><a href="#4-2-Divergent-三角形处理" class="headerlink" title="4.2 Divergent 三角形处理"></a>4.2 Divergent 三角形处理</h4><p>在本论文提出的 indirect lighting pipeline 中包含了两个 geometry pass：第一个 pass 关闭 tessellation stage 处理整个场景的三角形，这个阶段检测出哪些是 Divergent 三角形，并存入单独的 buffer 中。剩下的 regular 三角形送入 regular pipeline。</p><p>存储 Divergent 三角形的 buffer 直接作为后续第二个 geometry pass 的输入。tessellation stage 只在这个 pass 开启，用于细分 divergent 三角形，使得它们的面积小到能够被 regular pipeline 处理。</p><blockquote><p>Tessellation stage 相比于 geometry 是开销是非常大的，因此使用一个 geometry 阶段过滤 regular 三角形，提高了效率。</p></blockquote><p>regular pipeline 即对 regular 三角形采样分级，再进行 VPL lighting 计算。</p><h4 id="4-3-Per-triangle-random-number-generation"><a href="#4-3-Per-triangle-random-number-generation" class="headerlink" title="4.3 Per-triangle random number generation"></a>4.3 Per-triangle random number generation</h4><p>本论文涉及的随机过程都需要随机数来完成，对于算法 1 用到的随机数 $\large u_{t_i}$，作者使用伪随机数。mesh 中每个顶点添加一个额外的 uint32 属性，v_rand。该属性在加载 mesh 时为每个顶点生成一个 uniform 随机数。在 regular pipeline 中，每个三角形的随机数 $\large u_{t_i}$ 是使用其三个顶点间的 $\large xor$ 操作得到的。</p><p>对于 tessellation stage 细分生成的新三角形，作者通过采样一张预计算的噪声贴图得到新顶点的随机值，采样坐标为新顶点的重心坐标，最后对新三角形顶点的随机数使用同样的 $\large xor$ 操作。</p><p>想要以上随机数每帧更新，以上随机数最终再与一个 uniform 的全局变量 u_rand 进行 $\large xor$ 操作，这个 uniform 全局变量大概要一帧更新一次。算法如下</p><img src="/images/Paper Notes/GI/Forward Light Cuts A Scalable Approach to Real-Time Global Illumination.assets/image-20220717013914497.png" alt="image-20220717013914497" style="zoom: 67%;"><h4 id="4-4-Progressive-rendering"><a href="#4-4-Progressive-rendering" class="headerlink" title="4.4 Progressive rendering"></a>4.4 Progressive rendering</h4><p>可以按照上述使用 u_rand 的方法生成多个 independent rendering，之后累积作平均用以产生更好的渲染结果。如，从 u_rand 中为每个三角形生成两个独立的随机数，用以扰动 VPL 中心点 $\large y_i$。平均由多个 jittered VPLs 生成的多个 independent rendering，可以提供接近公式 (4) 真实解的结果。</p><h1 id="5-Remain-Question"><a href="#5-Remain-Question" class="headerlink" title="5 Remain Question"></a>5 Remain Question</h1><ul><li><input disabled type="checkbox"> 划分整体过程中的整体应该怎么理解？</li><li><input disabled type="checkbox"> Splatting indirect illumination   技术不了解</li></ul><h1 id="6-Reference"><a href="#6-Reference" class="headerlink" title="6 Reference"></a>6 Reference</h1><p><a name="[1]">[1]</a> Gilles LAURENT, Cyril DELALANDRE, Grégoire de LA RIVIÈRE, and Tamy BOUBEKEUR. 2016. Forward Light Cuts: A Scalable Approach to Real-Time Global Illumination. <i>Comput. Graph. Forum</i> 35, 4 (July 2016), 79–88.</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="1-阈值-S-0-的启发式的理解"><a href="#1-阈值-S-0-的启发式的理解" class="headerlink" title="1. 阈值 $S_0$ 的启发式的理解"></a>1. <a name="附录1">阈值 $S_0$ 的启发式的理解</a></h2><p>以像素为球心、半径为 $D_{near}$ 的球面面积为 $4\pi D^2_{near}$，假设在距离 $D_{near}$ 内的 VPL 光源才能到达该像素，并且 $N_{avg}$ 个 VPL 共同作用下才能照亮该像素。由于本文中次级光源都假设为 diffuse，因此可粗略地认为 VPL 发出的 radiance 与面积成正比。这样下来，VPL 的平均面积 $4\pi \frac{D^2_{near}}{N_{avg}}$，高于此平均面积的三角形成为 divergent，剩下的三角形为  regular，regular 三角形生成的 VPL 具有可控的影响距离，divergent 三角形后续会进一步细分为小三角形。</p><h2 id="2-着色方程积分近似为求和的理解"><a href="#2-着色方程积分近似为求和的理解" class="headerlink" title="2. 着色方程积分近似为求和的理解"></a>2. <a name="附录2">着色方程积分近似为求和的理解</a></h2><p>首先来看精确的 rendering equation，</p><p>$$<br>L(x,\omega_o)&#x3D;\int_{\Omega^+}\space f_r(x,\omega_i\rightarrow\omega_o)L_i(x’,\omega_i)cos\theta \space d\omega_i<br>$$<br>上式为对立体角的积分，转为对光源面积的积分为</p><p>$$<br>L(x,\omega_o)&#x3D;\int_{A}\space f_r(x,\omega_i\rightarrow\omega_o)L_i(x’,\omega_i)\frac{cos\theta cos\theta’}{||x’-x||^2} \space dA<br>$$</p><p>$L^{ML}$ 的形式即从对光源面积的积分近似而来，diffuse 下 BRDF 是常量，即 $H$ 中的 $\large\frac{\rho_x}{\pi}$，$L_i$ 对应 $H$ 中的 $L$。因此，$L^{ML}(x,\vec{n_x})$ 与 $L(x,\omega_o)$ 唯一不同的是一个是对总体面积的连续积分，一个是将每个 VPL 的面积视为微元的离散求和。可知，在 VPL 面积较小时，这种近似较为接近正确。</p><h2 id="3-VPL-lighting-推导"><a href="#3-VPL-lighting-推导" class="headerlink" title="3. VPL lighting 推导"></a>3. <a name="附录3">VPL lighting 推导</a></h2><p>将划分的三角形所有子集看作一个整体求和符号有：$\sum\limits^N_{k&#x3D;0}\sum\limits_{t_i^k\in \mathcal{L}^k}&#x3D;\sum\limits_{t_i\in \mathcal{L}}$</p><blockquote><p> 因为 $t_i^k$ 本就代表是子集 $\mathcal{L}^k$ 中的三角形，可知 $\large \mathbb{I}_{t_i^k\in \mathcal{L}^k}$ 恒为 $1$，因此有</p></blockquote><p>$\mathbb{E}\left[\sum\limits^N_{k&#x3D;0}\sum\limits_{t_i^k\in \mathcal{L}^k}H(t_i^k,x,\vec{n_x})F^k(t_i^k,x)\right]&#x3D;\mathbb{E}\left[\sum\limits^N_{k&#x3D;0}\sum\limits_{t_i^k\in \mathcal{L}^k}H(t_i^k,x,\vec{n_x})F^k(t_i^k,x)\mathbb{I}_{t_i^k\in \mathcal{L}^k}\right]$，</p><blockquote><p> 将和的期望转为期望的和</p></blockquote><p>$&#x3D;\sum\limits^N_{k&#x3D;0}\sum\limits_{t_i^k\in \mathcal{L}^k}\mathbb{E}\left[H(t_i^k,x,\vec{n_x})F^k(t_i^k,x)\mathbb{I}_{t_i^k\in \mathcal{L}^k}\right]$，</p><blockquote><p>此时由于指示函数的存在可将三角形子集看作一个整体求和，</p></blockquote><p>$&#x3D;\sum\limits_{t_i\in \mathcal{L}}\mathbb{E}\left[H(t_i,x,\vec{n_x})F^k(t_i,x)\mathbb{I}_{t_i\in \mathcal{L}^k}\right]$，</p><blockquote><p>$H(t_i,x,\vec{n_x})$ 与随机划分无关，对于期望而言是常量，可以提出期望计算外，即</p></blockquote><p>$&#x3D;\sum\limits_{t_i\in \mathcal{L}}H(t_i,x,\vec{n_x})\mathbb{E}\left[F^k(t_i,x)\mathbb{I}_{t_i\in \mathcal{L}^k}\right]$，</p><blockquote><p>接下来进行一个恒等变换，$F^k(t_i,x)\mathbb{I}<em>{t_i\in \mathcal{L}^k}&#x3D;\sum\limits^N</em>{k&#x3D;0}F^k(t_i,x)\mathbb{I}<em>{t_i\in \mathcal{L}^k}$，因为对于每一个 $t_i$，只会有一个 $k$ 值使得 $\large \mathbb{I}</em>{t_i\in \mathcal{L}^k}&#x3D;1$，其余都为 $0$。</p></blockquote><p>$&#x3D;\sum\limits_{t_i\in \mathcal{L}}H(t_i,x,\vec{n_x})\sum\limits^N_{k&#x3D;0}\mathbb{E}\left[F^k(t_i,x)\mathbb{I}_{t_i\in \mathcal{L}^k}\right]$，</p><blockquote><p>目前期望计算中只有指示函数与随机划分相关，且易知  $\mathbb{E}\left[\mathbb{I}_{t_i\in \mathcal{L}^k}\right]&#x3D;P(t_i\in \mathcal{L^k})$ ，有</p></blockquote><p>$\mathbb{E}\left[F^k(t_i,x)\mathbb{I}<em>{t_i\in \mathcal{L}^k}\right]&#x3D;F^k(t_i,x)\mathbb{E}\left[\mathbb{I}</em>{t_i\in \mathcal{L}^k}\right]&#x3D;F^k(t_i,x)P(t_i\in \mathcal{L^k})$</p><blockquote><p>最终有</p></blockquote><p>$ \sum\limits_{t_i\in \mathcal{L}}H(t_i,x,\vec{n_x})\sum\limits^N_{k&#x3D;0}F^k(t_i,x)P(t_i\in \mathcal{L}^k)$</p><h2 id="4-转为整体划分问题推导"><a href="#4-转为整体划分问题推导" class="headerlink" title="4. 转为整体划分问题推导"></a>4. <a name="附录4">转为整体划分问题推导</a></h2><p>由 $\eqref{partition probability}$ 式代入 $\eqref{many light estimator}$ 中有</p><p>$$\forall x,\quad \sum\limits_k F^k(t_i,x)\frac{\mathcal{A}(t_i)}{S_k}&#x3D;\mathcal{A}(t_i)$$</p><p>$$\forall x,\quad \sum\limits_k \frac{F^k(t_i,x)}{S_k}&#x3D;1$$</p><p>假设未知函数 $f^k(t_i,x)$ 使得 $F^k(t_i,x)&#x3D;S_kf^k(t_i,x)$，那么有</p><p>​$\sum\limits_kf^k(t_i,x)&#x3D;1$</p><h2 id="5-整体划分选取推导"><a href="#5-整体划分选取推导" class="headerlink" title="5. 整体划分选取推导"></a>5. <a name="附录5">整体划分选取推导</a></h2><blockquote><p>当 receiver 正对着 emitter 时，将 $\vec{n_x}&#x3D;\bar{xy_i}$ 代入 $\eqref{received radiance}$，有</p></blockquote><p>$\begin{align}\underset{\vec{n_x}}{max}\space H(t_i,x,\vec{n_x})&amp;&#x3D;\frac{3}{2\pi^2}\rho_i\rho_xE(t_i)\frac{(&lt;\vec{n_i},\bar{y_ix}&gt;)^2}{d_i^2}\&amp;&#x3D;\frac{3}{2\pi^2}\rho_i\rho_xE(t_i)\left(\frac{&lt;\vec{n_i},\bar{y_ix}&gt;}{||x-y_i||}\right)^2\end{align}$​</p><blockquote><p>将 $\large H$ 代入公式 $\eqref{partition nested ball}$ 有</p></blockquote><p>$$\frac{3}{2\pi^2}\rho_i\rho_xE(t_i)\left(\frac{&lt;\vec{n_i},\bar{y_ix}&gt;}{||x-y_i||}\right)^2 \geq h$$</p><p>$$\left(\frac{&lt;\vec{n_i},\bar{y_ix}&gt;}{||x-y_i||}\right)^2 \geq \frac{2h\pi^2}{3\rho_i\rho_xE(t_i)}$$</p><p>$$\frac{&lt;\vec{n_i},\bar{y_ix}&gt;}{||x-y_i||} \geq \pi \sqrt{\frac{2h}{3\rho_i\rho_xE(t_i)}}$$</p><p>$$\frac{||x-y_i||}{&lt;\vec{n_i},\bar{y_ix}&gt;} \leq \frac{1}{\pi} \sqrt{\frac{3\rho_i\rho_xE(t_i)}{2h}}$$</p><h2 id="6-模拟传统层级的几何级下降的理解"><a href="#6-模拟传统层级的几何级下降的理解" class="headerlink" title="6. 模拟传统层级的几何级下降的理解"></a>6. <a name="附录6">模拟传统层级的几何级下降的理解</a></h2><p>这里的模拟层级表示而引入几何级下降的参数配置：例如满二叉树的层级表示，根节点层(0层)节点数量为 $S_0&#x3D;1$ 个，往下每层数量是前一层的 2 倍，即有 $S_k&#x3D;S_0 2^k$ 个，为几何级增长。</p>]]></content>
    
    
    <categories>
      
      <category>Paper Notes</category>
      
      <category>GI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
