---
typora-copy-images-to: ${filename}.assets
typora-root-url: .\
mathjax: true
---

# 1 基础

## 1.1 多态

虚表、虚函数、虚表指针

## 1.2 静态链接 vs 动态链接

二者区别，链接器做了什么

链接 .o 在做什么，dll 内存是否共享

## 1.3 智能指针

shared_ptr实现

## 1.4 存储区域

### 1.4.1 进程内存布局

<img src="/C++.assets/image-20241114110433327.png" alt="image-20241114110433327" style="zoom:50%;" />

- Code Segment(代码区)：也称Text Segment，存放可执行程序的机器码
- Data Segment(数据区)：存放已初始化的全局和静态变量， 常量数据，如字符串常量
- BSS(Block started by symbol)：存放未初始化的全局和静态变量，默认设为0
- Heap(堆)：从低地址向高地址增长。容量大于栈，程序中动态分配的内存在此区域。
- Stack(栈)：从高地址向低地址增长。由编译器自动管理分配。程序中的局部变量、函数参数值、返回变量等存在此区域

#### 1.4.1.1 全局/静态变量

当全局/静态变量未初始化的时候，记录在BSS段。处于BSS段的变量的值默认为0，因此 BSS 段内部无需存储大量的零值，而只需记录字节个数即可。系统载入可执行程序后，将BSS段的数据载入数据段(Data Segment)，并将内存初始化为 0，再调用程序入口(main函数)。

而对于已经初始化了的全局/静态变量而言，如声明即初始化，则一直存储于数据段(Data Segment)。

### 1.4.2 栈与堆

#### 1.4.2.1 分配方式不同

- 栈由系统自动分配

- 堆需要程序员自己申请，并指明大小。如 

  - C 中 `p1 = (char *)malloc(10);` 
  - C++ 中 `p2 = (char *)new(10);`

  注意，指针变量还是在栈中

#### 1.4.2.2 空间大小不同

一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。

#### 1.4.2.3 分配效率

- 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，**压栈出栈都有专门的指令执行，这就决定了栈的效率比较高**。
- 堆则是 C/C++ 函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，**堆的效率比栈要低得多**。 

#### 1.4.2.4 碎片

- 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。

- 堆：

  - 首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，

  - 另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的 delete 语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。        

  - 对于堆来讲，频繁的 new/delete 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。

  - 对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。 

#### 1.4.2.5 生长方向

- 栈：生长方向是向下的，向着内存地址减小的方向增长。    

- 堆：生长方向是向上的，向着内存地址增加的方向增长；

### 1.4.3 内存对齐

#### 1.4.3.1 内存对齐的好处

处理器存取内存的单位往往不是字节，例如 32 位系统上，以 4 字节为单位存取内存，因此该处理器只能从地址为 4 的倍数的内存开始读取数据。

假设内存没有对齐，数据以字节大小的地址为单位任意存放，一个 int 变量可能分散到两个 4 字节块中，因此需要读取两个 4 字节块，并移除首尾不需要的字节，再进行合并，非常耗时。如下所示

<img src="/C++.assets/image-20241114111222182.png" alt="image-20241114111222182" style="zoom: 33%;" />

如果内存对齐，一个 int 变量正好只占用一个 4 字节块，因此仅需要一次读取操作。CPU 可以在对齐的内存字上进行的赋值/读取操作是原子操作。

#### 1.4.3.2 内存对齐规则

基础类型的对齐值为其 sizeof 值，而结构体中**有效对齐值**为结构体中最宽成员和编译器/用户指定对齐值之间的**较小者**：

- 结构体起始地址为有效对齐值的整数倍
- 结构体总大小为有效对齐值的整数倍
- 结构体的第一个成员偏移量为 0，之后成员的偏移量为 min(有效对齐值, 自身大小) 的整数倍

#### 1.4.3.3 指定内存对齐值

不同的编译器一般都会有默认的对齐量，一般为 2 的幂次。在 C 中可以通过预编译命令修改对齐量，如

```c
#pragma pack(n)
```

最终的有效对齐量会取结构体最宽成员和编译器/用户指定对齐量中的较小值，C++ 中的对齐操作：

- **alignas**：可以指定对齐量，应用于类/结构体/union/枚举/变量的定义。alignas 指定的对齐量不能小于默认对齐
- **alignof**：返回类型的对齐值，如果是数组，则返回元素类型的对齐值

### 1.4.4 new/delete 与 malloc/free

new/delete 底层内存操作默认使用 malloc/free 实现，malloc/free 是 libc 库函数，主要实现了一套内存管理机制，当其管理的内存不够时，通过 brk/mmap 等系统调用向内核申请进程的虚拟地址区间，如果其维护的内存能满足 malloc 调用，则直接返回，free时会将地址块返回空闲链表。因此内存申请有可能触发系统调用，引发系统内核上下文环境切换，开销会较高。

#### 1.4.4.1 属性上的区别

- new/delete：C++中的关键字，属于操作符，若要使用，需要编译器支持；

- malloc/free：库函数，若要使用则需要引入相应的头文件才可以正常使用。

#### 1.4.4.2 使用上的区别

- malloc：申请空间需要显式填入申请内存的大小；

- new：无需显式填入申请的内存大小，new 会根据 new 的类型分配内存。

#### 1.4.4.3 内存位置的区别

- new：此操作符分配的内存空间是在**自由存储区**；

- malloc：申请的内存是在堆空间。

自由存储区可以是堆、全局/静态存储区等，具体是在哪个区，主要还是要看 new 的实现以及 C++ 编译器默认 new 申请的内存是在哪里，绝大多数在堆上。但运算符 new/delete 内部默认是使用 malloc/free 的方式来被实现，因此也可以说是在堆上。

在 C++ 中 new/delete 操作符是可以重载的，我们可以重新实现 new 的实现代码，可以让其分配的内存位置在静态存储区等。而 malloc/free 是 C 里的库函数，无法对其进行重载。

#### 1.4.4.4 返回类型的区别

- new 操作符内存分配成功时，返回的是对象类型的指针，无须进行类型转换，故 new 是符合类型安全性的操作符
- malloc 内存分配成功则是返回 void * ，需要强制类型转换成所需类型。在 C++ 程序中 new 会比 malloc 安全可靠

#### 1.4.4.5 分配失败情况的区别

- malloc 分配内存失败时返回 NULL，可以通过判断返回值可以得知是否分配成功

- new 内存分配失败时，会抛出 bac_alloc 异常，不会返回 NULL，如果不捕捉异常，那么程序就会异常退出

#### 1.4.4.6 动态分配对象内存

使用 new 操作符来分配对象内存时会经历三个步骤：

1. 调用`operator new()`函数(对于数组是operator new\[\]())来分配一块内存空间(底层通常使用 malloc 实现，除非重载 new 符号)以便存储特定类型的对象
2. 运行相应的构造函数以构造对象，并为其传入初值
3. 对象构造完成后，返回一个指向该对象的指针

使用 delete 操作符来释放对象内存时会经历两个步骤：

1. 调用对象的析构函数
2. 编译器调用`operator delete`(或operator delete[])函数释放内存空间(通常底层默认使用 free 实现，除非重载delete 符号)

### 1.4.5 new 运算符

new 运算符主要完成两个操作：调用 operator new() 函数，动态分配内存；在分配的内存上调用构造函数，以初始化相应类型的对象，并返回首地址。这里的内存分配默认是 libc 库管理的，如果此时没有可用的堆内存，则会进行系统调用，为进程申请内存。系统调用的开销较大，会造成性能的不稳定。

我们可以重载 operator new 来实现自己的内存分配，标准库中就有几种重载

#### 1.4.5.1 placement new

placement new 可以指定执行构造类型的内存块，即可以将内存分配与构造分离，形式为`new (ptr) Type(params)`。可用于实现内存池，预申请一块较大的内存，之后的内存分配都在已经申请好的内存池中操作，开销较小。placement new 所调用的 operator new 的重载形式，如

```c++
inline void* __CRTDECL operator new(size_t _Size, void* _Where) noexcept
```

#### 1.4.5.2 aligned new

另一种 operator new 的重载是可以指定内存对齐值，其使用形式如`new(std::align_val_t{ 32 }) Type(params)`。operator new 的重载形式如

```c++
void* __CRTDECL operator new(size_t _Size, std::align_val_t _Al)
```



## 1.5 关键字

### 1.5.1 inline

原理，什么时候必须inline

### 1.5.2 volatile

类型修饰符，用来修饰被不同线程访问和修改的变量（硬件IO地址，会被程序之外的不可知作用改变）。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。如下面代码：

```c++
int i = 10;
int a = i;
int b = i; 
```

由于编译器发现两次从 i 读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。如果在 a、b 赋值语句之间插入修改 i 的汇编代码：

```assembly
__asm {
	mov dword ptr [ebp-4], 20h	// 将 i 值修改为 32
}
```

编译器开启优化发现 a、b 的值都为 10；不开优化则 a 为 10，b 为 32。而如果对 i 使用 volatile 修饰，b 都为 32，正是期待的结果。

对于指针，volatile 与 const 同样有两种方式，修饰指向的内容、修改指针变量。

# 2 STL

## 2.1 vector

可变大小的动态数组，使用连续内存，支持随机存取；在尾部之外的位置插入/删除元素，会导致其后所有元素的移动，如果引起内存重新分配，则会导致所有元素拷贝；当空间不够装下新来数据时，会自动申请另一片更大的空间（1.5倍或者2倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间；当释放或者删除（clear()）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。如果对vector的任何操作一旦引起了空间的重新配置，指向原 vector 的所有迭代器会都失效了。

- **size 和 capacity**：size 表示当前 vector 中有多少个元素；而 capacity 则表示它已经分配的内存中可以容纳多少元素
- **reserve 与 resize**：reserve 是将空间大小（capacity）直接扩充到指定大小；resize() 可以改变有效空间的大小，也有改变默认值的功能，capacity 的大小也会随着改变。
- **vector的元素类型不能是引用**：vector的底层是连续的内存，要求连续的对象排列**，**引用并非对象，没有实际地址
- **vector迭代器失效的情况**：发生内存重新分配，所有迭代器失效；由于使连续内存，因此删除/插入一个元素时，会使后面所有迭代器也会失效，erase方法会返回下一个有效的迭代器，`it=vec.erase(it);`；
- **正确释放 vector 的内存**：
  - `vec.clear()`：清空内容，但是不释放内存。
  - `vector<int>().swap(vec)`：清空内容，且释放内存，想得到一个全新的vector。
  - `vec.shrink_to_fit()`：请求容器降低其 capacity 和 size 匹配。
  - `vec.clear();vec.shrink_to_fit();`：清空内容，且释放内存。

### 2.1.1 vector 扩容

vector 扩容为什么要以1.5倍或者2倍扩容?

- 1.5 倍更好，扩容几次之后，下次扩容的所需内存可以被之前的申请的内存总和满足，能够重用（vs的方式）；
  而 >= 2倍扩容，每次扩容的大小都超过之前内存之和，无法复用之前的内存。
  windows 的堆管理会对相邻空闲内存块合并
- （linux gcc的方式）2倍扩容。对于给定次数的元素插入，倍数扩容的拷贝操作要比等长扩容少
  linux 使用 basic size 的1倍、2倍、... 管理内存



2.2 unordered_map

底层hash 冲突怎么解决（说了 链表 和 linear probing）问两种的优劣（他说 STL 实现是前者，我说后者会和别人抢占槽位，但内存是连续的有 cache）问觉得 vector 和 list 遍历速度差能有多少

2.3 



# 3 多线程

## 3.1 锁

### 3.1.1 自旋锁和互斥锁

自旋锁和互斥锁是什么？哪个性能好？互斥锁会导致线程或系统进入什么状态？

自旋锁是一种忙等待的同步机制。当一个线程尝试获取被占用的自旋锁时，它会一直循环检查锁是否可用，而不会让出CPU。

互斥锁是一种阻塞式的同步机制。当一个线程尝试获取被占用的互斥锁时，它会被挂起（加入等待序列），直到锁变为可用。

- 短期持有锁：自旋锁通常性能更好，因为它避免了线程切换的开销。
- 长期持有锁：互斥锁通常性能更好，因为它不会浪费CPU资源。
- 多核系统：自旋锁在多核系统中可能表现更好，特别是在锁竞争不激烈的情况下。
- 单核系统：互斥锁通常更适合单核系统，因为自旋会浪费宝贵的CPU时间。

当线程尝试获取一个已被占用的互斥锁时，它会进入以下状态：

- 阻塞状态（Blocked State）：线程会被挂起，等待锁变为可用。
- 就绪状态（Ready State）：当锁被释放时，等待该锁的线程会被唤醒并进入就绪状态，等待调度器分配CPU时间。

### 3.1.2 读写锁



## 3.2 同步机制





# 4 内存

怎么设计内存分配怎么回收内存使它能比较好地融入未分配内存提示说分配的时候就要做设计

内存模型



# 5 题目

1 delete this，struct的内存对齐、虚继承为了解决什么问题？



2 nullptr 调用成员函数

```c++
struct A {
	void f() { cout << "ok"; }
}
A* a = nullptr;
a->f();	// 输出 ok
```

把f变为虚函数，其他不变，会出现 segment fault

a->f()，其实是 A::f(a)，普通成员函数内部没有使用this指针，所以可以调用



3 sizeof(void*) 字节对齐

指针大小，4。编译的目标平台



4 虚函数，虚函数表可以被修改吗

https://bbs.kanxue.com/thread-254937.htm

强行改也可以，虚表指针会存放在对象首地址，通过系统API修复虚表指针指向区域的访问保护属性，修改其中的函数指针

5 有一段内存如果不希望他被任何人修改，应该怎么做？（求问💡）这个？https://stackoverflow.com/questions/14931477/is-there-a-way-to-mark-a-chunk-of-allocated-memory-readonly

windows 和 linux 有系统API修改内存区域的访问保护属性



平时写程序崩了怎么定位在哪一行，如果是exe呢

模板的定义为什么放在 hpp，可以在 cpp 吗
